{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Database schema expansion for Quick Dump queue and medical features",
        "description": "Add quick_dumps table and extend cards/notes tables to support medical list processing, partial credit, response time tracking, and connection suggestions",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create quick_dumps table schema and migration logic",
            "description": "Add quick_dumps table to database.ts with proper schema, types, and version migration from user_version=1 to user_version=2",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extend cards table with medical feature columns",
            "description": "Add cardType, parentListId, and listPosition columns to cards table through schema migration",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extend review_logs table with performance tracking columns",
            "description": "Add responseTimeMs and partialCreditScore columns to review_logs table for tracking review performance metrics",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create connections table for semantic note relationships",
            "description": "Add connections table to store semantic relationships between notes with similarity scores",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement query functions and IPC handlers for new tables",
            "description": "Create quickDumpQueries and connectionQueries objects, add corresponding IPC handlers in ipc-handlers.ts, and expose via preload.ts",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-05T00:05:06.017Z"
      },
      {
        "id": "2",
        "title": "AI service integration layer",
        "description": "Create local-first AI service with Ollama auto-detection, cloud fallbacks (OpenAI, DeepSeek, Anthropic), concept extraction, card format suggestions, and medical content processing",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AI provider abstraction and type definitions",
            "description": "Set up local-first provider detection, OpenAI-compatible SDK configuration, and all AI-related types",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:12:15.700Z"
          },
          {
            "id": 2,
            "title": "Implement concept extraction and card validation functions",
            "description": "Build extractConcepts and validateCard functions with provider-aware timeout and retry logic",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:15:33.268Z"
          },
          {
            "id": 3,
            "title": "Implement medical list detection and vignette conversion",
            "description": "Create functions to detect medical lists and convert list items to clinical vignettes",
            "dependencies": [
              1,
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:17:15.711Z"
          },
          {
            "id": 4,
            "title": "Implement tag suggestions and semantic similarity search",
            "description": "Build AI-powered tag suggestion and note similarity matching functions",
            "dependencies": [
              1,
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:19:43.555Z"
          },
          {
            "id": 5,
            "title": "Add caching layer and IPC handlers for AI service",
            "description": "Implement 5-minute result caching, provider status, and integrate AI service with IPC layer",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:22:53.351Z"
          }
        ],
        "updatedAt": "2026-01-05T01:22:53.351Z"
      },
      {
        "id": "3",
        "title": "[ARCHIVED] AI-guided capture interface (v1)",
        "description": "ARCHIVED: v1 capture flow with AI concept extraction checkboxes. Superseded by v2 Two-Mode Capture (T118). Kept for historical reference.",
        "details": "Original flow: paste → AI extracts concepts → checkboxes → format suggestion → batch card creation. v2 uses simpler Save to Inbox flow.",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-05T14:29:44.672Z"
      },
      {
        "id": "5",
        "title": "Zero-decision review interface (eliminate grading buttons)",
        "description": "Replace 4-button grading (Again/Hard/Good/Easy) with Show Answer → Continue flow, letting FSRS auto-schedule based on response time",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove grading buttons and interval preview UI",
            "description": "Remove the 4-button grading interface (Again/Hard/Good/Easy) and interval previews from ReviewInterface.tsx",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.586Z"
          },
          {
            "id": 2,
            "title": "Implement Show Answer → Continue flow with response time tracking",
            "description": "Replace grading buttons with single Continue button and add response time tracking from card shown to Continue pressed",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.591Z"
          },
          {
            "id": 3,
            "title": "Implement auto-rating algorithm based on response time",
            "description": "Create algorithm to automatically determine Rating based on response time: <5s=Easy, 5-15s=Good, 15-30s=Hard, >30s=Again",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.595Z"
          },
          {
            "id": 4,
            "title": "Update scheduleReview to accept and store responseTimeMs",
            "description": "Modify scheduleReview function and review_logs table to accept and persist response time in milliseconds",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.598Z"
          },
          {
            "id": 5,
            "title": "UI cleanup and zero-decision interface verification",
            "description": "Clean up UI after removing grading buttons, verify progress bar and session stats work, ensure FSRS performance <100ms",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.600Z"
          },
          {
            "id": 6,
            "title": "Auto-grade animation feedback display",
            "description": "Show brief visual feedback of the auto-determined grade (Easy/Good/Hard/Again) for ~1 second after Continue pressed, before advancing to next card",
            "dependencies": [
              5
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.603Z"
          },
          {
            "id": 7,
            "title": "Quick override mechanism during feedback display",
            "description": "Allow user to override auto-grade during the 1-second feedback window using keyboard shortcuts (1-4) or clicking alternative grades",
            "dependencies": [
              6
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.607Z"
          }
        ],
        "updatedAt": "2026-01-06T00:32:13.607Z"
      },
      {
        "id": "10",
        "title": "Global search with <200ms response time",
        "description": "Implement fast unified search across cards and notes with FTS5 full-text search, Cmd+F shortcut, instant results",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create FTS5 virtual tables for cards, notes, and source_items with sync triggers",
            "description": "Implement FTS5 full-text search tables with automatic synchronization triggers for all searchable content",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement searchQueries.search() with filter support and performance tracking",
            "description": "Create unified search function that queries all FTS tables with filter options (all/cards/notes/inbox) and tracks response time",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add IPC handler, preload exposure, and TypeScript types for search",
            "description": "Wire up search functionality through IPC layer with proper type definitions",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build basic SearchBar component with debounced query and results dropdown",
            "description": "Replace placeholder SearchBar with functional component that performs real-time search with debounced input and displays top 10 results in dropdown",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add horizontal filter chips UI with toggleable selection and count badges",
            "description": "Implement filter chip buttons (All/Cards/Notes/Inbox) above search results with active state and result counts",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement keyboard navigation and Ctrl+F global shortcut",
            "description": "Add full keyboard support for search including Up/Down/Enter/Escape navigation and global Ctrl+F hotkey to focus search bar",
            "dependencies": [
              5
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add search term highlighting in result snippets",
            "description": "Implement visual highlighting of matched search terms in result text using FTS5 snippet() function",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create full SearchResults page component with sections and view-all navigation",
            "description": "Build dedicated full-page search results view with categorized sections, showing all matches beyond the 10-result dropdown limit",
            "dependencies": [
              7
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-06T05:12:32.737Z"
      },
      {
        "id": "17",
        "title": "Auto-start Ollama from Electron on first AI request",
        "description": "Automatically start Ollama when the app needs AI services, eliminating the friction of manually starting Ollama before using the app",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ensureOllamaRunning() function with process spawning",
            "description": "Create function to check Ollama status and spawn it if not running",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate auto-start into AI client initialization",
            "description": "Update initializeClient() to call ensureOllamaRunning() when Ollama provider is detected",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add user notification for Ollama status via IPC",
            "description": "Notify renderer process about Ollama auto-start status so user sees feedback",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Handle cross-platform Ollama executable detection",
            "description": "Ensure Ollama can be found and started on Windows, macOS, and Linux",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-06T05:29:32.390Z"
      },
      {
        "id": "31",
        "title": "BUG FIX: Quick Dump saves to notes table instead of quick_dumps table",
        "description": "QuickDumpModal incorrectly saves content as a regular note instead of to the quick_dumps table, breaking the extraction queue workflow",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:11:06.148Z"
      },
      {
        "id": "35",
        "title": "[v2-T1] Data model v3: SourceItem, CanonicalTopic, NotebookTopicPage, SmartView schemas",
        "description": "Implement the v2 architecture data model with new tables for 3-layer system: Knowledge Bank (SourceItem), Notebook (NotebookTopicPage, NotebookBlock), and enhanced Cards with provenance. Add CanonicalTopic for topic normalization and SmartView for filtered access.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces for v3 data model",
            "description": "Create TypeScript interfaces in src/types/index.ts for SourceItem, CanonicalTopic, NotebookTopicPage, NotebookBlock, SmartView, and SmartViewFilter. Update Card interface with optional provenance fields.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create database schema v3 with migration from v2",
            "description": "Implement new tables (source_items, canonical_topics, notebook_topic_pages, notebook_blocks, smart_views) in electron/database.ts with migration from schema v2 to v3.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CRUD functions for new tables",
            "description": "Add database query functions for SourceItem, NotebookTopicPage, NotebookBlock, CanonicalTopic, and SmartView in electron/database.ts following existing pattern.",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Wire IPC handlers for new CRUD operations",
            "description": "Register IPC handlers in ipc-handlers.ts, expose via preload.ts, and declare types in electron.d.ts for all new database operations.",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update test helpers with new schema",
            "description": "Add new table creation to tests/helpers/db-helpers.ts ensuring test database schema matches production v3 schema.",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "36",
        "title": "[v2-T1.1] Topic normalization: alias table, matching rules, dedupe prevention",
        "description": "Implement topic alias matching system that normalizes user input to canonical topics. 'HOCM', 'HCM', 'hypertrophic cardiomyopathy' should all resolve to the same CanonicalTopic.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create electron/topic-service.ts with core alias resolution functions",
            "description": "Implement resolveTopicAlias() and createOrGetTopic() functions for basic topic alias lookup and creation with automatic alias generation",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2026-01-06T14:43:34.428Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement suggestTopicMatches() with fuzzy search for autocomplete",
            "description": "Add fuzzy search function to suggest topic matches using simple string similarity for autocomplete dropdown",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T14:54:58.758Z"
          },
          {
            "id": 3,
            "title": "Implement addTopicAlias() with uniqueness validation",
            "description": "Add function to add new aliases to existing topics with duplicate prevention across all topics",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T15:05:57.395Z"
          },
          {
            "id": 4,
            "title": "Implement mergeTopics() with transactional safety and reference updates",
            "description": "Add topic merging function that consolidates aliases and updates all references in source_items and notebook_topic_pages tables",
            "dependencies": [
              1,
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T15:37:46.360Z"
          },
          {
            "id": 5,
            "title": "Wire IPC handlers and create TopicAutocomplete UI component",
            "description": "Register IPC handlers for topic operations and build React autocomplete component with debounced search and dropdown suggestions",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T15:44:32.497Z"
          }
        ],
        "updatedAt": "2026-01-06T15:44:32.497Z"
      },
      {
        "id": "38",
        "title": "[v2-T2] Capture pipeline: Quick Dump → SourceItem (inbox), text + image support",
        "description": "Implement capture flow that creates SourceItems in Knowledge Bank with inbox status. Support text paste and image paste/drop.",
        "details": "TEXT CAPTURE: Complete ✓. IMAGE CAPTURE: NOT IMPLEMENTED (T38.2-T38.3 pending). Database supports images but UI lacks handlers.",
        "testStrategy": "Test text capture (working), test image capture (pending)",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update QuickDumpModal to create SourceItems instead of QuickDumps",
            "description": "Refactor QuickDumpModal.tsx to use sourceItems.create API, mapping text content to SourceItem schema with sourceType='quickcapture' and status='inbox'.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T02:38:03.709Z"
          },
          {
            "id": 2,
            "title": "Add image paste/drop support to QuickDumpModal",
            "description": "Implement clipboard paste and drag-drop handlers for images in QuickDumpModal, with visual preview and content type detection.",
            "dependencies": [
              1
            ],
            "details": "CRITICAL: NOT IMPLEMENTED. T38.2 was marked DONE incorrectly. QuickDumpModal only handles text paste (clipboardData.getData('text')). No image handlers exist for clipboardData.files or clipboardData.items. Database schema supports images (imageData BLOB) but UI does not.",
            "status": "cancelled",
            "testStrategy": "Test image paste from clipboard, drag-drop image files, verify preview displays, confirm imageData saves to DB",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T00:32:52.755Z"
          },
          {
            "id": 3,
            "title": "Implement image file storage and mediaPath handling",
            "description": "Create IPC handler for saving image files to app data directory and returning relative path for mediaPath field.",
            "dependencies": [
              2
            ],
            "details": "Depends on T38.2. No IPC handlers exist for image save operations. Need: saveImage(buffer) IPC handler, file storage in app.getPath('userData')/images/, return mediaPath for DB storage.",
            "status": "cancelled",
            "testStrategy": "Save image via IPC, verify file exists in userData/images/, confirm mediaPath stored in sourceItems table, test image retrieval",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T00:32:52.758Z"
          },
          {
            "id": 4,
            "title": "Add inboxCount state management to useAppStore",
            "description": "Extend useAppStore with inboxCount state that queries source_items table for items with status='inbox', and refreshes after captures.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2026-01-06T02:33:30.360Z",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Wire Sidebar to display inbox badge count from useAppStore",
            "description": "Connect Sidebar component to useAppStore.inboxCount and replace hardcoded inboxCount=0 with live state.",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T02:33:30.460Z"
          }
        ],
        "updatedAt": "2026-01-07T00:32:56.159Z"
      },
      {
        "id": "40",
        "title": "[v2-T3] Knowledge Bank UI: vertical list grouped by status, search, filters",
        "description": "Build the main Knowledge Bank view showing all SourceItems organized by status with filtering and search capabilities.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create StatusGroup collapsible component (COMPLETE)",
            "description": "StatusGroup.tsx component is already complete with collapsible status sections, badge styling, and chevron animations.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create KnowledgeBankView with status-grouped layout",
            "description": "Build main Knowledge Bank view component fetching all SourceItems and organizing them into 3 collapsible StatusGroup sections (Inbox, Processed, Curated) using existing row components.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2026-01-06T20:44:26.020Z",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add search and filter controls to KnowledgeBankView",
            "description": "Implement real-time search input (debounced 200ms) and multi-select filters (status, source type) with AND logic to filter visible items in Knowledge Bank.",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T20:57:59.367Z"
          }
        ],
        "updatedAt": "2026-01-06T20:57:59.367Z"
      },
      {
        "id": "41",
        "title": "[v2-T4] Notebook UI: topic pages, add blocks from sources, enforce card-creation here only",
        "description": "Build the Notebook layer with topic pages containing blocks from Knowledge Bank. This is the ONLY place where cards can be created.",
        "details": "NOTEBOOK VIEW:\n\n1. TOPIC PAGE LIST:\n- Sidebar or list showing all NotebookTopicPages\n- Show: topic name, aliases, card count, source count\n- Search/filter by topic name\n- 'New Topic Page' button\n\n2. TOPIC PAGE VIEW:\n- Header: Topic name, aliases, stats\n- Blocks section: excerpts from SourceItems\n- Each block shows:\n  - Source reference (clickable deep link)\n  - Content excerpt\n  - Annotations (user notes)\n  - Actions: [Edit] [→ Source] [Generate Card]\n- Footer: [+ Add from Knowledge Bank] [Generate All Cards]\n\n3. ADD BLOCK FLOW:\n- Click '+ Add from Knowledge Bank'\n- Modal shows Knowledge Bank filtered to curated/processed\n- Select source item\n- Select excerpt (highlight text) or use full content\n- Save creates NotebookBlock linked to source\n- SourceItem status → 'curated'\n\n4. BLOCK MANAGEMENT:\n- Drag to reorder blocks (position field)\n- Edit block content (excerpt)\n- Add annotations\n- Delete block (doesn't delete source)\n\nCARD CREATION ENFORCED:\n- 'Generate Card' button ONLY appears on blocks\n- No card creation in Knowledge Bank\n- No card creation from scratch\n- All cards have notebookTopicPageId (enforced)\n\nCOMPONENTS:\n\n- src/components/notebook/NotebookView.tsx\n- src/components/notebook/TopicPageList.tsx\n- src/components/notebook/TopicPageView.tsx\n- src/components/notebook/NotebookBlock.tsx\n- src/components/notebook/AddBlockModal.tsx",
        "testStrategy": "Create topic page, add block from source, verify deep link works. Generate card from block, verify card has notebookTopicPageId. Verify no way to create card outside Notebook.",
        "priority": "high",
        "dependencies": [
          "40",
          "36"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NotebookView container component with routing integration",
            "description": "NotebookView.tsx renders when currentView='notebook'. Pattern: KnowledgeBankView.tsx",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build TopicPageList sidebar with search and new topic creation",
            "description": "TopicPageList.tsx shows all topics with search. 'New Topic Page' uses TopicAutocomplete dialog.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build TopicPageView with header, stats, and blocks list",
            "description": "TopicPageView.tsx shows topic header (name, aliases, stats) + NotebookBlock list + footer actions.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create NotebookBlock component with source deep link and actions",
            "description": "NotebookBlock.tsx: Card with content, source deep link, [Edit] [→ Source] [Generate Card] actions.",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build AddBlockModal for selecting sources from Knowledge Bank",
            "description": "AddBlockModal.tsx: Select processed/curated SourceItems, create NotebookBlock, update status to curated.",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Wire up Notebook view navigation and integrate with app routing",
            "description": "AppLayout routing, sidebar navigation, notebook count badge in useAppStore.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-07T02:21:03.685Z"
      },
      {
        "id": "42",
        "title": "Card Generation from Notebook Blocks",
        "description": "Select text in NotebookBlock → AI suggests cards with format intelligence and card-worthiness feedback → user confirms → card created with provenance. Post-creation: blocks with cards show muted visual indicator.",
        "details": "CORE PHILOSOPHY:\nThe Notebook is the 'What Boards Test' registry—curated, clinically-relevant content. Card generation treats text selection as a conversation starter with AI, not a binding specification. User identifies what confuses them; AI becomes collaborative tutor evaluating whether confusion merits a flashcard.\n\nINTERACTION FLOW:\n1. HOVER & SELECT:\n- Hover over text in NotebookBlock shows subtle highlight\n- Click activates selection mode with context-aware bounding box (expands to semantic units: sentences, clinical facts, procedural steps)\n- Floating 'Generate Card' button anchors to selection\n- Click-to-activate prevents accidental triggers\n\n2. AI CONTEXT STRATEGY:\n- Full NotebookBlock content as context (prevents 'lost in the middle')\n- Highlighted portion marked with semantic emphasis\n- Optional 'Why do you want to learn this?' text field (teaching moment + format hint)\n- If user writes 'I keep confusing X with Y' → AI suggests discriminative format\n\n3. FORMAT INTELLIGENCE:\nAI auto-suggests one of five formats with visual explanation:\n- Clinical Vignette Q&A: diagnostic reasoning\n- Overlapping Cloze: lists that risk sibling contamination\n- Single-Fact Cloze: discrete knowledge\n- Image Occlusion: when images referenced\n- Procedural Sequential: step-based skills\nFormat shown as labeled dropdown, default is AI suggestion, instant override available.\n\n4. CARD-WORTHINESS SOFT-GATE (integrated, not separate F6):\n- Quality panel shows 3 traffic lights: Testable? One Concept? Discriminative?\n- Yellow/red indicators have expandable explanation panel\n- Options: [Edit First] [Create Anyway] (tracked) [Skip]\n- Teaches effective card design through use, not blocking\n\n5. PROCEDURAL CARDS (MVP):\n- AI detects procedural content (keywords: steps, procedure, technique, how to)\n- Generates two-part card: Front=supplies checklist (pre-revealed), Back=numbered steps\n- Uses standard card template; voice-activated equipment reveal deferred (see DEFERRED: Procedural Simulation Mode)\n\n6. CARD CREATION:\n- Card saved with: notebookTopicPageId, sourceBlockId, tags from topic, FSRS defaults\n- Toast: 'Card created' with [View] link\n- NotebookBlock shows muted visual indicator (subtle box around text) showing content has been turned into card(s)\n- Indicator is non-distracting (muted colors, optional hover to reveal)\n\n7. USER TEACHING MOMENTS:\n- When user creates basic list card, card-worthiness flags it\n- AI offers auto-generate improved versions (overlapping cloze, individual vignettes)\n\nPERFORMANCE TARGET:\n- Text selection to created card: <20 seconds including AI processing\n- Optimistic UI: AI thinking indicator immediately, streaming preview updates, editable fields before AI completes\n- Database writes async after Create click, local state updates first\n\nCOMPONENTS:\n- src/components/notebook/CardGenerationModal.tsx\n- src/components/notebook/CardSuggestionPreview.tsx\n- src/components/notebook/FormatSelector.tsx\n- src/components/notebook/CardWorthinessPanel.tsx\n- Update NotebookBlock.tsx: Add selection handling + card indicator styling\n\nAI FUNCTIONS in electron/ai-service.ts:\n- generateCardFromBlock(blockContent: string, topicContext: string, userIntent?: string): Promise<CardSuggestion[]>\n- evaluateCardWorthiness(cardContent: string): Promise<WorthinessResult>",
        "testStrategy": "1. Hover text in block, verify highlight appears. 2. Select text, verify Generate Card button anchors. 3. Generate card from medical fact, verify AI suggests appropriate format. 4. Create list card, verify card-worthiness warning appears. 5. Create card, verify provenance fields (notebookTopicPageId, sourceBlockId). 6. Verify block shows muted indicator after card creation. 7. Performance: <20s from selection to created card.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define CardSuggestion types and AI generateCardFromBlock function",
            "description": "Create CardSuggestion type (format, front, back, confidence, worthinessResult) in src/types/ai.ts. Implement generateCardFromBlock() in ai-service.ts with format detection logic (QA, Cloze, Vignette, ImageOcclusion, Procedural). Handle procedural keyword detection, list detection for overlapping cloze. Put highlighted text at START of context window to avoid 'lost in the middle' issue.",
            "dependencies": [],
            "details": "Format detection heuristics: procedural keywords (steps, procedure, technique, how to), list patterns for overlapping cloze, clinical vignette triggers. Return array for multi-card suggestions from lists.",
            "status": "done",
            "testStrategy": "Unit test with sample medical content: clinical fact → QA, list of causes → overlapping cloze, procedure steps → procedural format.",
            "updatedAt": "2026-01-07T23:30:16.319Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Wire IPC handler for ai:generateCardFromBlock",
            "description": "Add ai:generateCardFromBlock handler in ipc-handlers.ts, expose in preload.ts, add type to electron.d.ts. Handler calls ai-service.generateCardFromBlock() with blockContent, topicContext, optional userIntent.",
            "dependencies": [
              1
            ],
            "details": "Cache key should include blockId to avoid regenerating. Return CardSuggestion[] to renderer.",
            "status": "done",
            "testStrategy": "Call from renderer, verify CardSuggestion[] returns with correct format.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:30:16.322Z"
          },
          {
            "id": 3,
            "title": "Build CardGenerationModal with FormatSelector and preview",
            "description": "Create CardGenerationModal.tsx with: optional 'Why do you want to learn this?' textarea, FormatSelector.tsx dropdown (5 formats with visual labels), CardSuggestionPreview.tsx showing front/back. Streaming UI: show AI thinking indicator immediately, update preview as response arrives. Buttons: [Edit First] [Create Card] [Skip].",
            "dependencies": [
              1
            ],
            "details": "Modal receives selectedText and blockId as props. Format dropdown defaults to AI suggestion but allows override. Preview shows editable front/back fields.",
            "status": "done",
            "testStrategy": "Open modal with test text, verify format selector works, edit preview fields, confirm buttons work.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:44:25.533Z"
          },
          {
            "id": 4,
            "title": "Build CardWorthinessPanel with traffic-light feedback",
            "description": "Create CardWorthinessPanel.tsx with compact traffic-light strip showing 3 criteria. Each criterion has green/yellow/red indicator with expandable explanation. Track [Create Anyway] clicks for analytics.",
            "dependencies": [
              1
            ],
            "details": "THREE CRITERIA:\n\n1. TESTABLE - Has one clear correct answer; survives rephrasing\n   Pass: 'What marker rises first in MI?' → Troponin\n   Fail: 'Describe MI pathophysiology' (essay, no single answer)\n\n2. ONE CONCEPT - Tests exactly one retrievable fact\n   Pass: 'Door-to-balloon target?' → <90 min\n   Fail: 'Name 5 STEMI criteria' (list = multiple facts)\n\n3. DISCRIMINATIVE - Distinguishes from similar concepts\n   Pass: 'Troponin vs CK-MB timing?' (forces comparison)\n   Fail: 'What's a cardiac marker?' (too generic, no discrimination)\n\nUI: Compact traffic-light strip (horizontal row of 3 circles). Hover/click on indicator → expands explanation panel with pass/fail examples. Yellow = borderline, Red = clear violation. Teaching moment: when red, suggest alternative format (e.g., 'Consider overlapping cloze for lists').",
            "status": "done",
            "testStrategy": "Test with: (1) 'Name 5 causes of chest pain' → One Concept should be red, (2) 'Describe pathophysiology of MI' → Testable should be red, (3) 'What is a troponin?' → Discriminative should be yellow, (4) 'Troponin rises before CK-MB. True/False?' → All green.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:37:56.504Z"
          },
          {
            "id": 5,
            "title": "Add text selection UI to NotebookBlock",
            "description": "Add hover highlight effect on NotebookBlock text (subtle, context-aware bounding). Click-to-activate selection mode. Floating 'Generate Card' button anchored to selection. Clear selection after modal opens. Debounce selection detection for performance.",
            "dependencies": [],
            "details": "Use window.getSelection() API. Context-aware bounding expands to sentence/paragraph boundaries. Avoid modal pop-up on accidental clicks with activation delay or minimum selection length.",
            "status": "done",
            "testStrategy": "Hover text, verify highlight. Select text, verify floating button appears. Click button, verify modal opens with selection.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:30:16.324Z"
          },
          {
            "id": 6,
            "title": "Wire modal to IPC and card creation flow",
            "description": "Connect CardGenerationModal to ai:generateCardFromBlock IPC. On [Create Card]: call cards:create with notebookTopicPageId, sourceBlockId, front, back, format. Use transaction: insert card + update NotebookBlock.cardCount atomically. Show toast 'Card created' with [View] link.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "FSRS defaults for new cards: state=0, reps=0, lapses=0. Card ID via crypto.randomUUID(). Performance target: <20s from selection to created card.",
            "status": "done",
            "testStrategy": "Select text, generate card, verify card in database with provenance fields. Verify toast appears.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:49:10.686Z"
          },
          {
            "id": 7,
            "title": "Add muted indicator styling for blocks with cards",
            "description": "NotebookBlock shows visual indicator when cardCount > 0. Muted, non-distracting styling (subtle left border or background tint). Optional hover to reveal 'X cards created from this block'. Update cardCount badge in real-time after card creation.",
            "dependencies": [
              6
            ],
            "details": "Consider: subtle left border (2px muted color), or very light background overlay. Badge shows count. Hover reveals list of linked cards.",
            "status": "done",
            "testStrategy": "Create card from block, verify indicator appears. Verify cardCount badge updates without page refresh.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:49:10.694Z"
          }
        ],
        "updatedAt": "2026-01-07T23:49:10.694Z"
      },
      {
        "id": "44",
        "title": "[v2-T8] Smart Views: system views (Inbox, Today, Queue, Weak Topics), filter engine",
        "description": "Implement Smart Views system with preset system views and a reusable filter engine for dynamic list filtering.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create filter engine types and applyFilter() function",
            "description": "Implement reusable filter engine with SmartViewFilter interface and applyFilter() function in new src/lib/filter-engine.ts file.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T20:57:59.462Z"
          },
          {
            "id": 2,
            "title": "Define system view configurations (Inbox, Today, Queue, Weak Topics)",
            "description": "Create system view definitions with filter configs, icons, and sort rules in src/lib/system-views.ts using SmartView type.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T21:12:10.382Z"
          },
          {
            "id": 3,
            "title": "Build SmartViewSidebar component with view list UI",
            "description": "Create SmartViewSidebar component in src/components/layout/SmartViewSidebar.tsx displaying system views with icons, badges, and click handlers.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T20:57:59.558Z"
          },
          {
            "id": 4,
            "title": "Implement badge counts and integrate into AppLayout",
            "description": "Add reactive badge count calculation using applyFilter and integrate SmartViewSidebar into AppLayout.tsx alongside existing Sidebar.",
            "dependencies": [
              1,
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T21:12:10.478Z"
          }
        ],
        "updatedAt": "2026-01-06T21:12:10.478Z"
      },
      {
        "id": "45",
        "title": "[v2-T6] FSRS integration: scheduling fields, review UI, response time tracking",
        "description": "Ensure FSRS integration works with new card provenance model. Track response times for future personalization.",
        "details": "FSRS FIELDS (already in cards table):\n- stability, difficulty, elapsedDays, scheduledDays\n- reps, lapses, state\n- dueDate, lastReview\n\nNEW TRACKING:\n- responseTimeMs in review_logs (already added in Task 1)\n- Track time from card shown to answer revealed\n- Track time from answer revealed to rating\n\nREVIEW UI UPDATES:\n\n1. PROVENANCE DISPLAY:\n- Show source: 'From: [Topic Name]'\n- Click to navigate to NotebookTopicPage\n- Show related cards count\n\n2. ZERO-DECISION FLOW:\n- Show Answer (Space)\n- Continue (Enter) = auto-grade based on response time\n- I Forgot (F) = grade as Again\n- Edit (E) = open card editor\n- Skip (S) = skip without grading\n\n3. LOW-EASE FLAGGING:\n- If card ease < 2.0 after review, flag for attention\n- Show in Weak Topics smart view\n- Suggest 'fix card' flow\n\nRESPONSE TIME LOGIC:\n- Fast correct (< 5s): increase ease slightly\n- Slow correct (> 15s): decrease ease slightly\n- Helps identify cards that need improvement\n\nCOMPONENTS:\n\n- Update src/components/review/ReviewInterface.tsx\n- Add response time tracking\n- Add provenance display\n- Connect to NotebookTopicPage navigation",
        "testStrategy": "Review card, verify response time logged. Test fast answer increases ease. Test slow answer decreases ease. Test low-ease card appears in Weak Topics. Test provenance link navigates correctly.",
        "priority": "high",
        "dependencies": [
          "41",
          "42"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add provenance display in ReviewInterface with NotebookTopicPage navigation",
            "description": "Display 'From: [Topic Name]' with clickable link to navigate to the source NotebookTopicPage. Handle legacy v1 cards without notebookTopicPageId gracefully.",
            "dependencies": [],
            "details": "Update ReviewInterface.tsx to:\n1. Load CanonicalTopic name from card.notebookTopicPageId via IPC (create new handler in ipc-handlers.ts)\n2. Add database query to join NotebookTopicPage → CanonicalTopic → canonicalName\n3. Display topic name below card content in the source metadata section\n4. Make topic name clickable to navigate via setCurrentView('notebook', notebookTopicPageId)\n5. Show fallback for legacy v1 cards without notebookTopicPageId (show Note title as before)\n6. Add count of related cards from same topic page (optional enhancement)\n\nFiles to modify:\n- src/components/review/ReviewInterface.tsx (lines 419-429)\n- electron/database.ts (add getTopicNameByNotebookPageId query)\n- electron/ipc-handlers.ts (add IPC handler)\n- src/types/electron.d.ts (add IPC type definition)\n- electron/preload.ts (expose IPC method)",
            "status": "done",
            "testStrategy": "Review a card with notebookTopicPageId, verify topic name displays. Click topic link, verify navigation to NotebookTopicPage. Review legacy v1 card, verify Note title fallback displays.",
            "updatedAt": "2026-01-08T01:59:03.520Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement response-time signal for FSRS interval adjustment",
            "description": "Add explicit response-time modifier to FSRS scheduling: fast answers (<5s) get +15% interval boost, slow answers (>15s) get -15% reduction. This is a multiplier applied ON TOP of the base FSRS calculation.",
            "dependencies": [],
            "details": "Update fsrs-service.ts scheduleReview function:\n1. After FSRS calculates base interval (scheduled.card.scheduled_days), apply response-time modifier\n2. Fast response (<5000ms): multiply interval by 1.15\n3. Slow response (>15000ms): multiply interval by 0.85\n4. Normal response (5-15s): no modifier (1.0)\n5. Update scheduled.card.scheduled_days before converting to DbCard\n6. Recalculate due date from modified interval\n7. This is SEPARATE from the auto-rating logic (which maps time→rating). This adds an additional multiplier.\n8. Ensure responseTimeMs is passed through from ReviewInterface → scheduleCardReview → scheduleReview\n\nFiles to modify:\n- electron/fsrs-service.ts (scheduleReview function, lines 82-159)\n- Add helper function calculateResponseTimeModifier(responseTimeMs: number | null): number\n\nNote: Do NOT modify the auto-rating logic in ReviewInterface.tsx (lines 111-116). That stays as-is. This is an additional signal in the scheduling layer.",
            "status": "done",
            "testStrategy": "Review card with fast response (<5s), check review_logs.responseTimeMs and card.scheduledDays (should be 15% higher than base FSRS). Review with slow response (>15s), verify 15% reduction. Review with normal response, verify no modifier.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T01:59:03.523Z"
          },
          {
            "id": 3,
            "title": "Add database query for low-difficulty cards aggregated by topic",
            "description": "Create SQL query to find cards with difficulty > 8.0 (FSRS scale), aggregate by NotebookTopicPage, return counts and topic names for Weak Topics view.",
            "dependencies": [],
            "details": "Add to electron/database.ts:\n1. Create new query function getLowDifficultyCardsByTopic()\n2. SQL: JOIN cards → notebookTopicPageId → NotebookTopicPage → CanonicalTopic\n3. Filter WHERE cards.difficulty > 8.0 AND cards.notebookTopicPageId IS NOT NULL\n4. GROUP BY canonicalTopicId\n5. Return: { topicId: string, topicName: string, cardCount: number, avgDifficulty: number }[]\n6. Order by avgDifficulty DESC, cardCount DESC\n7. Add to cardQueries object\n8. Create IPC handler in ipc-handlers.ts\n9. Add type definitions in electron.d.ts and index.ts\n10. Expose in preload.ts\n\nNew interface:\nexport interface WeakTopicSummary {\n  topicId: string;\n  topicName: string;\n  cardCount: number;\n  avgDifficulty: number;\n}\n\nFiles to modify:\n- electron/database.ts (add to cardQueries)\n- electron/ipc-handlers.ts (add handler)\n- src/types/electron.d.ts\n- src/types/index.ts\n- electron/preload.ts",
            "status": "done",
            "testStrategy": "Create test cards with difficulty > 8.0 and < 8.0 linked to different topics. Call getLowDifficultyCardsByTopic(), verify only high-difficulty cards returned, grouped by topic with correct counts and avg.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T01:59:03.526Z"
          },
          {
            "id": 4,
            "title": "Add visual indicator for high-difficulty cards in ReviewInterface",
            "description": "When reviewing a card with difficulty > 8.0, show red pulsing border and 'This card needs attention' message with Edit Card suggestion.",
            "dependencies": [
              3
            ],
            "details": "Update ReviewInterface.tsx:\n1. Check currentCard.difficulty > 8.0\n2. Add conditional className to card container (line 380): if high-difficulty, add 'ring-2 ring-destructive/50 animate-pulse-subtle'\n3. Add message below card content (before source metadata): 'This card needs attention' with AlertTriangle icon\n4. Add 'Edit Card' button/link (implement card editor navigation in future task, for now just show UI)\n5. Use existing pulse-subtle animation from Tailwind config\n6. Ensure difficulty value is available in Card type (already in CardWithFSRS)\n\nFiles to modify:\n- src/components/review/ReviewInterface.tsx (lines 380-430)\n\nNote: Card difficulty is already in the Card type from FSRS fields. Just need to read it from currentCard.",
            "status": "done",
            "testStrategy": "Review card with difficulty > 8.0, verify red pulsing border and warning message display. Review card with difficulty < 8.0, verify no indicator. Verify pulse animation works smoothly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T01:59:03.528Z"
          },
          {
            "id": 5,
            "title": "Create Weak Topics smart view component",
            "description": "Build WeakTopicsView component showing topics with high-difficulty cards, sorted by avg difficulty descending. Show card count per topic and navigation to topic page.",
            "dependencies": [
              3
            ],
            "details": "Create new component src/components/smartviews/WeakTopicsView.tsx:\n1. Fetch weak topics using window.api.cards.getLowDifficultyCardsByTopic()\n2. Display as list with:\n   - Topic name (large, bold)\n   - Card count badge\n   - Avg difficulty score (color-coded: 8-9=yellow, 9-10=red)\n   - Progress bar showing difficulty severity\n3. Click topic → navigate to NotebookTopicPage (setCurrentView('notebook', topicId))\n4. Empty state: 'No weak topics! All cards are well-learned.'\n5. Add to AppView type as 'weak-topics'\n6. Update router/view switcher to include WeakTopicsView\n7. Style consistent with existing smart views (inbox, notebook)\n\nFiles to create:\n- src/components/smartviews/WeakTopicsView.tsx\n\nFiles to modify:\n- src/types/index.ts (add 'weak-topics' to AppView if not exists)\n- src/App.tsx or view router (add weak-topics case)\n- Add icon and navigation in sidebar (future task)",
            "status": "done",
            "testStrategy": "Navigate to weak-topics view, verify topics with high-difficulty cards display. Click topic, verify navigation to topic page. Create cards with difficulty < 8.0, verify they don't appear. Test empty state when no weak topics.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T01:59:03.531Z"
          },
          {
            "id": 6,
            "title": "Add FSRS parameter optimization groundwork (schema and hooks)",
            "description": "Prepare infrastructure for Phase 3 MLE parameter training: add review_count tracking, settings table for learned parameters, and placeholder trigger logic (don't implement actual MLE yet).",
            "dependencies": [],
            "details": "Database schema updates in electron/database.ts:\n1. Add settings table if not exists:\n   CREATE TABLE settings (\n     key TEXT PRIMARY KEY,\n     value TEXT NOT NULL,\n     updatedAt TEXT NOT NULL\n   )\n2. Add migration for settings table\n3. Add settingsQueries object with get/set methods\n4. Add 'fsrs_parameters' key to store JSON of learned FSRS params\n5. Add 'review_count' key to track total reviews completed\n6. Increment review_count in scheduleReview after each review log insert\n7. Add helper function shouldTriggerOptimization(): boolean (returns true if review_count >= 400)\n8. Add placeholder comment in scheduleReview: '// TODO Phase 3: If shouldTriggerOptimization(), trigger MLE training'\n9. Create IPC handlers for settings CRUD\n10. Add types and preload exposure\n\nDO NOT implement actual MLE training algorithm. This is just the schema/hooks prep.\n\nFiles to modify:\n- electron/database.ts (add settings table migration, queries)\n- electron/fsrs-service.ts (increment review_count, add optimization check)\n- electron/ipc-handlers.ts (settings handlers)\n- src/types/electron.d.ts\n- electron/preload.ts",
            "status": "done",
            "testStrategy": "Verify settings table created. Review 5 cards, verify review_count increments to 5. Call shouldTriggerOptimization() with mock count >= 400, verify returns true. Verify fsrs_parameters can be stored and retrieved as JSON.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T01:59:03.533Z"
          }
        ],
        "updatedAt": "2026-01-08T01:59:03.533Z"
      },
      {
        "id": "91",
        "title": "Debug and Fix Ollama AI Extraction Pipeline",
        "description": "Troubleshoot and resolve AI extraction issues with Ollama integration, focusing on JSON parsing, model compatibility, and response handling in the extractConcepts() function",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:58:26.652Z"
      },
      {
        "id": "112",
        "title": "Sidebar Consolidation: merge SmartViewSidebar into Sidebar",
        "description": "Delete SmartViewSidebar.tsx, consolidate navigation into single Sidebar component with DO NOW and LIBRARY sections",
        "details": "DO NOW: Review (primary), Inbox (secondary). LIBRARY: Notebook, Knowledge Bank. KB shows ALL items with inbox at top; Inbox is pre-filtered shortcut. Remove: Capture, Today, Queue, Topics, Stats.",
        "testStrategy": "Verify single sidebar renders, navigation works, badge counts update",
        "priority": "high",
        "dependencies": [
          "44"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Sidebar.tsx: Add Capture at top and restructure sections",
            "description": "Capture above sections, 'DO NOW' header, Inbox nav item with badge.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Review emphasis styling with subtle glow when cards due",
            "description": "Ring glow on Review button when dueCount > 0.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Remove Topics and Stats from secondary navigation",
            "description": "secondaryNavItems only contains Notebook.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update AppLayout.tsx: Remove SmartViewSidebar component",
            "description": "Single Sidebar only, no SmartViewSidebar aside.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Delete SmartViewSidebar.tsx and clean up unused Smart View state",
            "description": "Deleted file, smartViewCounts only has inbox + notebook.",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-07T02:20:58.229Z"
      },
      {
        "id": "113",
        "title": "Image Capture Support: paste, drop, display in KB/Notebook",
        "description": "Add image paste/drop to QuickDumpModal, save images to userData/images/, display in Knowledge Bank and Notebook views.",
        "details": "SCOPE:\n1. QuickDumpModal: Add paste handler for clipboardData.files/items (image types), add drag-drop zone, show preview thumbnail before save\n2. IPC: Create images:save handler that writes Buffer to app.getPath('userData')/images/{uuid}.{ext}, returns mediaPath\n3. SourceItem: Save mediaPath field, display image in SourceItemRow and KnowledgeBankView\n4. NotebookBlock: Display block.mediaPath images in NotebookBlock component\n5. Card display: Show images on card front/back during review\n\nDatabase schema already supports imageData BLOB and mediaPath TEXT fields.",
        "testStrategy": "Paste screenshot, verify preview shows. Save, verify file in userData/images/. View in KB, verify image displays. Add to notebook, verify image in block. Generate card, verify image on card.",
        "priority": "high",
        "dependencies": [
          "38",
          "41"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add image paste and drag-drop handlers to QuickCaptureModal",
            "description": "Implement clipboard paste detection for images and drag-drop zone UI with preview thumbnail in QuickCaptureModal component before save.",
            "dependencies": [],
            "details": "QuickCaptureModal.tsx already has basic paste/drop handlers (lines 68-109) that detect images and call handleImageFile. The component displays preview thumbnail (lines 337-352) and saves via window.api.files.saveImage (lines 175-188). This subtask focuses on ensuring these handlers work correctly: verify paste event captures image/png, image/jpeg types from clipboardData.items, verify drag-drop zone activates with isDragging overlay (lines 288-296), verify preview displays before save with clear button, and ensure proper error handling for oversized files (>10MB).",
            "status": "pending",
            "testStrategy": "Paste screenshot from clipboard, verify preview appears with correct image. Drag image file over modal, verify drop zone overlay activates. Drop image, verify preview renders. Test file size validation with >10MB image.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Verify IPC handler saves images to userData/images/ directory",
            "description": "Confirm existing files:saveImage IPC handler correctly writes image Buffer to app.getPath('userData')/images/{uuid}.{ext} and returns relative mediaPath.",
            "dependencies": [],
            "details": "The IPC handler files:saveImage already exists at ipc-handlers.ts:2130-2169. It extracts base64 from data URL, creates userData/images/ directory if needed (lines 2148-2151), generates UUID filename with correct extension based on mimeType (lines 2143-2144), writes Buffer to disk (line 2163), and returns normalized path with forward slashes (line 2161). This subtask verifies the handler works correctly: test image persistence to correct directory, verify UUID generation produces unique filenames, confirm path normalization for cross-platform DB compatibility (forward slashes), test all supported mime types (png, jpeg, gif, webp), and verify error handling for invalid base64 data.",
            "status": "pending",
            "testStrategy": "Save image from QuickCaptureModal, check userData/images/ directory contains file with UUID name and correct extension. Verify returned mediaPath uses forward slashes. Test with different image types. Verify error handling with malformed data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Display images in SourceItemRow and KnowledgeBankView",
            "description": "Add image rendering for SourceItem.mediaPath in SourceItemRow component and KnowledgeBankView, showing thumbnail preview when mediaPath is present.",
            "dependencies": [
              2
            ],
            "details": "SourceItemRow.tsx (lines 1-228) currently shows icon based on sourceType (lines 56-74) including Image icon for sourceType='image' (lines 63-64), but does not render the actual image from mediaPath. Add conditional rendering: if sourceItem.mediaPath exists, display <img> thumbnail (max 48px height) in the icon area or adjacent to title, using src constructed from userData path + mediaPath. For KnowledgeBankView, ensure image preview appears in the list view. Handle image loading errors gracefully with fallback icon. Consider lazy loading for performance with many images.",
            "status": "pending",
            "testStrategy": "Create SourceItem with mediaPath via QuickCaptureModal. Navigate to Knowledge Bank, verify image thumbnail displays in SourceItemRow. Click to open SourceItemViewerDialog, verify full-size image displays. Test with missing image file to verify fallback behavior.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Display images in NotebookBlock component",
            "description": "Add image rendering for NotebookBlock.mediaPath in NotebookBlock component, showing images above or below block content text.",
            "dependencies": [
              2
            ],
            "details": "NotebookBlock.tsx (lines 1-229) currently renders only text content (lines 190-195). When block.mediaPath exists, render <img> element with src constructed from userData path + block.mediaPath. Position image strategically: above text content for context, or below based on UI design. Use responsive sizing (max-width: 100%, max-height: 400px) and rounded borders to match card styling (className from line 143-147). Ensure selection trigger for card generation (lines 198-218) still works properly when image is present. Handle image load errors with placeholder.",
            "status": "pending",
            "testStrategy": "Add SourceItem with image to Notebook as NotebookBlock. Navigate to Notebook view, verify image displays in block. Verify text selection for card generation still works. Test with missing image file to verify error handling.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Display images on card front/back during review session",
            "description": "Add image rendering in ReviewInterface component to show images on card front and back sides when Card.mediaPath exists.",
            "dependencies": [
              2
            ],
            "details": "ReviewInterface.tsx shows current card with front/back content using ClozeDisplay component (imported line 16). When currentCard.mediaPath exists, render <img> element on the appropriate card face. For cloze cards, image should appear above the cloze text. Position: centered with max-width 100%, max-height 300px for review context. Use similar styling as NotebookBlock images. Ensure image doesn't interfere with answer reveal flow (answerVisible state, line 33) or grading buttons. Card type in CardBrowserView shows front/back at lines 411 and 419. Images should be visible during both question (front) and answer (back) phases. Handle errors gracefully with fallback.",
            "status": "pending",
            "testStrategy": "Generate card from NotebookBlock with image. Start review session, verify image appears on card front. Reveal answer, verify image persists (or shows back image if different). Complete review, verify next card. Test error handling with missing image file.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "114",
        "title": "Backup/Restore UI: auto-save toast, Settings restore button",
        "description": "Add UI indicators for existing backup-service.ts: toast notifications on auto-save, Settings page restore functionality.",
        "details": "EXISTING: electron/backup-service.ts has createBackup(), restoreBackup(), auto-backup with 7-day retention.\n\nNEW UI:\n1. Toast notification on successful auto-backup (every 30s or on significant changes)\n2. Settings page section: 'Data Backup' with:\n   - Last backup timestamp display\n   - [Backup Now] manual trigger button\n   - [Restore from Backup] opens file picker for .db files\n   - Warning dialog before restore (destructive operation)\n3. IPC: Expose backup:create, backup:restore, backup:getLastTimestamp\n\nGives user confidence data won't be lost during development iterations.",
        "testStrategy": "Trigger auto-backup, verify toast appears. Click Backup Now, verify new backup created. Restore from backup, verify data loads correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-13T17:36:53.323Z"
      },
      {
        "id": "115",
        "title": "Card Browser: view all cards with filters (topic, status, due date)",
        "description": "Dedicated view to browse, search, and filter all cards in the system. Enables card management beyond global search.",
        "details": "CARD BROWSER VIEW:\n1. Access: Add 'Cards' to LIBRARY section in Sidebar\n2. Layout: Vertical list of cards with preview (front truncated)\n3. Filters:\n   - Status chips: Due / New / Learning / Review / Suspended\n   - Topic dropdown (from CanonicalTopics)\n   - Tag filter\n   - Date range (created/due)\n4. Sort: Due date, Created date, Ease, Last reviewed\n5. Actions:\n   - Click card → expand preview (front + back)\n   - [Edit] → inline edit or modal\n   - [Suspend/Unsuspend]\n   - [Delete] with confirmation\n6. Bulk actions: Select multiple → suspend/delete\n\nReplaces standalone Queue view with richer functionality.",
        "testStrategy": "Navigate to Card Browser, verify all cards display. Filter by topic, verify list updates. Sort by due date, verify order. Edit card, verify saves. Suspend card, verify status changes.",
        "priority": "high",
        "dependencies": [
          "42",
          "45"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Schema + Types: Add aiTitle column and CardBrowserItem interface",
            "description": "Add aiTitle column to cards table, update AppView type to include 'cards', create CardBrowserItem interface with computed fields (siblingCount, isLeech, topicName), and add 'Cards' entry to Sidebar LIBRARY section.",
            "dependencies": [],
            "details": "1. Add migration for aiTitle TEXT NULL column to cards table in database.ts. 2. Update AppView type in src/types/index.ts to include 'cards' as valid view. 3. Create CardBrowserItem interface in src/types/index.ts with fields: id, front (truncated 40 chars), back, tags, status, dueDate, createdAt, topicName, siblingCount, isLeech, sourceBlockId, notebookTopicPageId, difficulty, lapses, stability, reps. 4. Update Sidebar.tsx to add Cards to secondaryNavItems in LIBRARY section with icon from lucide-react (LayoutGrid or Library). 5. Leech detection formula: lapses >= 5 OR (lapses >= 3 AND difficulty > 0.7) OR (reps >= 5 AND stability < 7).\n<info added on 2026-01-08T04:37:08.775Z>\nI need to analyze the codebase to provide context-aware guidance about the aiTitle column implementation. Let me start by examining the current database schema and related files.Now let me check the tasks.json file to see if aiTitle is mentioned:Let me also check if there are any examples of embedding or AI title generation in the codebase:Based on my analysis of the codebase, I can now provide the subtask update text:\n\nMVP implementation uses simple truncation only. AI-generated titles require embedding infrastructure which is POST-MVP according to DEFERRED.md F2 (AI Duplicate Detection). The aiTitle column is added to schema with minimal ALTER TABLE statement for future use but will remain NULL in MVP. Migration pattern follows existing v1-v9 migrations in database.ts lines 342-968. Add to next available migration version (v10) using columnExists() guard and backup/restore pattern for safety.\n</info added on 2026-01-08T04:37:08.775Z>\n<info added on 2026-01-08T04:59:33.146Z>\nI need to analyze the current Sidebar.tsx structure to understand the bug and provide accurate guidance for fixing it.Now I can see the bug clearly. The current Sidebar.tsx has Knowledge Bank in mainNavItems (DO NOW section) at lines 71-75, but according to the MVP spec, it should be in secondaryNavItems (LIBRARY section). Let me verify the icon import needed:Based on my analysis of the current Sidebar.tsx structure and the MVP Screens spec, I can now provide the subtask update:\n\nBUG FIX REQUIRED in Sidebar.tsx lines 55-86. Current structure violates MVP spec from DougHub MVP Screens and Design.md lines 38-50. Knowledge Bank is incorrectly placed in mainNavItems (DO NOW section) at lines 71-75. CORRECT IMPLEMENTATION: Move Knowledge Bank object from mainNavItems array to secondaryNavItems array. Change icon import from Database to Brain (add to imports line 2-11). Update icon property from Database to Brain at line 73. Final arrays should be: mainNavItems contains only Review and Inbox. secondaryNavItems contains Notebook and Knowledge Bank (in that order) followed by Cards when added. This ensures LIBRARY section displays Notebook, Knowledge Bank, Cards as per approved design.\n</info added on 2026-01-08T04:59:33.146Z>",
            "status": "done",
            "testStrategy": "Verify migration runs without errors. Check AppView type includes 'cards'. Confirm CardBrowserItem interface exports correctly. Test Sidebar renders Cards option in LIBRARY section.",
            "updatedAt": "2026-01-08T16:24:19.351Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Core List Component: CardBrowserView.tsx with virtual scrolling",
            "description": "Create CardBrowserView.tsx component with search bar, filter tabs (Due/Leeches/All), and card row display showing truncated front text, topic pills, and status badge. Install react-window for virtual scrolling performance.",
            "dependencies": [
              1
            ],
            "details": "1. Create src/components/cards/CardBrowserView.tsx. 2. Install react-window via npm (npm install react-window @types/react-window). 3. Implement search input with debounce (300ms). 4. Add filter tabs using shadcn/ui Tabs component: 'Due' (cards with dueDate <= today), 'Leeches' (computed isLeech flag), 'All'. 5. CardRow component: display truncated front (40 chars with ellipsis), topic pill (from topicName), status badge (New/Learning/Review/Relearning based on state field). 6. Use react-window FixedSizeList for rendering ~50px row height. 7. Wire to useAppStore currentView='cards'. 8. Empty state: show message when no cards match filters.\n<info added on 2026-01-08T04:38:06.734Z>\nI'll analyze the codebase to provide specific implementation details for the CardBrowserView component.Performance targets: <500ms initial load with virtual scrolling (react-window), <150ms search response, <50ms filter toggle. Use FixedSizeList with itemSize=50 for normal mode. Status badge mapping: state 0=New, 1=Learning, 2=Review, 3=Relearning. Existing patterns: See InboxView.tsx for search/filter patterns (debounced search at line 69-78 with 150ms delay, useMemo for filtered lists at line 89-104, Select component for filters at line 251-270, batch selection toolbar at line 377-382), BatchActions.tsx for selection toolbar (fixed bottom-center positioning at line 43, rounded-full pill design). Note: react-window is NOT currently installed in package.json - must be added per step 2.\n</info added on 2026-01-08T04:38:06.734Z>\n<info added on 2026-01-08T04:45:35.530Z>\nI'll analyze the codebase to provide specific implementation details for the missing filter/sort features.Based on my analysis of the codebase, here is the new information for the subtask update:\n\n9. Add sort dropdown in header toolbar (after search input, before filter tabs) using shadcn/ui Select component with four options: 'Due date' (sort by dueDate ASC nulls last), 'Created' (createdAt DESC), 'Difficulty' (difficulty DESC from FSRS), 'Last reviewed' (lastReview DESC nulls last). 10. Add Topic filter dropdown next to sort using TopicAutocomplete.tsx component (located at src/components/ui/TopicAutocomplete.tsx) - use Command component with CommandInput for type-ahead search, calls window.api.canonicalTopics.suggestMatches(query) with 300ms debounce, renders matching topics from CanonicalTopic[] response. Convert to multi-select mode by wrapping multiple topic selections. 11. Add Tag filter dropdown using similar Command + Popover pattern with type-ahead search (fetch tags via window.api.tags.getAll or similar). 12. Consider adding 'Suspended' as 4th tab alongside Due/Leeches/All, OR render as status chip within the existing status badge component (state field does not include suspended - check if separate isSuspended or suspended boolean exists in CardBrowserItem schema from T115.1). 13. Filter stacking logic: Primary tabs filter first (Due/Leeches/All/Suspended), then apply secondary filters (Topic, Tag, Sort) to already-filtered results using Array.filter chaining in useMemo. 14. Header toolbar layout: Use flex gap-3 container with search input (flex-1), sort dropdown (w-[160px]), topic filter (w-[200px]), tag filter (w-[180px]) positioned before filter tabs row.\n</info added on 2026-01-08T04:45:35.530Z>",
            "status": "done",
            "testStrategy": "Navigate to Cards view via Sidebar. Verify search filters cards by front/back text. Test filter tabs switch between Due/Leeches/All. Confirm virtual scrolling works with 100+ cards without lag.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:05:42.783Z"
          },
          {
            "id": 3,
            "title": "IPC + Database: cards:getBrowserList with filters and sorting",
            "description": "Implement database query cards:getBrowserList that returns CardBrowserItem[] with filters (status, topic, tag), sorting (dueDate, createdAt), and pagination. Include computed isLeech flag and siblingCount in query.",
            "dependencies": [
              1
            ],
            "details": "1. Add getBrowserList method to database.ts that queries cards table with LEFT JOIN to notebookTopicPages for topicName. 2. Compute isLeech in query: CASE WHEN lapses >= 5 OR (lapses >= 3 AND difficulty > 0.7) OR (reps >= 5 AND stability < 7) THEN 1 ELSE 0 END as isLeech. 3. Compute siblingCount: subquery COUNT(*) from cards WHERE sourceBlockId = c.sourceBlockId AND sourceBlockId IS NOT NULL. 4. Support filters: status (state field), topicId (notebookTopicPageId), tags (JSON_CONTAINS or similar). 5. Support sorting: ORDER BY dueDate ASC, createdAt DESC, difficulty DESC. 6. Add IPC handler in ipc-handlers.ts: cards:getBrowserList. 7. Add method to preload.ts and electron.d.ts: cards.getBrowserList(filters, sort). 8. Add method to useAppStore.ts: getBrowserList wrapper.\n<info added on 2026-01-08T04:39:20.815Z>\nI need to analyze the codebase to provide accurate updates based on the user's request about using the existing CardWithFSRS interface and proper JOIN structure.Now let me check the existing query patterns for JOIN structures to understand how to properly construct the getBrowserList query:Now let me check how the database stores cards and what columns exist:Now let me check if there are existing examples of how cards are queried with topic information:Based on my analysis of the codebase, I can now generate the appropriate update for the subtask. The key findings are:\n\n1. `CardWithFSRS` interface exists in `src/types/index.ts` and extends both `Card` and `CardFSRS` interfaces\n2. The database schema shows the join path: `cards` → `notebookTopicPageId` → `notebook_topic_pages` → `canonicalTopicId` → `canonical_topics` → `canonicalName`\n3. Existing weak topics query (line 1243-1244 in database.ts) demonstrates the proper JOIN pattern\n4. The `sourceBlockId` column exists in the cards table for sibling detection\n\nReturn method signature should be CardWithFSRS[] not CardBrowserItem[]. Update JOIN chain to cards LEFT JOIN notebook_topic_pages ntp ON c.notebookTopicPageId = ntp.id LEFT JOIN canonical_topics ct ON ntp.canonicalTopicId = ct.id to get ct.canonicalName as topicName. Use existing JOIN pattern from getWeakTopics query at database.ts:1243-1244 as reference.\n</info added on 2026-01-08T04:39:20.815Z>",
            "status": "done",
            "testStrategy": "Call cards:getBrowserList from renderer with various filters. Verify correct cards returned. Test sorting by dueDate and createdAt. Confirm isLeech and siblingCount computed correctly. Check performance <500ms for 1000+ cards.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T16:49:26.654Z"
          },
          {
            "id": 4,
            "title": "Card Row Expand/Collapse: Show full front/back and source chain",
            "description": "Add click-to-expand functionality to card rows showing full front/back content, tags, and source chain preview (NotebookTopicPage → SourceItem). Use collapsible animation from tailwind.config.ts.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Update CardRow component in CardBrowserView.tsx to track expanded state (useState). 2. On row click, toggle expanded state. 3. Expanded view shows: full front text, full back text, tags as pills, source chain: 'Topic: [topicName] → Source: [sourceBlockId preview]'. 4. Use tailwind collapsible animation from config (data-state='open'|'closed'). 5. Limit height to ~300px with overflow-y-auto for very long content. 6. Add subtle border-left accent (primary color) when expanded. 7. Keyboard: Arrow right to expand, arrow left to collapse focused row.\n<info added on 2026-01-08T04:52:33.570Z>\nI'll analyze the codebase to understand the current implementation and provide specific guidance for adding clickable topic navigation.Based on the codebase analysis, I can see that:\n\n1. The pattern `setCurrentView(\"notebook\", notebookTopicPageId)` is used throughout (ReviewInterface.tsx:345, SearchBar.tsx:139, etc.)\n2. Cards have a `notebookTopicPageId` field (types/index.ts:26)\n3. NotebookTopicPage has a `canonicalTopicId` that links to CanonicalTopic (types/index.ts:95-97)\n4. The Card Browser will need to fetch NotebookTopicPage data to get the topic name for display\n\nHere's the new text to append to the subtask:\n\n8. Make topic name in source chain clickable: Wrap topic name text in a button or anchor element with onClick handler that calls setCurrentView('notebook', card.notebookTopicPageId). 9. Fetch NotebookTopicPage data via window.api.notebookPages.getById(notebookTopicPageId) to get canonicalTopicId, then fetch CanonicalTopic via window.api.canonicalTopics.getById(canonicalTopicId) to display canonicalName. Cache fetched topic names in component state to avoid redundant API calls. 10. Style clickable topic as link: text-primary underline-offset-4 hover:underline cursor-pointer. 11. Add aria-label='Jump to notebook topic page' for accessibility. This enables provenance verification without mental context switching—critical for anxious users who need to confirm card source during review maintenance.\n</info added on 2026-01-08T04:52:33.570Z>",
            "status": "done",
            "testStrategy": "Click card row and verify it expands smoothly. Confirm full front/back text displayed. Check tags and source chain visible. Test keyboard arrow keys to expand/collapse. Verify animation runs without jank.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:18:26.553Z"
          },
          {
            "id": 5,
            "title": "Hover Quick Actions: Edit, Suspend, Delete with confirmation",
            "description": "Show edit/suspend/delete action icons on row hover. Edit opens inline editor or modal. Suspend is immediate toggle. Delete requires confirmation dialog.",
            "dependencies": [
              4
            ],
            "details": "1. Add hover state to CardRow showing action buttons on right side. 2. Edit button (Pencil icon): opens CardEditModal or inline editor to modify front/back/tags. 3. Suspend button (Pause icon): toggles card state to/from suspended (add 'suspended' boolean to cards schema or use state=4). 4. Delete button (Trash icon): opens AlertDialog confirmation before calling cards.remove(id). 5. Update IPC handlers: cards:suspend(id, suspended), cards:update(id, updates). 6. Actions should update local state immediately (optimistic UI) and refresh list on success. 7. Show loading spinner on action buttons during async operations.\n<info added on 2026-01-08T04:47:10.972Z>\nI'll analyze the codebase to provide specific implementation guidance for creating the CardEditModal component.Based on my analysis of the codebase, here's the implementation guidance for CardEditModal:\n\nCreate src/components/cards/CardEditModal.tsx following CardGenerationModal.tsx architecture (src/components/notebook/CardGenerationModal.tsx:1-387). Use Dialog/DialogContent/DialogHeader/DialogTitle/DialogFooter from @/components/ui/dialog, Textarea from @/components/ui/textarea, Button from @/components/ui/button, Label from @/components/ui/label. For tags field, use inline Badge components (src/components/ui/badge.tsx) with X icons for removal + text input for adding new tags - no dedicated multi-select component exists in codebase. Props interface: open, onOpenChange, cardId, initialFront, initialBack, initialTags. State: front (string), back (string), tags (string[]), isLoading (boolean), error (string | null). Form validation: require front.trim().length > 0, show error if empty on submit. On save, call window.api.cards.update(cardId, { front, back, tags }) per pattern in useAppStore.ts:254. Handle IpcResult<T> response: if result.error, show error; else call onOpenChange(false) and refresh parent list. Loading state: disable save button and show spinner during async call. Keyboard shortcut: detect Ctrl+Enter for quick save (pattern from CardGenerationModal:169). Style consistently with CardGenerationModal: max-w-xl DialogContent, text-sm inputs, primary save button, ghost cancel. Position action buttons in DialogFooter: cancel left, save right (px-6).\n</info added on 2026-01-08T04:47:10.972Z>\n<info added on 2026-01-08T04:51:11.216Z>\nI'll analyze the codebase to understand the toast implementation and optimistic UI patterns before providing the implementation guidance.Based on my codebase analysis, here's the implementation guidance for the undo capability:\n\nImplement undo with action prop on toast: Import ToastAction from @/components/ui/toast (src/components/ui/toast.tsx:58-71). After suspend or delete, store previous card state in local variable (previousState = { id, suspended: false } or { id, deleted: false }). Call toast({ title: 'Card suspended' or 'Card deleted', duration: 5000, action: <ToastAction altText=\"Undo\" onClick={handleUndo}>Undo</ToastAction> }). Store previous state in CardRow component state using useRef to persist across renders without triggering re-render. handleUndo function: dismiss toast, call window.api.cards.update(id, previousState) or window.api.cards.restore(id), optimistically revert UI immediately (set local state back), refresh list on success. Set toast duration to 5000ms (5 seconds) instead of default TOAST_REMOVE_DELAY from use-toast.ts:9. Pattern follows toaster.tsx:16-25 where action element renders between description and close button. For delete action, may need new IPC handler cards:restore if soft-delete implemented (check schema for deleted_at column), otherwise use cards:create to recreate. Critical: Clear timeout on component unmount using useEffect cleanup to prevent memory leaks. Optimistic UI: update CardRow state immediately on suspend/delete, revert on undo, then sync with DB response. This matches toast pattern in AddToNotebookDialog.tsx:102-107 but adds action element for undo functionality.\n</info added on 2026-01-08T04:51:11.216Z>",
            "status": "done",
            "testStrategy": "Hover over card row and verify action buttons appear. Click Edit and modify card, confirm changes save. Click Suspend and verify card status updates. Click Delete, confirm dialog appears, verify card removed from list.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:29:52.209Z"
          },
          {
            "id": 6,
            "title": "Preview Pane: Bottom panel with ~150 chars of back content",
            "description": "Add bottom preview pane showing truncated back content for focused card. Updates on arrow key navigation (↑/↓). Keyboard nav: ↑/↓ rows, → expand, ← collapse.",
            "dependencies": [
              4
            ],
            "details": "1. Add preview pane component at bottom of CardBrowserView (fixed position or flexbox). 2. Track focusedCardIndex in state. 3. Display back content truncated to ~150 chars with ellipsis. 4. Update focusedCardIndex on arrow up/down keys (add global keydown listener). 5. Arrow right expands focused row, arrow left collapses. 6. Scroll focused row into view when navigating with keyboard. 7. Pane shows card metadata: due date, difficulty, lapses, last review date. 8. Subtle border-top separator, ~120px height, dark background. 9. Escape key to blur focus and hide pane.",
            "status": "done",
            "testStrategy": "Focus a card and verify preview pane shows back content. Press arrow down and confirm focus moves to next card. Press arrow right to expand, arrow left to collapse. Press Escape to hide pane. Check preview updates <16ms on navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:51:31.906Z"
          },
          {
            "id": 7,
            "title": "Sibling Cards (Deck Visual): Show deck lines and fan out siblings",
            "description": "Query cards with same sourceBlockId. Show subtle deck indicator (2-3 muted offset rectangles below card). Click to fan out siblings in nested list.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. CardRow checks if siblingCount > 1, renders deck visual below card: 2-3 div elements with absolute positioning, offset 2px down and 4px right, muted border, decreasing opacity. 2. Click deck visual to expand siblings list below parent row. 3. Query siblings: cards.getBySiblings(sourceBlockId) returns cards WHERE sourceBlockId = X. 4. Render sibling cards as nested indented rows (ml-8) with connecting lines (border-l). 5. Show sibling index/count: '2 of 5 cards from this block'. 6. Clicking sibling row navigates to that card (focus + expand). 7. Collapse siblings by clicking deck visual again or clicking elsewhere.",
            "status": "done",
            "testStrategy": "Find card with siblings (siblingCount > 1). Verify deck visual renders below card. Click deck and confirm siblings expand in nested list. Click sibling and verify it focuses. Click deck again to collapse.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T18:24:14.774Z"
          },
          {
            "id": 8,
            "title": "Compact Mode Toggle: Single-line condensed layout (3x density)",
            "description": "Add compact mode toggle via dropdown or keyboard shortcut (Ctrl+Shift+C). Single-line view with condensed spacing, ~30px row height. 3x density increase.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Add compactMode boolean to CardBrowserView state. 2. Add toggle button in header toolbar (LayoutGrid vs LayoutList icon). 3. In compact mode: reduce row height to ~30px, single-line front text (truncate 60 chars), hide topic pills, show status as small dot, remove padding. 4. Update FixedSizeList itemSize dynamically based on compactMode. 5. Keyboard shortcut: Ctrl+Shift+C to toggle (add global listener). 6. Persist compactMode preference in localStorage. 7. Expanded state should still work in compact mode (expands to larger size).",
            "status": "done",
            "testStrategy": "Click compact mode toggle and verify row height reduces to ~30px. Count visible rows before/after toggle, confirm ~3x more rows visible. Press Ctrl+Shift+C to toggle. Reload app and verify preference persists.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:51:32.004Z"
          },
          {
            "id": 9,
            "title": "Right Drawer (Source Context): Sheet with NotebookBlock preview and cards list",
            "description": "Click source link in expanded card row to open right Sheet showing NotebookBlock content preview and list of all cards generated from that block. No page navigation.",
            "dependencies": [
              4
            ],
            "details": "1. Use shadcn/ui Sheet component (install if needed: npx shadcn@latest add sheet). 2. Add 'View Source' link in expanded card row (only if sourceBlockId exists). 3. Sheet slides in from right, ~600px width. 4. Top section: NotebookBlock content preview (full text, read-only). 5. Bottom section: List of cards from this block (query cards WHERE sourceBlockId = X). 6. Each card shows front (truncated), tags, status badge. 7. Click card in drawer to focus it in main browser (close drawer, scroll to card, expand). 8. Sheet header shows topic name and block creation date. 9. Close button (X) in top-right corner.",
            "status": "done",
            "testStrategy": "Expand card with sourceBlockId, click 'View Source' link. Verify Sheet opens from right. Confirm NotebookBlock content displays. Check list of sibling cards renders. Click card in drawer and verify main browser focuses that card.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T18:24:14.776Z"
          },
          {
            "id": 10,
            "title": "Bulk Selection Mode: Checkbox selection with batch suspend/delete",
            "description": "Add checkbox on row hover for multi-select. Selection bar transforms header with batch actions (suspend/delete). Ctrl+A select all, Shift+arrows extend selection.",
            "dependencies": [
              2,
              5
            ],
            "details": "1. Add selectedCardIds Set to CardBrowserView state. 2. Show checkbox on left side of row on hover (or always visible in compact mode). 3. Click checkbox to toggle selection. 4. When selectedCardIds.size > 0, show BatchActions component (adapt from src/components/knowledgebank/BatchActions.tsx). 5. BatchActions bar shows: count, Clear button, Suspend All button, Delete All button (with confirmation). 6. Ctrl+A selects all visible cards (filtered results). 7. Shift+↑/↓ extends selection from focused card. 8. Batch operations: map over selectedCardIds, call suspend/delete for each, show progress. 9. Clear selection after batch action completes.",
            "status": "done",
            "testStrategy": "Hover card row and verify checkbox appears. Click checkbox to select. Select multiple cards and verify BatchActions bar appears. Click Suspend All and confirm all selected cards suspended. Press Ctrl+A and verify all cards selected. Press Shift+↓ and verify selection extends.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T18:35:25.606Z"
          },
          {
            "id": 11,
            "title": "Keyboard Shortcuts: Comprehensive navigation and action hotkeys",
            "description": "Implement keyboard shortcuts: / focus search, E edit, S suspend, Del delete, L jump to leeches, N/P next/prev leech, 1/2/3 filter tabs, Ctrl+G jump to card.",
            "dependencies": [
              2,
              4,
              5,
              6
            ],
            "details": "1. Add global keydown listener in CardBrowserView. 2. / (forward slash): focus search input. 3. E: edit focused card (same as clicking Edit button). 4. S: suspend/unsuspend focused card. 5. Delete/Backspace: delete focused card (with confirmation). 6. L: switch to Leeches filter tab. 7. N: jump to next leech card in list (wraparound). 8. P: jump to previous leech. 9. 1/2/3: switch to Due/Leeches/All filter tabs. 10. Ctrl+G: open 'Jump to Card' dialog with search. 11. Add visible keyboard shortcuts legend in footer or help tooltip (?).",
            "status": "done",
            "testStrategy": "Press / and verify search input focused. Press E on focused card and confirm edit modal opens. Press S and verify card suspends. Press L and confirm Leeches tab active. Press N/P to navigate leeches. Press 1/2/3 to switch tabs. Press Ctrl+G and verify jump dialog opens.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T19:05:35.357Z"
          },
          {
            "id": 12,
            "title": "Empty States + Leech UX: No results state and leech warning indicators",
            "description": "Add empty state for no results with typo suggestions. Add 'No leeches' celebration state. Show leech warning icon and 'needs rewriting' hint in expanded card view for leech cards.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Empty state component: display when filtered cards.length === 0. 2. Message: 'No cards found' with suggestion to adjust filters. 3. If search query has 0 results, suggest typo corrections (fuzzy match against existing card fronts - optional, can defer). 4. 'No leeches' state: when Leeches tab active and 0 leeches, show celebration message with trophy icon: 'Great job! No leeches to review.' 5. Leech card indicator: in expanded view, show amber/red alert icon next to difficulty score. 6. Hint text: 'This card needs rewriting. Consider splitting into multiple cards or clarifying the question.' 7. Style leech rows with subtle amber border-left accent.",
            "status": "done",
            "testStrategy": "Search for nonsense query and verify empty state displays. Switch to Leeches tab with no leeches and verify celebration state. Expand a leech card (lapses >= 5) and verify warning icon and hint text visible. Confirm leech cards have amber border accent.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T17:51:32.093Z"
          }
        ],
        "updatedAt": "2026-01-08T19:05:35.357Z"
      },
      {
        "id": "116",
        "title": "Browser Capture Hook: local HTTP API for Tampermonkey integration",
        "description": "Expose local HTTP endpoint in Electron main process for browser scripts to send captured content directly to Knowledge Bank.",
        "details": "HTTP API SERVER:\n1. Start Express/http server on localhost:PORT (configurable, default 23847)\n2. Endpoint: POST /capture\n   - Body: { content: string, title?: string, sourceType: 'qbank'|'article'|'web', url?: string, imageBase64?: string }\n   - Returns: { success: boolean, sourceItemId?: string, error?: string }\n3. Security: localhost only, optional API key in header\n4. On receive: Create SourceItem in inbox, trigger refreshSmartViewCounts\n5. Settings UI: Enable/disable HTTP capture, show port, regenerate API key\n\nTAMPERMONKEY INTEGRATION:\n- User installs script that adds 'Send to DougHub' button on PeerPrep/MKSAP pages\n- Script extracts question HTML, sends to localhost endpoint\n- DougHub shows toast 'Captured from PeerPrep'\n\nNote: User has existing script to adapt.",
        "testStrategy": "Start app, verify HTTP server running. POST to /capture with test content, verify SourceItem created in inbox. Test from Tampermonkey script on actual qbank site.",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add API key authentication to HTTP capture server",
            "description": "Enhance the existing capture-server.ts to support optional API key authentication for security. Store API key in settings table and validate on POST /api/capture requests.",
            "dependencies": [],
            "details": "The HTTP server already exists in electron/capture-server.ts with POST /api/capture endpoint. Need to:\n1. Add optional X-API-Key header validation in /api/capture handler\n2. Generate UUID-based API key and store in settings table as 'capture:apiKey'\n3. Add setting 'capture:enabled' (boolean, default true) to enable/disable server\n4. Move PORT to settings as 'capture:port' (default 23847)\n5. Modify startCaptureServer() to check capture:enabled setting before starting\n6. Add getCaptureServerStatus() function returning { enabled, port, hasApiKey }\n7. Add regenerateApiKey() function that generates new UUID and stores it\n\nFiles to modify:\n- electron/capture-server.ts: Add apiKey parameter to startCaptureServer(), validate header\n- electron/main.ts: Load settings and pass to startCaptureServer()\n- electron/database/settings.ts: No changes needed (already supports key-value storage)\n\nSecurity: Reject requests without valid API key if one is set. Always bind to 127.0.0.1 only (already implemented).",
            "status": "pending",
            "testStrategy": "Test with curl: 1) Start server, POST without API key (should work if not set), 2) Generate API key via settings, POST without header (should fail 401), 3) POST with correct X-API-Key header (should succeed), 4) POST with wrong key (should fail 401), 5) Disable capture:enabled setting, verify server doesn't start on app restart.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Expose capture server settings and controls via IPC",
            "description": "Add IPC handlers for renderer to get server status, update settings (enable/disable, port, API key), and expose in preload.ts for UI access.",
            "dependencies": [
              1
            ],
            "details": "Add IPC handlers in electron/ipc-handlers.ts:\n1. capture:getStatus - Returns { enabled: boolean, port: number, apiKey: string | null, isRunning: boolean }\n2. capture:updateSettings - Updates capture:enabled, capture:port in settings table\n3. capture:regenerateApiKey - Generates new UUID, stores as capture:apiKey, returns new key\n4. capture:restartServer - Stops and restarts server with new settings (requires app restart for now)\n\nAdd to electron/preload.ts:\n```typescript\ncapture: {\n  getStatus: () => ipcRenderer.invoke('capture:getStatus'),\n  updateSettings: (settings: { enabled?: boolean, port?: number }) => \n    ipcRenderer.invoke('capture:updateSettings', settings),\n  regenerateApiKey: () => ipcRenderer.invoke('capture:regenerateApiKey'),\n}\n```\n\nAdd TypeScript definitions in src/types/electron.d.ts (or wherever IPC types are defined).\n\nNote: Server restart requires app restart for MVP. Full hot-reload can be deferred.",
            "status": "pending",
            "testStrategy": "From DevTools console: 1) Call window.api.capture.getStatus(), verify returns current settings, 2) Call regenerateApiKey(), verify returns new UUID, 3) Call updateSettings({ enabled: false }), verify setting saved in DB, 4) Restart app, verify server not running when disabled.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Capture Server settings UI in SettingsView",
            "description": "Add 'Browser Integration' card to SettingsView.tsx with enable/disable toggle, port display, API key display with copy button, and regenerate API key button.",
            "dependencies": [
              2
            ],
            "details": "Add new Card to src/components/settings/SettingsView.tsx under a new 'Browser Integration' section:\n\n**UI Components:**\n1. Switch: Enable/Disable HTTP capture server (calls capture:updateSettings)\n2. Read-only Input: Port number with label 'Server Port' (default: 23847)\n3. Read-only Input: API Key with [Copy] button (uses navigator.clipboard.writeText)\n4. Button: 'Regenerate API Key' with confirmation dialog (calls capture:regenerateApiKey)\n5. Alert box: 'Restart app to apply changes' shown when settings modified\n6. Status indicator: Green dot + 'Running' or Gray dot + 'Stopped'\n\n**State management:**\n- Load settings on mount with useEffect calling window.api.capture.getStatus()\n- Track dirty state to show 'restart required' message\n- Show toast on successful API key copy and regeneration\n\n**Layout:**\nPlace after 'AI Provider' section, before 'Database' section. Use same Card/CardHeader/CardContent pattern as existing settings cards.\n\n**Copy functionality:**\nUse theme colors for status indicator (bg-success/bg-muted from index.css per CLAUDE.md).",
            "status": "pending",
            "testStrategy": "Manual UI testing: 1) Navigate to Settings, verify 'Browser Integration' card visible, 2) Toggle enable/disable, verify setting saved and restart alert shown, 3) Click Copy API key, verify copied to clipboard and toast shown, 4) Click Regenerate, confirm dialog, verify new key displayed, 5) Restart app with capture disabled, verify status shows 'Stopped'.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Tampermonkey script template for qbank capture",
            "description": "Write documented Tampermonkey userscript template that extracts question HTML from PeerPrep/MKSAP pages and POSTs to localhost:23847/api/capture with proper payload format.",
            "dependencies": [
              1
            ],
            "details": "Create docs/tampermonkey-capture-template.js with:\n\n**Script metadata:**\n```javascript\n// ==UserScript==\n// @name         DougHub Qbank Capture\n// @namespace    http://tampermonkey.net/\n// @version      1.0\n// @description  Capture medical board questions to DougHub\n// @match        https://www.peerprep.com/*\n// @match        https://mksap19.acponline.org/*\n// @grant        GM_xmlhttpRequest\n// @connect      127.0.0.1\n// ==/UserScript==\n```\n\n**Functionality:**\n1. Detect site (PeerPrep vs MKSAP) from hostname\n2. Add floating 'Send to DougHub' button to page (position: fixed, bottom-right)\n3. On click: Extract pageHTML, bodyText, images array, url, siteName\n4. POST to http://127.0.0.1:23847/api/capture with X-API-Key header\n5. Show inline notification: 'Captured to DougHub!' (green) or error message (red)\n6. Match existing CapturePayload interface from electron/capture-server.ts\n\n**Payload format:**\n```typescript\n{\n  timestamp: new Date().toISOString(),\n  url: window.location.href,\n  hostname: window.location.hostname,\n  siteName: 'ACEP PeerPrep' | 'MKSAP 19',\n  pageHTML: document.body.innerHTML,\n  bodyText: document.body.innerText.substring(0, 5000),\n  images: [] // Extract from existing user script if applicable\n}\n```\n\n**Comments:** Add TODO placeholders for:\n- API_KEY constant (user must fill in)\n- Site-specific extraction logic (varies by qbank)\n- Image extraction (optional for MVP)\n\nSave to docs/ folder for user reference. User will customize based on their existing script.",
            "status": "pending",
            "testStrategy": "Test with Tampermonkey: 1) Install script in Chrome/Firefox, 2) Navigate to PeerPrep question page, 3) Click 'Send to DougHub' button, 4) Verify POST request sent with API key header, 5) Check DougHub inbox for new SourceItem, 6) Verify toast notification appears, 7) Test with invalid API key, verify error shown in browser.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "117",
        "title": "Basic Learning Mode: post-review mistakes summary with elaborated feedback",
        "description": "After review session, show 'Review Mistakes?' prompt displaying missed cards with AI-generated why-wrong explanations.",
        "details": "LEARNING MODE ENTRY:\n1. After review session ends (no more due cards or user exits):\n   - If mistakes > 0: Show modal 'Review X mistakes?'\n   - [Review Now] / [Skip]\n2. Mistakes Review UI:\n   - Vertical scroll through each mistake\n   - Show: Card front, your timing/grade, correct answer\n   - AI elaborated feedback: 'Why this is wrong: ...'\n   - 'Why correct answer is right: ...'\n   - Related concept hints\n3. AI Function: generateElaboratedFeedback(card, userResponse)\n   - Uses card content + topic context\n   - Returns { whyWrong: string, whyRight: string, relatedConcepts: string[] }\n4. End of mistakes: 'All reviewed!' with summary stats\n\nThis is the highest-yield learning pipeline feature. Other learning mode features (T94-T107) remain in DEFERRED.md for future implementation.",
        "testStrategy": "Complete review session with 2+ mistakes. Verify prompt appears. Click Review Now, verify mistakes display with AI feedback. Verify all mistakes can be scrolled through.",
        "priority": "high",
        "dependencies": [
          "45"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Track mistakes in ReviewInterface state",
            "description": "Add mistakeCardIds array and sessionStartTime to ReviewInterface component state. Track cards rated 'Again' during session without duplicates.",
            "dependencies": [],
            "details": "Add state variables to ReviewInterface.tsx: `mistakeCardIds: string[]` and `sessionStartTime: Date | null`. In the submitReview function (line 149), when rating === Rating.Again, add cardId to mistakeCardIds array using setMistakeCardIds(prev => prev.includes(currentCard.id) ? prev : [...prev, currentCard.id]). Initialize sessionStartTime when reviewQueue is initialized (line 70). Store both mistake card objects with their response times: { cardId: string, responseTimeMs: number | null, rating: number }[]\n<info added on 2026-01-08T02:35:23.440Z>\nLet me analyze the codebase to understand the database schema and provide an accurate update.Based on my analysis of the codebase, I can see that the `review_logs` table currently has three tracking columns: `responseTimeMs`, `partialCreditScore`, and `responseTimeModifier` (added in schema v7, line 863-869 in database.ts). The initial schema definition is at line 975-987.\n\nHere's the new text content to add to the subtask:\n\n---\n\nSchema prep for future features: Add nullable `userAnswer TEXT` column to review_logs table in database.ts migration (following the pattern at lines 366-376 for responseTimeMs/partialCreditScore additions). This is zero-cost preparation enabling F18 (Typed Answer Mode) and F19 (Adaptive Learning Assistant) deferred features per DEFERRED.md. The column should be added via ALTER TABLE but not populated by MVP review submission code.\n</info added on 2026-01-08T02:35:23.440Z>\n<info added on 2026-01-08T02:40:43.580Z>\nI need to analyze the database schema first to understand the current structure of the review_logs table and provide an accurate update about adding both columns.Based on my analysis of the codebase and the user request, here is the new text to append to the subtask:\n\nSchema prep section updated: Add TWO nullable columns to review_logs table via ALTER TABLE in database.ts migration section (following pattern at lines 863-869 for responseTimeModifier): `userAnswer TEXT` (F18: Typed Answer Mode - captures what user typed before reveal) AND `userExplanation TEXT` (F20: Exam Trap Detection - captures why user thinks they missed the question). Both are zero-cost preparation enabling future Adaptive Learning Assistant features per DEFERRED.md lines 90-136. Columns should be added to schema but not populated by MVP review submission code.\n</info added on 2026-01-08T02:40:43.580Z>",
            "status": "done",
            "testStrategy": "Review a session with 2+ cards, rate one as Again. Verify mistakeCardIds contains that card ID. Verify sessionStartTime is set when session starts.",
            "updatedAt": "2026-01-08T03:13:19.414Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add session-end modal trigger",
            "description": "When session completes, show MistakesPromptModal if mistakes exist, otherwise show completion toast.",
            "dependencies": [
              1
            ],
            "details": "In ReviewInterface.tsx sessionComplete block (line 368), replace redirect logic with conditional: if mistakeCardIds.length > 0, show MistakesPromptModal with count; else show toast 'Session complete! X/X correct' using useToast hook. Create MistakesPromptModal.tsx component with Dialog wrapper, showing 'You missed X card(s). Review mistakes?' message, [Review Now] button (triggers mistake review flow) and [Skip] button (navigates to capture). Modal accepts onReview and onSkip callbacks.",
            "status": "done",
            "testStrategy": "Complete session with 0 mistakes - verify toast appears. Complete session with 2+ mistakes - verify modal appears with correct count and both buttons work.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:13:19.510Z"
          },
          {
            "id": 3,
            "title": "Create AI generateElaboratedFeedback function",
            "description": "Add AI function to generate why-wrong and why-right feedback for missed cards.",
            "dependencies": [],
            "details": "In electron/ai-service.ts, add generateElaboratedFeedback(card: { front: string, back: string, cardType: string }, topicContext: string, responseTimeMs: number | null): Promise<ElaboratedFeedback>. Follow existing pattern: add PROMPTS.elaboratedFeedback system prompt (medical education AI explaining why answer is wrong, why correct answer is right, related concepts). Use aiCache.key() for caching with card content + topic. Return { whyWrong: string, whyRight: string, relatedConcepts: string[] }. Add IPC handler in ipc-handlers.ts: ipcMain.handle('ai:generateElaboratedFeedback'). Update preload.ts and electron.d.ts with new method.",
            "status": "done",
            "testStrategy": "Call ai:generateElaboratedFeedback with sample card. Verify returns whyWrong, whyRight, and relatedConcepts array. Verify caching works on repeat calls.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:13:19.601Z"
          },
          {
            "id": 4,
            "title": "Create MistakesReviewModal component",
            "description": "Build modal to scroll through mistakes with AI-generated feedback.",
            "dependencies": [
              3
            ],
            "details": "Create src/components/review/MistakesReviewModal.tsx. Use Dialog from shadcn/ui. Accept props: open, onOpenChange, mistakeCards: Array<{ card: CardWithFSRS, responseTimeMs: number | null }>. State: currentIndex (0), feedback loading state. For each card, display: card.front (use ClozeDisplay if cloze type like ReviewInterface line 439), card.back (use ClozeAnswer if cloze), response time formatted as 'Xm Ys'. Fetch AI feedback on-demand when currentIndex changes using window.api.ai.generateElaboratedFeedback(). Show loading spinner during fetch. Display feedback sections: 'Why this is wrong', 'Why correct answer is right', 'Related concepts'. Navigation: [Previous] [X/Y] [Next] buttons, [Done] on last card closes modal. Include session stats in header/footer.",
            "status": "done",
            "testStrategy": "Open modal with 3 mistake cards. Verify front/back display correctly. Verify AI feedback loads for each card. Navigate through all cards, verify Next/Previous work. Click Done, verify modal closes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:13:19.693Z"
          },
          {
            "id": 5,
            "title": "Add session stats to mistake review",
            "description": "Calculate and display total session time, cards reviewed, mistakes count, and accuracy percentage.",
            "dependencies": [
              1,
              4
            ],
            "details": "In ReviewInterface.tsx, track sessionStats: { totalTime: number, cardsReviewed: number, mistakeCount: number }. Calculate totalTime = Date.now() - sessionStartTime.getTime(). Format as 'Xm Ys' helper function. Calculate accuracy = Math.round(((cardsReviewed - mistakeCount) / cardsReviewed) * 100). Pass stats to MistakesReviewModal via props. Display in modal header or footer: 'Session: Xm Ys • X/Y correct (Z% accuracy)'. Use muted text styling similar to ReviewInterface line 503.",
            "status": "done",
            "testStrategy": "Complete 5-card session with 2 mistakes in 3 minutes. Verify modal shows '3m 0s • 3/5 correct (60% accuracy)'.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:13:19.788Z"
          },
          {
            "id": 6,
            "title": "Types and integration",
            "description": "Add TypeScript interfaces for ElaboratedFeedback and wire all components together.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "In src/types/ai.ts, add: export interface ElaboratedFeedback { whyWrong: string; whyRight: string; relatedConcepts: string[]; }. In src/types/electron.d.ts, add to ai interface: generateElaboratedFeedback: (card: { front: string, back: string, cardType: string }, topicContext: string, responseTimeMs: number | null) => Promise<IpcResult<ElaboratedFeedback>>. In ReviewInterface.tsx, import and wire MistakesPromptModal and MistakesReviewModal. Add state for showMistakesReview: boolean. In sessionComplete block, conditionally render MistakesPromptModal. When user clicks 'Review Now', set showMistakesReview=true. Render MistakesReviewModal with mistakeCards data. Test complete flow: review session → rate cards as Again → see prompt → click Review → see feedback → navigate mistakes → click Done.",
            "status": "done",
            "testStrategy": "Complete review session with 3 mistakes. Click 'Review Now'. Verify modal opens with all 3 cards. Verify AI feedback displays. Navigate through all cards. Click Done. Verify returns to capture view.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:13:19.881Z"
          }
        ],
        "updatedAt": "2026-01-08T03:13:19.881Z"
      },
      {
        "id": "118",
        "title": "Two-Mode Capture: FAB modal with auto-classification and Process Now button",
        "description": "Expand capture modal with content auto-classification, AI title generation, and disabled 'Process Now' button (enabled after T117 Learning Mode).",
        "details": "TWO-MODE CAPTURE PRINCIPLE:\n\n1. SINGLE CAPTURE MODAL (QuickDumpModal expansion):\n- Opened via FAB (+), global shortcut, drag-drop, or Tampermonkey prefill\n- Plaintext textarea with auto-detect: Text / URL / PDF / Image / QBank\n- AI auto-title (debounced, editable, fallback to truncation)\n\n2. TWO EXITS:\n- [Save to Inbox] (primary): Create SourceItem, close modal, show toast\n- [Process Now] (secondary, disabled initially): Create SourceItem, enter guided processing\n\n3. AUTO-CLASSIFICATION:\n- Detect content type from paste/drop\n- Show badge indicating detected type\n- Set sourceType field automatically\n\n4. PROCESS NOW BUTTON:\n- Initially disabled with tooltip 'Coming soon - complete Learning Mode first'\n- Enabled after T117 (Learning Mode) is complete\n- When enabled: saves to inbox then navigates to guided processing flow\n\nNOTE: This expands T38's basic capture with the two-mode principle. Inbox remains derived view (status='inbox').",
        "testStrategy": "Paste text, verify auto-title generates. Verify Save to Inbox creates SourceItem. Verify Process Now button is disabled. Test content type detection for URL vs plain text.",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create content type auto-detection utility",
            "description": "Build utility function to detect content type (Text/URL/PDF/Image/QBank) from pasted or dropped content",
            "dependencies": [],
            "details": "Create src/lib/content-detector.ts with detectContentType(content: string) function. Detect URL via regex (https?://), PDF via .pdf extension or 'application/pdf' MIME, Image via data:image/ or image MIME types, QBank via patterns like 'Question ID:' or 'Stem:', default to Text. Return type ContentType = 'text' | 'url' | 'pdf' | 'image' | 'qbank'. Handle edge cases: data URLs, file paths, clipboard binary data.",
            "status": "done",
            "testStrategy": "Unit test with sample URLs, PDF paths, image data URLs, QBank text, and plain text. Verify correct type detection for each case.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:37:04.267Z"
          },
          {
            "id": 2,
            "title": "Add AI auto-title generation with debouncing",
            "description": "Create AI service function to generate titles from content with 500ms debounce, editable result, and truncation fallback",
            "dependencies": [],
            "details": "In electron/ai-service.ts, add generateTitle(content: string): Promise<string> that uses AI to generate a concise title (max 50 chars). Use simple prompt: 'Generate a brief title (max 50 chars) for this content: {content}'. Implement in-memory cache similar to generateCardFromBlock. In QuickCaptureModal, use React hook to debounce content changes (500ms), call window.api.ai.generateTitle, allow user to edit generated title. Fallback to content.slice(0, TITLE_MAX_LENGTH) + '...' if AI fails or content < 10 chars. Add ai:generateTitle IPC handler in ipc-handlers.ts, expose in preload.ts and electron.d.ts.\n<info added on 2026-01-08T03:23:09.385Z>\nI need to analyze the codebase to understand the current implementation before providing the simplified update.Based on my analysis, the current QuickCaptureModal already implements title truncation using `TITLE_MAX_LENGTH` constant (50 chars) at lines 167-169. The title is auto-generated from content but not editable. Here's the update text:\n\nMVP SIMPLIFICATION: Remove all AI title generation work from this subtask. Title truncation already exists in QuickCaptureModal.tsx:167-169 using TITLE_MAX_LENGTH constant. For MVP, only add an editable title field to QuickCaptureModal UI that is pre-populated with the truncated content (existing logic). User can edit before saving. AI-powered title generation is post-MVP polish and should be deferred to DEFERRED.md. No IPC handlers, no ai-service changes, no debouncing needed for MVP.\n</info added on 2026-01-08T03:23:09.385Z>",
            "status": "done",
            "testStrategy": "Paste long text, verify title generates after 500ms. Edit title manually, verify edits persist. Test with AI unavailable, verify truncation fallback works. Test with very short content.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:37:04.270Z"
          },
          {
            "id": 3,
            "title": "Update QuickCaptureModal UI with type badge and title editing",
            "description": "Enhance modal to show detected content type badge, editable auto-generated title field, and update sourceType based on detection",
            "dependencies": [
              1,
              2
            ],
            "details": "In QuickCaptureModal.tsx: Add state for detectedType (ContentType), generatedTitle (string), and isEditingTitle (boolean). On content/imageData change, call detectContentType() and update badge. Add <Badge> component below textarea showing detected type with color coding (URL=blue, PDF=purple, Image=green, QBank=orange, Text=gray). Add title Input field above textarea, populated with AI-generated title (debounced 500ms after content change), editable by user. Update handleSave to use generatedTitle if provided, otherwise fallback to existing truncation logic. Map ContentType to SourceType: url→article, pdf→pdf, image→image, qbank→qbank, text→quickcapture.",
            "status": "done",
            "testStrategy": "Paste URL, verify blue URL badge appears. Verify title auto-generates. Edit title, paste more content, verify title doesn't reset while editing. Test all content types for correct badge color and sourceType mapping.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:37:04.273Z"
          },
          {
            "id": 4,
            "title": "Add two-button footer with disabled Process Now button",
            "description": "Update modal footer to show [Save to Inbox] primary button and [Process Now] secondary button (disabled with tooltip)",
            "dependencies": [],
            "details": "In QuickCaptureModal.tsx DialogFooter: Keep existing 'Save for Later' button but rename to 'Save to Inbox' (primary, keeps existing handleSave logic). Add new <Button variant='outline' disabled> with text 'Process Now' and <Tooltip> showing 'Coming soon - complete Learning Mode first (T117)'. Use TooltipProvider from components/ui/tooltip. Position 'Save to Inbox' on right (primary action), 'Process Now' in middle. Keep Cancel on left. Add visual indicator that Process Now is coming (maybe ghost variant with subtle styling).",
            "status": "done",
            "testStrategy": "Open modal, verify two buttons visible. Hover Process Now, verify tooltip shows 'Coming soon' message. Click Save to Inbox, verify existing save flow works. Verify button layout: Cancel (left), Process Now disabled (middle), Save to Inbox (right).",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:37:04.275Z"
          },
          {
            "id": 5,
            "title": "Add drag-drop file support for PDFs and other file types",
            "description": "Extend existing drag-drop handler to support PDF files and other document types beyond images",
            "dependencies": [
              1
            ],
            "details": "In QuickCaptureModal.tsx, update handleDrop() to handle file.type === 'application/pdf' or file extensions (.pdf, .docx, .txt). For PDFs: save file path to SourceItem.mediaPath, set sourceType='pdf', show file name in preview area with PDF icon. For non-image files, store file path and show file metadata (name, size, type). Update handleFileChange() and fileInputRef accept attribute to 'image/*,application/pdf,.txt,.docx'. Maintain existing image handling for backward compatibility. Update preview area to show file icon + name for non-image files.",
            "status": "cancelled",
            "testStrategy": "Drag PDF file, verify preview shows PDF icon and filename. Drop .txt file, verify correct detection. Drag image, verify existing image preview still works. Test file size limits for PDFs (should use same MAX_FILE_SIZE). Verify saved SourceItem has correct sourceType and mediaPath.",
            "updatedAt": "2026-01-08T03:23:12.932Z",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Update SourceType and database schema if needed",
            "description": "Verify SourceType enum includes all auto-detected types (url, qbank) and add if missing",
            "dependencies": [
              1,
              3
            ],
            "details": "In electron/database.ts, check SourceType union type (line 17) includes: 'qbank' | 'article' | 'pdf' | 'image' | 'audio' | 'quickcapture' | 'manual'. Add 'url' type if needed for URL captures (or map url→article in QuickCaptureModal). Verify DbSourceItem.sourceType field (line 97) accepts these types. No schema migration needed (sourceType is TEXT column, already flexible). Update type mapping in QuickCaptureModal to use 'article' for URLs since that's the semantic meaning. Document the mapping: URL→article, PDF→pdf, Image→image, QBank→qbank, Text→quickcapture.",
            "status": "done",
            "testStrategy": "Run TypeScript compilation, verify no type errors. Create SourceItem with each content type, verify database accepts all sourceType values. Query by sourceType, verify filtering works for all types including qbank and article.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T03:23:16.640Z"
          }
        ],
        "updatedAt": "2026-01-08T03:37:08.318Z"
      },
      {
        "id": "119",
        "title": "Insight Writing Modal: Redesign Add to Notebook Flow",
        "description": "Redesign AddToNotebookDialog with source preview, 'What did you learn?' textarea, and dual buttons (Save Draft / Get AI Feedback). Kill batch flow entirely. Single-item processing only.",
        "details": "INSIGHT WRITING MODAL DESIGN:\n\n1. MODAL STRUCTURE:\n- Source preview panel (read-only rawContent from SourceItem, scrollable)\n- 'What did you learn?' textarea (required, min 20 chars)\n- Topic selector (existing functionality)\n- 'Link to existing block?' prompt when topic already has blocks\n\n2. BOARD RELEVANCE PANEL (when topic selected):\n- Shows when: topic selected AND topic has qbank source_items with matching tags\n- Query: SELECT * FROM source_items WHERE sourceType='qbank' AND tags overlap with topic\n- Display: question count, accuracy (correct/total), commonly tested concepts (aggregated testedConcepts[]), user mistakes\n- Guidance text: 'Focus your insight on [weak concept] - you've struggled here'\n- Collapsible panel, default expanded\n\n3. TWO BUTTONS:\n- [Save Draft] (ghost/outline): Save userInsight to NotebookBlock without AI evaluation\n- [Get AI Feedback] (primary): Submit for AI evaluation before saving\n\n4. LINK TO EXISTING BLOCK:\n- When selected topic has existing blocks, show list of block summaries\n- User can choose 'Link to existing block' (adds sourceItemId to existing block's sources)\n- Or 'Create new block' (proceeds with insight writing)\n- Linking = no new writing needed, just association\n\n5. KILL BATCH FLOW:\n- Remove batchAddToNotebook from database.ts, ipc-handlers, preload, store\n- Remove BatchActions UI components that use batch notebook operations\n- Single-item 'Add to Notebook' is the only path\n\nPRINCIPLE: 'Extraction IS the learning' — each source forces articulation of what YOU learned from THAT source. Board Relevance guides WHAT to focus on based on your practice Q history.",
        "testStrategy": "Click Add to Notebook on KB item, verify modal shows source preview + insight textarea. Submit with <20 chars, verify validation error. Select topic with existing blocks, verify 'Link to existing?' prompt appears. Test Save Draft creates block without AI. Test batch actions removed from UI. Select topic with qbank items, verify Board Relevance Panel shows accuracy and tested concepts.",
        "priority": "high",
        "dependencies": [
          "118",
          "125"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Board Relevance Panel Component",
            "description": "Create BoardRelevancePanel.tsx component that shows practice Q cross-reference data for selected topic and computes relevanceScore",
            "dependencies": [],
            "details": "Create src/components/notebook/BoardRelevancePanel.tsx. Props: topicId (string), topicTags (string[]), sourceContent (string), onRelevanceComputed (score: RelevanceScore, reason: string) => void. Query: getBoardRelevanceForTopic(topicTags) IPC handler that returns { questionsAttempted: number, correctCount: number, testedConcepts: { concept: string, count: number }[], missedConcepts: { concept: string, sourceItemId: string }[] }.\n\nDISPLAY:\n- Header: '📊 Board Relevance'\n- Stats: 'X Qs attempted | Y% accuracy'\n- 'Tested:' list with concepts + count\n- 'You missed:' list with concept names (amber highlight)\n- Relevance indicator with score badge + reason\n\nRELEVANCE SCORING LOGIC (call onRelevanceComputed when computed):\n| Condition | Score | Reason |\n|-----------|-------|--------|\n| sourceContent matches missedConcepts | high | 'Targets your weak area' |\n| sourceContent matches testedConcepts | medium | 'Board-tested topic' |\n| questionsAttempted === 0 | unknown | 'No practice Q data' |\n| Topic has Qs but no concept match | low | 'Not tested in your Qs' |\n\nMATCHING LOGIC: Simple keyword match - check if any concept string appears in sourceContent (case-insensitive). Check missedConcepts first (higher priority).\n\nUI: Use Collapsible from shadcn/ui, default open. Badge colors: high=green, medium=blue, low=gray, unknown=yellow. Only render if topic selected. Styling: Card with muted background, amber accent for mistakes section.",
            "status": "pending",
            "testStrategy": "Select topic with qbank items where source matches missed concept, verify score=high. Select topic with qbank items where source matches tested concept, verify score=medium. Select topic with qbank items but no concept match, verify score=low. Select topic with no qbank items, verify score=unknown. Verify onRelevanceComputed callback fires with correct score/reason.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "IPC Handler: getBoardRelevanceForTopic",
            "description": "Create database query and IPC handler to aggregate board relevance data for a topic",
            "dependencies": [],
            "details": "Add getBoardRelevanceForTopic(topicTags: string[]) to database.ts. Query source_items WHERE sourceType='qbank' AND tags overlap with topicTags.\n\nRETURN INTERFACE:\n{\n  questionsAttempted: number,\n  correctCount: number,\n  accuracy: number, // percentage\n  testedConcepts: { concept: string, count: number }[],\n  missedConcepts: { concept: string, sourceItemId: string }[]\n}\n\nQUERY LOGIC:\n1. Base query: SELECT * FROM source_items WHERE sourceType='qbank' AND tags overlap topicTags\n2. Aggregate: COUNT(*) as questionsAttempted, SUM(CASE WHEN correctness='correct' THEN 1 ELSE 0 END) as correctCount\n3. Parse testedConcepts JSON arrays, flatten, count occurrences, return sorted by count desc\n4. For missedConcepts: Filter WHERE correctness='incorrect', extract testedConcepts with sourceItemId\n5. Calculate accuracy = (correctCount / questionsAttempted) * 100\n\nAdd IPC handler in ipc-handlers.ts: insights:getBoardRelevance. Expose in preload.ts and electron.d.ts.",
            "status": "pending",
            "testStrategy": "Call insights:getBoardRelevance with sample topic tags. Verify correct aggregation of questions, accuracy, tested concepts. Verify mistakes filtered correctly. Test with no matching qbank items returns zeros.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-08T20:00:00.000Z"
      },
      {
        "id": "120",
        "title": "NotebookBlock Schema Extension for AI Evaluation",
        "description": "Add userInsight, aiEvaluation, relevanceScore, and relevanceReason columns to notebook_blocks table. aiEvaluation stores JSON blob with gaps, examTrapType, confusionTags, feedbackText, evaluatedAt.",
        "details": "SCHEMA CHANGES:\n\n1. NEW COLUMNS on notebook_blocks:\n- userInsight TEXT (nullable for existing blocks)\n- aiEvaluation TEXT (JSON blob, nullable)\n- relevanceScore TEXT (nullable) - 'high' | 'medium' | 'low' | 'unknown'\n- relevanceReason TEXT (nullable) - e.g., 'Targets your weak area' or 'No Q data'\n\n2. aiEvaluation JSON STRUCTURE:\n{\n  gaps: string[];           // Identified knowledge gaps\n  examTrapType?: ExamTrapType; // Only set for incorrect items\n  confusionTags?: string[];  // e.g., ['Methotrexate vs Methylnaltrexone']\n  feedbackText: string;      // AI's response to user's insight\n  evaluatedAt: string;       // ISO timestamp\n}\n\n3. ExamTrapType ENUM (for T122):\n- 'qualifier-misread' // 'most common' vs 'most common abnormality'\n- 'negation-blindness' // 'NOT associated with'\n- 'age-population-skip' // Missing 'in children' or 'in pregnant women'\n- 'absolute-terms' // 'always', 'never', 'only'\n- 'best-vs-correct' // Multiple correct, one is 'best'\n- 'timeline-confusion' // 'initial' vs 'definitive'\n\n4. MIGRATION:\n- ALTER TABLE notebook_blocks ADD COLUMN userInsight TEXT\n- ALTER TABLE notebook_blocks ADD COLUMN aiEvaluation TEXT\n- ALTER TABLE notebook_blocks ADD COLUMN relevanceScore TEXT\n- ALTER TABLE notebook_blocks ADD COLUMN relevanceReason TEXT\n- Existing blocks get null values (backward compatible)\n\n5. UPDATE DbNotebookBlock INTERFACE:\n- Add userInsight?: string\n- Add aiEvaluation?: NotebookBlockAiEvaluation (typed interface)\n- Add relevanceScore?: 'high' | 'medium' | 'low' | 'unknown'\n- Add relevanceReason?: string\n\n6. RELEVANCE SCORE LOGIC (set during Add to Notebook flow):\n- high: Content matches missedConcepts from practice Qs → 'Targets your weak area'\n- medium: Content matches testedConcepts → 'Board-tested topic'\n- unknown: No practice Q history for topic → 'No practice Q data'\n- low: Topic has Qs but content doesn't match tested concepts → 'Not tested in your Qs'",
        "testStrategy": "Run migration, verify 4 columns added. Create block with userInsight, verify persistence. Create block with aiEvaluation JSON, verify JSON round-trip. Create block with relevanceScore='high' and relevanceReason='Targets your weak area', verify persistence. Query existing blocks, verify null handling for all fields.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript types for AI evaluation schema",
            "description": "Create TypeScript type definitions for ExamTrapType, NotebookBlockAiEvaluation, and RelevanceScore in src/types/index.ts",
            "dependencies": [],
            "details": "Add the following type definitions to src/types/index.ts:\n\n1. ExamTrapType union type with 6 variants: 'qualifier-misread', 'negation-blindness', 'age-population-skip', 'absolute-terms', 'best-vs-correct', 'timeline-confusion'\n\n2. NotebookBlockAiEvaluation interface with fields:\n   - gaps: string[] (identified knowledge gaps)\n   - examTrapType?: ExamTrapType (only for incorrect items)\n   - confusionTags?: string[] (e.g. medication confusion pairs)\n   - feedbackText: string (AI response to user insight)\n   - evaluatedAt: string (ISO timestamp)\n\n3. RelevanceScore type as union: 'high' | 'medium' | 'low' | 'unknown'\n\n4. Update NotebookBlock interface to include:\n   - userInsight?: string\n   - aiEvaluation?: NotebookBlockAiEvaluation\n   - relevanceScore?: RelevanceScore\n   - relevanceReason?: string\n\nThese types will be imported by database layer and React components.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes. Import types in a test file to ensure they're properly exported. Check that NotebookBlock interface extends correctly without breaking existing code.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T16:19:52.895Z"
          },
          {
            "id": 2,
            "title": "Create database migration v17 and update DbNotebookBlock interface",
            "description": "Add migration file to create 4 new columns on notebook_blocks table and update DbNotebookBlock/NotebookBlockRow interfaces in electron/database/types.ts",
            "dependencies": [
              1
            ],
            "details": "1. Create electron/database/migrations/v17.ts following v15 migration pattern:\n   - ALTER TABLE notebook_blocks ADD COLUMN userInsight TEXT\n   - ALTER TABLE notebook_blocks ADD COLUMN aiEvaluation TEXT (will store JSON string)\n   - ALTER TABLE notebook_blocks ADD COLUMN relevanceScore TEXT\n   - ALTER TABLE notebook_blocks ADD COLUMN relevanceReason TEXT\n   - All columns nullable for backward compatibility\n   - setSchemaVersion(17) at end\n\n2. Update electron/database/types.ts:\n   - Add 4 new optional fields to DbNotebookBlock interface\n   - Add 4 new nullable fields to NotebookBlockRow interface\n   - Import NotebookBlockAiEvaluation type from src/types\n\n3. Register migration in electron/database/migrations/index.ts by adding v17 to the migrations array.\n\n4. Update parseNotebookBlockRow in electron/database/notebook-blocks.ts to handle new fields (parse aiEvaluation JSON if present, convert null to undefined).",
            "status": "done",
            "testStrategy": "Run app to trigger migration. Verify schema_version=17. Query notebook_blocks table to confirm 4 new columns exist. Create test block with all new fields populated, verify JSON round-trip for aiEvaluation. Query existing blocks to verify null handling doesn't break.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T16:26:32.529Z"
          },
          {
            "id": 3,
            "title": "Update IPC layer to expose new NotebookBlock fields",
            "description": "Ensure notebook block IPC handlers and preload API properly return and accept the new schema fields (userInsight, aiEvaluation, relevanceScore, relevanceReason)",
            "dependencies": [
              2
            ],
            "details": "Review and update as needed:\n\n1. electron/ipc-handlers.ts:\n   - Verify notebookBlocks:getByPage handler returns full DbNotebookBlock (already using notebookBlockQueries.getByPage)\n   - Verify notebookBlocks:getById handler returns full DbNotebookBlock\n   - Verify notebookBlocks:create accepts all fields from DbNotebookBlock interface\n   - Verify notebookBlocks:update accepts partial updates including new fields\n\n2. electron/preload.ts:\n   - Verify notebookBlocks API object exposes correct methods\n   - No type changes needed (using 'unknown' parameter types)\n\n3. src/types/electron.d.ts:\n   - Verify window.api.notebookBlocks method signatures match actual handlers\n   - Update if return types need to reflect new fields\n\nNo code changes should be needed if handlers already use the DbNotebookBlock interface. This subtask is verification + any necessary type alignment.",
            "status": "done",
            "testStrategy": "Use React DevTools to inspect NotebookBlock objects returned from IPC calls. Verify new fields are present (even if null/undefined). Test creating a block with userInsight populated via IPC, verify persistence. Test updating relevanceScore on existing block, verify change persists.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T16:33:18.152Z"
          }
        ],
        "updatedAt": "2026-01-16T16:33:18.152Z"
      },
      {
        "id": "121",
        "title": "AI Insight Evaluation Endpoint",
        "description": "Create IPC handler + AI prompt for evaluating user insights. Returns gaps, examTrapType (when incorrect), confusionTags, and feedbackText.",
        "details": "AI INSIGHT EVALUATION:\n\n1. NEW IPC HANDLER:\n- ai:evaluateInsight\n- Input: { userInsight: string, sourceContent: string, isIncorrect: boolean, topicContext?: string }\n- Output: IpcResult<NotebookBlockAiEvaluation>\n\n2. AI PROMPT DESIGN:\nYou are a medical education expert evaluating a learner's written insight.\n\nSOURCE CONTENT:\n{sourceContent}\n\nLEARNER'S INSIGHT:\n{userInsight}\n\nTOPIC CONTEXT: {topicContext}\n\nEvaluate the insight and return JSON:\n{\n  \"gaps\": [\"list of knowledge gaps or missing key points\"],\n  \"feedbackText\": \"Constructive feedback on the insight (2-3 sentences)\",\n  \"confusionTags\": [\"any concept pairs that might be confused\"],\n  \"examTrapType\": null // Only classify if this was a WRONG answer\n}\n\n3. EXAM TRAP CLASSIFICATION (only when isIncorrect=true):\nAdditional prompt section:\n\"The learner got this question WRONG. Classify the error type:\n- qualifier-misread: Misread qualifiers like 'most common' vs 'most common abnormality'\n- negation-blindness: Missed 'NOT' or 'EXCEPT' in question\n- age-population-skip: Missed population specifier (children, pregnant, elderly)\n- absolute-terms: Tricked by 'always', 'never', 'only' (usually wrong)\n- best-vs-correct: Picked correct but not BEST answer\n- timeline-confusion: Confused initial vs definitive management\n- null: Knowledge gap, not exam trap\"\n\n4. AI SERVICE FUNCTION:\n- electron/ai-service.ts: evaluateInsight()\n- Use Claude/OpenAI with JSON mode\n- Cache by hash(userInsight + sourceContent)\n\n5. IPC WIRING:\n- ipc-handlers.ts: add handler\n- preload.ts: expose window.api.ai.evaluateInsight\n- electron.d.ts: type definition",
        "testStrategy": "Call evaluateInsight with sample insight + source, verify JSON response structure. Test with isIncorrect=true, verify examTrapType populated. Test with isIncorrect=false, verify examTrapType is null. Test caching behavior.",
        "priority": "high",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-08T20:00:00.000Z"
      },
      {
        "id": "122",
        "title": "AI Feedback Panel in Insight Modal",
        "description": "After 'Get AI Feedback' clicked, show inline panel in modal with gaps, exam trap type, confusion tags, and AI feedback. User can refine insight or accept.",
        "details": "AI FEEDBACK PANEL UI:\n\n1. TRIGGER:\n- User clicks [Get AI Feedback] button in Insight Writing Modal (T119)\n- Button shows loading spinner during AI call\n- Panel appears below insight textarea when response received\n\n2. PANEL LAYOUT:\n┌─────────────────────────────────────────┐\n│ AI Feedback                    [Retry] │\n├─────────────────────────────────────────┤\n│ 💡 Feedback:                            │\n│ \"Your insight captures the key point   │\n│ about X, but consider adding...\"        │\n├─────────────────────────────────────────┤\n│ ⚠️ Gaps Identified:                     │\n│ • Missing: mechanism of action          │\n│ • Consider: contraindications           │\n├─────────────────────────────────────────┤\n│ 🔀 Potential Confusions:                │\n│ [Methotrexate vs Methylnaltrexone]      │\n├─────────────────────────────────────────┤\n│ 🎯 Exam Trap Detected: (only if wrong)  │\n│ Qualifier Misread - You may have...     │\n└─────────────────────────────────────────┘\n\n3. USER ACTIONS:\n- Refine insight textarea based on feedback\n- Click [Get AI Feedback] again to re-evaluate\n- Click [Save to Notebook] to save with current aiEvaluation\n- Feedback panel collapses but aiEvaluation is stored\n\n4. SAVE BEHAVIOR:\n- If AI feedback received: save both userInsight AND aiEvaluation to block\n- If Save Draft (no AI): save only userInsight, aiEvaluation is null\n\n5. STYLING:\n- Use existing shadcn Alert/Card components\n- Color-code sections (amber for gaps, red for exam trap, blue for confusions)\n- Collapsible sections if too long",
        "testStrategy": "Click Get AI Feedback, verify loading state. Verify panel appears with all sections. Edit insight and re-submit, verify new feedback. Save to Notebook, verify both userInsight and aiEvaluation persisted. Test Save Draft path, verify aiEvaluation is null.",
        "priority": "high",
        "dependencies": [
          "119",
          "121"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-08T20:00:00.000Z"
      },
      {
        "id": "123",
        "title": "Learning Tab Weak Points Panel",
        "description": "Add collapsible panel to Learning Tab showing aggregated weakness data: trap type breakdown, top confusion pairs, weak topics by difficulty. Pulls from review_logs + notebook_blocks.aiEvaluation.",
        "details": "WEAK POINTS PANEL:\n\n1. LOCATION:\n- Inside Learning Tab (ReviewInterface area)\n- Collapsible panel below daily review stats\n- Shows when user has review data (not on first use)\n\n2. PANEL SECTIONS:\n\n┌─────────────────────────────────────────┐\n│ 📊 Your Weak Points            [▼ Hide] │\n├─────────────────────────────────────────┤\n│ EXAM TRAPS (last 30 days)               │\n│ ┌────────────────────────────────────┐  │\n│ │ Qualifier Misread    ████████ 8    │  │\n│ │ Negation Blindness   ████ 4        │  │\n│ │ Timeline Confusion   ██ 2          │  │\n│ └────────────────────────────────────┘  │\n├─────────────────────────────────────────┤\n│ CONFUSION PAIRS                         │\n│ • Methotrexate ↔ Methylnaltrexone (3x)  │\n│ • Type 1 ↔ Type 2 RTA (2x)              │\n├─────────────────────────────────────────┤\n│ WEAK TOPICS (by card difficulty)        │\n│ • Nephrology (avg difficulty: 0.72)     │\n│ • Cardiology (avg difficulty: 0.68)     │\n│ [View all in Card Browser →]            │\n└─────────────────────────────────────────┘\n\n3. DATA SOURCES:\n- Exam traps: Aggregate examTrapType from notebook_blocks.aiEvaluation\n- Confusion pairs: Aggregate confusionTags from notebook_blocks.aiEvaluation\n- Weak topics: Existing WeakTopicSummary from T117/T45\n\n4. NEW IPC HANDLERS:\n- insights:getExamTrapBreakdown -> { trapType: string, count: number }[]\n- insights:getConfusionPairs -> { pair: string, count: number }[]\n- Reuse existing cards:getWeakTopics\n\n5. AGGREGATION QUERIES:\n- Group by examTrapType WHERE examTrapType IS NOT NULL, count, order by count DESC\n- Parse confusionTags JSON arrays, flatten, count occurrences\n- Time-bound to last 30 days for relevance\n\n6. UI INTEGRATION:\n- Add to ReviewInterface.tsx or create WeakPointsPanel.tsx component\n- Default collapsed, remembers state in localStorage\n- Only show sections with data (hide empty trap types)",
        "testStrategy": "Create blocks with various examTrapTypes, verify aggregation. Verify confusion pair counting. Navigate to Learning Tab, verify panel renders. Toggle collapse, verify state persists. Test with no data, verify graceful empty state.",
        "priority": "high",
        "dependencies": [
          "120",
          "122"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-08T20:00:00.000Z"
      },
      {
        "id": "124",
        "title": "Tampermonkey Script Integration for Quick Capture",
        "description": "Hook up Tampermonkey script so user can auto-pull Board Questions from PeerPrep and MKSAP into Quick Capture Screen. Script sends question data to DougHub via local endpoint or clipboard, Quick Capture receives and pre-populates fields.",
        "details": "TAMPERMONKEY INTEGRATION:\n\n1. COMMUNICATION METHOD:\n- Option A: Local HTTP server in Electron (localhost:PORT)\n- Option B: Clipboard-based with special format detection\n- Option C: Custom protocol handler (doughub://capture?data=...)\n\n2. DATA PAYLOAD FROM SCRIPT:\n- Question stem text\n- Answer choices (if MCQ)\n- Correct answer (if available)\n- Source platform (PeerPrep/MKSAP)\n- URL/reference ID\n- Any associated explanation text\n\n3. QUICK CAPTURE INTEGRATION:\n- Detect incoming data from Tampermonkey\n- Pre-populate Quick Capture fields\n- Set sourceType appropriately\n- User reviews and confirms capture\n\n4. EXISTING SCRIPT:\n- User has basic Tampermonkey script already\n- Need to flesh out data extraction for each platform\n- Need to establish communication with DougHub app",
        "testStrategy": "Install Tampermonkey script, navigate to PeerPrep question, trigger capture. Verify data arrives in Quick Capture with fields pre-populated. Test MKSAP integration. Test error handling when DougHub not running.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Express HTTP capture server in Electron main process",
            "description": "Implement localhost:23847 HTTP server to receive POST requests from Tampermonkey script with board question data payload",
            "dependencies": [],
            "details": "Create electron/capture-server.ts with Express server listening on port 23847. Implement POST /api/capture endpoint that receives CapturePayload (timestamp, url, hostname, siteName, pageHTML, images[]). Add error handling, CORS configuration for localhost only, and integration with main.ts to start server on app ready. Server should return JSON response with success/error status. Add graceful shutdown on app quit.",
            "status": "done",
            "testStrategy": "Use curl or Postman to POST sample payload to localhost:23847/api/capture. Verify server starts with Electron app, accepts requests, and shuts down cleanly. Test error handling with malformed payloads.",
            "updatedAt": "2026-01-12T20:17:04.648Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create board question parser types and base structure",
            "description": "Define BoardQuestionContent types and create parser dispatcher with stub implementations for site-specific parsers",
            "dependencies": [],
            "details": "Create electron/parsers/board-question-parser.ts with functions to parse HTML into BoardQuestionContent structure (source, questionId, vignetteHtml, questionStemHtml, answers[], wasCorrect, explanationHtml, keyPointsHtml, images[]). Implement site-specific selector maps for PeerPrep (.questionStem, .answerOption, .correct-answer, .feedbackTab, .keyPointsTab, #media-links) and MKSAP 19 (.question-text, .answer-option, .critique, .educational-objective). Add duplicate detection logic by URL to append to attempts[] array. Export parseBoardQuestion(html: string, siteName: string, url: string) function.\n<info added on 2026-01-08T21:42:10.676Z>\nI'll analyze the codebase to understand the current parser structure and types before generating the subtask update.Based on my analysis of the codebase, here's the text that should be added to the subtask:\n\n---\n\nUPDATED SCOPE: This subtask creates types and base structure only. Site-specific implementations moved to T124.6 (PeerPrep) and T124.7 (MKSAP).\n\nCreate electron/parsers/ directory and electron/parsers/board-question-parser.ts file. Define BoardQuestionContent interface matching HANDOFF-T124.md spec (source, questionId, category, capturedAt, sourceUrl, vignetteHtml, questionStemHtml, answers[], wasCorrect, explanationHtml, keyPointsHtml, images[], attempts[]). Include AnswerOption interface with letter, html, isCorrect, isUserChoice, peerPercent fields. Include AttemptRecord interface with attemptNumber, date, chosenAnswer, wasCorrect, note fields. Create parseBoardQuestion(html: string, siteName: 'peerprep' | 'mksap', url: string): BoardQuestionContent function signature that dispatches to site-specific parsers. Add stub implementations for parsePeerPrep() and parseMKSAP() that throw new Error('Not implemented - see T124.6/T124.7'). Install cheerio for HTML parsing (npm install cheerio @types/cheerio). Export all types and parseBoardQuestion function. Aligns with existing IPC patterns in electron/ipc-handlers.ts and database types in electron/database.ts.\n</info added on 2026-01-08T21:42:10.676Z>",
            "status": "done",
            "testStrategy": "Create unit tests with sample HTML from PeerPrep and MKSAP. Verify correct extraction of vignette, answers, explanations, and images. Test duplicate detection creates attempts entries. Validate output matches BoardQuestionContent schema.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.652Z"
          },
          {
            "id": 3,
            "title": "Implement image download service for board question media",
            "description": "Create service to download remote images from board questions and save them to userData/images/ directory as local files",
            "dependencies": [],
            "details": "Create electron/services/image-service.ts with downloadImage(url: string): Promise<string> function that fetches remote images, generates unique filenames using crypto.randomUUID(), saves to app.getPath('userData')/images/, and returns relative path (images/filename.ext). Handle image format detection from Content-Type header. Add retry logic for failed downloads. Process images[] array from CapturePayload and update BoardQuestionContent.images[] with localPath and location metadata. Create images directory if it doesn't exist.",
            "status": "done",
            "testStrategy": "Test with various image URLs (jpg, png, gif). Verify files are saved to correct userData/images/ directory with unique names. Test error handling for 404s and network failures. Confirm relative paths are correctly formatted for cross-platform compatibility.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.655Z"
          },
          {
            "id": 4,
            "title": "Wire up IPC handlers and types for capture integration",
            "description": "Add IPC handler for capture:receive, update preload.ts and electron.d.ts with CapturePayload and BoardQuestionContent types, integrate parser and image services",
            "dependencies": [
              1,
              3,
              6,
              7
            ],
            "details": "In electron/ipc-handlers.ts, add capture:receive handler that: 1) calls board-question-parser to extract BoardQuestionContent, 2) calls image-service to download and save images, 3) creates SourceItem with sourceType='qbank' and rawContent=JSON.stringify(boardQuestionContent), 4) shows system notification using Electron Notification API even when backgrounded. Update electron/preload.ts to expose api.capture.receive(payload) method. Add TypeScript interfaces for CapturePayload and BoardQuestionContent to electron.d.ts. Update capture-server.ts to call IPC handler when POST is received.",
            "status": "done",
            "testStrategy": "Send test capture from Tampermonkey script. Verify SourceItem is created in database with qbank sourceType. Confirm images are downloaded and paths stored correctly. Test system notification appears when app is backgrounded. Check IPC communication with Electron DevTools.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.657Z"
          },
          {
            "id": 5,
            "title": "Create BoardQuestionView React component",
            "description": "Build React component to render structured board question content in Knowledge Bank",
            "dependencies": [
              4
            ],
            "details": "Create src/components/BoardQuestionView.tsx component that renders BoardQuestionContent: vignetteHtml in styled container, questionStemHtml, answers[] with letter/html/isCorrect/peerPercent display, explanationHtml and keyPointsHtml as expandable sections, images with localPath rendering, and collapsible Attempts (N) badge showing attempts[] history. Add HTML rendering with safe styling (no sanitization per spec). Update user's Tampermonkey script to change target port to 23847, ensure it POSTs CapturePayload format with pageHTML and images[] to /api/capture endpoint. Add error handling and user feedback in script.\n<info added on 2026-01-08T21:43:48.551Z>\nI'll analyze the codebase to provide specific implementation guidance for the BoardQuestionView component.Based on my codebase analysis, here's the update text for the subtask focusing only on the BoardQuestionView React component:\n\n---\n\nCOMPONENT STRUCTURE:\n- Import shadcn/ui components: Card, CardHeader, CardTitle, CardContent (src/components/ui/card.tsx), Badge (src/components/ui/badge.tsx), Collapsible/CollapsibleTrigger/CollapsibleContent (src/components/ui/collapsible.tsx)\n- Import Tailwind utility: cn from @/lib/utils\n- Follow existing component patterns from src/components/cards/CardBrowserView.tsx and src/components/review/ReviewInterface.tsx\n\nINTERFACE DEFINITION (based on docs/HANDOFF-T124.md lines 54-98):\n```typescript\ninterface BoardQuestionContent {\n  source: 'peerprep' | 'mksap';\n  questionId?: string;\n  category?: string;\n  capturedAt: string;\n  sourceUrl: string;\n  vignetteHtml: string;\n  questionStemHtml: string;\n  answers: {\n    letter: string;\n    html: string;\n    isCorrect: boolean;\n    isUserChoice: boolean;\n    peerPercent?: number;\n  }[];\n  wasCorrect: boolean;\n  explanationHtml: string;\n  keyPointsHtml?: string;\n  images: {\n    localPath: string;\n    caption?: string;\n    location: 'vignette' | 'explanation' | 'keypoint';\n  }[];\n  attempts: {\n    attemptNumber: number;\n    date: string;\n    chosenAnswer: string;\n    wasCorrect: boolean;\n    note?: string;\n  }[];\n}\n```\n\nRENDER LAYOUT (reference design from docs/HANDOFF-T124.md lines 210-241):\n1. Card wrapper with header showing source badge, category, date, result indicator (✓/❌), and collapsible Attempts(N) badge\n2. Vignette section with vignetteHtml rendered via dangerouslySetInnerHTML, styled with prose class\n3. Question stem section with questionStemHtml\n4. Answers grid showing letter, html content, peer percentage bar chart, correct checkmark, user selection dot\n5. Collapsible sections for Explanation (explanationHtml) and Key Points (keyPointsHtml) using Collapsible components\n6. Image rendering: filter images by location field and display inline in respective sections using localPath\n\nHTML RENDERING:\n- Use dangerouslySetInnerHTML={{ __html: content }} for all HTML fields per spec requirement (no sanitization)\n- Apply Tailwind prose classes for medical content typography\n- Images: <img src={`file://${app.getPath('userData')}/images/${localPath}`} /> pattern\n\nSTYLING:\n- Follow existing component styling patterns from CardBrowserView.tsx\n- Use Badge variants (secondary, destructive, outline) for metadata display\n- Result indicator: green CheckCircle2 icon for correct, red XCircle for incorrect\n- Answer grid: flex layout with hover states, peer percentage as horizontal bar using Tailwind width utilities\n\nATTEMPTS BADGE:\n- Collapsible component toggled by Badge with Attempts(N) text\n- CollapsibleContent shows attempts[] array in reverse chronological order\n- Display format: \"Attempt {N} - {date} - {chosenAnswer} - {✓/❌} {note?}\"\n</info added on 2026-01-08T21:43:48.551Z>",
            "status": "done",
            "testStrategy": "Open Knowledge Bank inbox, find qbank item, and verify BoardQuestionView renders all sections correctly including images, vignette, answers, and explanation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.660Z"
          },
          {
            "id": 6,
            "title": "Implement PeerPrep HTML parser",
            "description": "Implement parsePeerPrep() function with ACEP PeerPrep-specific CSS selectors and extraction logic",
            "dependencies": [
              2
            ],
            "details": "Implement parsePeerPrep() function in electron/parsers/board-question-parser.ts. PeerPrep CSS selectors: vignette (.questionStem, .question-stem), answers (.answerOption, .answer-choice), correct answer (.correct-answer, [class*=\"correct\"]), user selection (.selected, .user-selected, [class*=\"selected\"]), peer percentages (.peer-response, .percentage), explanation (.feedbackTab, .feedback-content), key points (.keyPointsTab, .key-points), question images (#media-links a.fancybox), explanation images (.feedbackTab img, .keyPointsTab img). Extract peer percentage from adjacent text (e.g. '49%'). Parse each answer detecting correct and user-selected. Determine wasCorrect by comparing user choice to correct answer. Collect image URLs with source location for later download. Handle missing optional fields gracefully.",
            "status": "done",
            "testStrategy": "Test with sample PeerPrep HTML. Verify extraction of vignette, answers with peer percentages, explanation, key points, and image URLs. Validate output matches BoardQuestionContent schema.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.662Z"
          },
          {
            "id": 7,
            "title": "Implement MKSAP HTML parser",
            "description": "Implement parseMKSAP() function with MKSAP 19-specific CSS selectors and extraction logic",
            "dependencies": [
              2
            ],
            "details": "Implement parseMKSAP() function in electron/parsers/board-question-parser.ts. MKSAP CSS selectors: vignette (.question-text, .stem), answers (.answer-option), correct answer (.correct), user selection (.selected), explanation (.critique, .explanation), educational objective (.educational-objective). MKSAP may not have peer percentages - leave undefined. Educational objective maps to keyPointsHtml. Handle MKSAP's different HTML structure for answers. Collect image URLs from question and explanation sections. Same approach as PeerPrep: preserve raw HTML, no sanitization.",
            "status": "done",
            "testStrategy": "Test with sample MKSAP HTML. Verify extraction of vignette, answers, explanation, and educational objectives. Validate output matches BoardQuestionContent schema.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.665Z"
          },
          {
            "id": 8,
            "title": "Update Tampermonkey script for DougHub integration",
            "description": "Update the Tampermonkey userscript to POST captured board questions to DougHub's localhost server",
            "dependencies": [
              4
            ],
            "details": "Update Tampermonkey script: change target port from 55590 to 23847, POST to /api/capture endpoint. Send CapturePayload with timestamp (ISO string), url (window.location.href), hostname, siteName ('ACEP PeerPrep' | 'MKSAP 19' based on hostname), pageHTML (document.documentElement.outerHTML), bodyText (document.body.innerText), images array. Image extraction: find #media-links a.fancybox for PeerPrep question images, img tags in feedback sections with source location. Trigger detection: wait for 'Key Point' text (PeerPrep) or 'Correct Answer' text (MKSAP). Add 'Send to DougHub' button that appears after answer submission, styled to match site. Show loading state during POST, success/error toast notification. Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s). User-friendly error if DougHub not running.",
            "status": "done",
            "testStrategy": "Install updated Tampermonkey script. Navigate to PeerPrep question, submit answer, click Send to DougHub. Verify POST request sent to localhost:23847/api/capture with correct payload. Test error handling when DougHub is not running. Test on MKSAP question.",
            "parentId": "undefined",
            "updatedAt": "2026-01-12T20:17:04.667Z"
          }
        ],
        "updatedAt": "2026-01-12T20:17:04.667Z"
      },
      {
        "id": "125",
        "title": "Data Logging Framework: Schema Extensions for Future AI",
        "description": "Add schema fields across layers to enable future AI features. Capture Screen: correctness field. Knowledge Bank: notes field. Cards: targetedConfusion field. Learning Tab: confidenceRating field. These fields prepare the data foundation for POST-MVP AI enhancements.",
        "details": "DATA LOGGING FRAMEWORK:\n\nPurpose: Add schema fields NOW so data starts accumulating for POST-MVP AI features.\n\n1. CAPTURE SCREEN (source_items table):\n- ADD: correctness TEXT (nullable) - 'correct' | 'incorrect' | null\n- Purpose: Track whether board question was answered correctly at capture time\n- UI: Add Correct/Incorrect toggle to QuickCaptureModal when sourceType is 'qbank'\n\n2. KNOWLEDGE BANK (source_items table):\n- ADD: notes TEXT (nullable)\n- Purpose: Informal annotations ('I thought X because Y')\n- UI: Add notes textarea to SourceItemDetail view\n- IPC: Extend sourceItems:update to handle notes field\n\n3. KNOWLEDGE BANK (source_items table):\n- ADD: testedConcepts TEXT (nullable, JSON array)\n- Purpose: AI-extracted testable concepts from board questions\n- Example: [\"Kanavel signs\", \"consult threshold\", \"empiric abx\"]\n- Populated: During T124 board Q capture via AI extraction from explanation/key points\n- Enables: Board Relevance Panel (T119) showing commonly tested concepts and user weak spots\n\n4. CARDS (cards table):\n- ADD: targetedConfusion TEXT (nullable)\n- Purpose: Which confusion pair this card addresses (e.g., 'Methotrexate vs Methylnaltrexone')\n- Set during card generation when aiEvaluation.confusionTags exists\n- UI: Show badge on card in Card Browser\n\n- ADD: relevanceScore TEXT (nullable) - 'high' | 'medium' | 'low' | 'unknown'\n- ADD: relevanceReason TEXT (nullable) - e.g., 'Targets your weak area'\n- Purpose: Inherited from parent NotebookBlock at card generation time\n- Enables: Batch Review Smart View to filter low-relevance cards\n\n5. LEARNING TAB (review_logs table):\n- ADD: confidenceRating TEXT (nullable) - 'forgot' | 'struggled' | 'knew_it'\n- Purpose: Explicit confidence signal beyond pass/fail\n- UI: Optional 3-button confidence rating after answer reveal (Forgot / Struggled / Knew It)\n- Default: null if user skips confidence rating\n\nMIGRATION:\n- All fields nullable with no default\n- Add columns via ALTER TABLE (7 total: correctness, notes, testedConcepts, targetedConfusion, relevanceScore, relevanceReason, confidenceRating)\n- Update DbSourceItem, DbCard, DbNotebookBlock interfaces\n- Update insert/update queries\n- No data migration needed (new fields only)\n\nDATA FLOW PREP:\n- These fields enable: Response time weighting, Aggregated confusion reports, Auto-generated comparison cards, AI practice questions, Semantic interference detection, 7-step learning pipeline, Board Relevance Panel (Practice Q cross-reference)",
        "testStrategy": "Verify migration adds all 7 columns (correctness, notes, testedConcepts, targetedConfusion, relevanceScore, relevanceReason, confidenceRating). Test correctness toggle in QuickCaptureModal for qbank items. Test notes textarea in SourceItemDetail. Test testedConcepts populated for qbank items. Test relevanceScore/relevanceReason on cards inherits from parent block. Test confidenceRating buttons in Learning Tab. Verify null handling when fields not set.",
        "priority": "high",
        "dependencies": [
          "118",
          "117"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Database migration v16: Add 7 schema columns for AI data logging",
            "description": "Create migration v16 adding nullable columns: source_items (correctness, notes, testedConcepts), cards (targetedConfusion, relevanceScore, relevanceReason), review_logs (confidenceRating)",
            "dependencies": [],
            "details": "Create electron/database/migrations/v16.ts following the pattern from v15.ts. Add ALTER TABLE statements for: 1) source_items.correctness TEXT NULL, 2) source_items.notes TEXT NULL, 3) source_items.testedConcepts TEXT NULL (JSON array), 4) cards.targetedConfusion TEXT NULL, 5) cards.relevanceScore TEXT NULL ('high'|'medium'|'low'|'unknown'), 6) cards.relevanceReason TEXT NULL, 7) review_logs.confidenceRating TEXT NULL ('forgot'|'struggled'|'knew_it'). Update migrations/index.ts to import and call migrateToV16. Use database.transaction() and setSchemaVersion(16). All fields nullable with no defaults.",
            "status": "pending",
            "testStrategy": "Run app and verify migration executes. Query schema with PRAGMA table_info() for each table. Insert test records with new fields and verify persistence. Verify existing data unaffected (all new fields NULL).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update TypeScript interfaces for 7 new database fields",
            "description": "Extend DbSourceItem, DbCard, DbReviewLog, SourceItemRow, CardRow, ReviewLogRow interfaces in electron/database/types.ts to include new nullable fields with proper types",
            "dependencies": [
              1
            ],
            "details": "In electron/database/types.ts, add to DbSourceItem: correctness?: 'correct' | 'incorrect' | null, notes?: string, testedConcepts?: string[] (stored as JSON in DB). Add to DbCard: targetedConfusion?: string, relevanceScore?: 'high' | 'medium' | 'low' | 'unknown', relevanceReason?: string. Add to DbReviewLog: confidenceRating?: 'forgot' | 'struggled' | 'knew_it'. Mirror these in the corresponding Row interfaces (SourceItemRow, CardRow, ReviewLogRow) where JSON fields like testedConcepts become 'string' type in Row interfaces. Follow existing pattern where public interfaces have parsed types, Row interfaces have raw SQLite types.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes. Verify types properly inferred in database query files. Test that parseSourceItemRow, parseCardRow, parseReviewLogRow handle new fields (JSON.parse for testedConcepts).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Correct/Incorrect toggle UI in QuickCaptureModal for qbank items",
            "description": "Add correctness field toggle (Correct/Incorrect/Skip) in QuickCaptureModal when detectedType === 'qbank', persisting value to source_items.correctness on save",
            "dependencies": [
              2
            ],
            "details": "In src/components/modals/QuickCaptureModal.tsx, add state: const [correctness, setCorrectness] = useState<'correct' | 'incorrect' | null>(null). Below the title Input (around line 313), conditionally render when detectedType === 'qbank': a label 'Did you answer correctly?' and three toggle buttons (Correct/Incorrect/Skip) using Button variant='outline' with active state styling. Update handleSave() to include correctness in sourceItem object when detectedType === 'qbank'. Reset correctness to null in handleCancel and after successful save. Use theme colors (bg-success, bg-destructive, bg-muted) for visual feedback.",
            "status": "pending",
            "testStrategy": "Paste qbank URL in QuickCaptureModal, verify toggle appears. Select Correct, save, verify source_items.correctness='correct'. Select Incorrect, save, verify correctness='incorrect'. Select Skip or don't interact, verify correctness=null. Test non-qbank content, verify toggle hidden.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add notes textarea in SourceItemViewerDialog for annotations",
            "description": "Add editable notes textarea to SourceItemViewerDialog allowing users to add informal annotations, with auto-save debouncing and persistence to source_items.notes",
            "dependencies": [
              2
            ],
            "details": "In src/components/knowledgebank/SourceItemViewerDialog.tsx, after the main content area (around line 87), add a collapsible section 'Notes' with a Textarea component. Add local state for notes value and debounced save (400ms). On mount, load item.notes into state. Create IPC call window.api.sourceItems.update() to persist notes field. Show 'Saving...' indicator during save. Use muted background styling to distinguish notes from main content. Add placeholder text 'Add informal annotations (e.g., \"I thought X because Y\")'. Make section collapsible with Collapsible component from shadcn/ui.",
            "status": "pending",
            "testStrategy": "Open SourceItemViewerDialog, type in notes field, wait 400ms, verify IPC update call made. Refresh view, verify notes persisted. Test rapid typing, verify debouncing works (only one save after typing stops). Test empty notes, verify saves null/empty string correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add confidence rating buttons in Learning/Review interface",
            "description": "Add optional 3-button confidence rating UI (Forgot/Struggled/Knew It) after answer reveal in card review flow, persisting to review_logs.confidenceRating",
            "dependencies": [
              2
            ],
            "details": "Locate card review component (likely in src/components/review/ or referenced from AppLayout.tsx). After user reveals answer and before/alongside FSRS rating buttons (Again/Hard/Good/Easy), add optional confidence rating prompt: 'How confident were you?' with three buttons: 'Forgot' (destructive variant), 'Struggled' (warning variant), 'Knew It' (success variant). Add state for confidenceRating. When user submits review (via existing FSRS buttons), include confidenceRating in review log creation. Default to null if user skips confidence rating. Style as secondary action (smaller, less prominent than FSRS buttons). Update reviewLogQueries.create() to accept and store confidenceRating field.",
            "status": "pending",
            "testStrategy": "Start card review, reveal answer, verify confidence buttons appear. Click 'Forgot' then rate card, verify review_logs.confidenceRating='forgot'. Click 'Knew It' then rate, verify 'knew_it'. Skip confidence rating, verify confidenceRating=null. Verify FSRS scheduling unaffected by confidence rating.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-08T22:00:00.000Z"
      },
      {
        "id": "126",
        "title": "v16 Migration: Create notebook_links Table",
        "description": "Create the notebook_links table to enable cross-topic block linking. This is a prerequisite for Workflows 3, 6 Enhancement, 8, 9, and 10.",
        "details": "DATABASE MIGRATION v16:\n\nCreate the notebook_links table for block-to-block references (AI-detected and manual backlinks).\n\nSCHEMA:\n```sql\nCREATE TABLE notebook_links (\n  id TEXT PRIMARY KEY,\n  sourceBlockId TEXT NOT NULL REFERENCES notebook_blocks(id),\n  targetBlockId TEXT NOT NULL REFERENCES notebook_blocks(id),\n  linkType TEXT NOT NULL,                 -- same_concept|related_topic|cross_specialty|comparison|builds_on\n  reason TEXT,                            -- AI or user explanation\n  anchorText TEXT,                        -- The phrase that triggered the link\n  anchorStart INTEGER,                    -- Character position in source block\n  anchorEnd INTEGER,\n  createdAt TEXT NOT NULL,\n  UNIQUE(sourceBlockId, targetBlockId)\n);\n```\n\nINDEXES:\n```sql\nCREATE INDEX idx_notebook_links_source ON notebook_links(sourceBlockId);\nCREATE INDEX idx_notebook_links_target ON notebook_links(targetBlockId);\n```\n\nTYPESCRIPT INTERFACE (add to electron/database/types.ts):\n```typescript\ninterface DbNotebookLink {\n  id: string;\n  sourceBlockId: string;\n  targetBlockId: string;\n  linkType: 'same_concept' | 'related_topic' | 'cross_specialty' | 'comparison' | 'builds_on';\n  reason?: string;\n  anchorText?: string;\n  anchorStart?: number;\n  anchorEnd?: number;\n  createdAt: string;\n}\n```\n\nIPC HANDLERS TO ADD:\n- notebookLinks:create - Create a new link\n- notebookLinks:getBySourceBlock - Get all links FROM a block\n- notebookLinks:getByTargetBlock - Get all links TO a block\n- notebookLinks:delete - Delete a link by ID\n- notebookLinks:search - Search blocks by content (for link modal)\n\nDATABASE QUERIES (add to electron/database/notebook-links.ts):\n```typescript\nexport const notebookLinkQueries = {\n  create: (link: DbNotebookLink) => db.run(`INSERT INTO notebook_links ...`),\n  getBySourceBlock: (blockId: string) => db.all(`SELECT * FROM notebook_links WHERE sourceBlockId = ?`, blockId),\n  getByTargetBlock: (blockId: string) => db.all(`SELECT * FROM notebook_links WHERE targetBlockId = ?`, blockId),\n  delete: (id: string) => db.run(`DELETE FROM notebook_links WHERE id = ?`, id),\n};\n```\n\nMIGRATION FILE: electron/database/migrations/v16.ts\n\nEDGE CASES:\n- ON DELETE CASCADE: When a notebook_block is deleted, delete all links referencing it\n- Self-links: Prevent sourceBlockId === targetBlockId at insert time\n- Duplicate links: UNIQUE constraint handles this, return existing link ID on conflict",
        "testStrategy": "Run migration, verify table created with correct schema. Test CRUD operations via IPC. Test unique constraint prevents duplicate links. Test cascade delete removes links when block deleted. Test indexes exist.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create v17 migration file with notebook_links table schema",
            "description": "Create electron/database/migrations/v17.ts with notebook_links table, indexes, and CASCADE deletion triggers",
            "dependencies": [],
            "details": "Create migration file following v15/v16 pattern. Use getDatabase() and transaction wrapper. Execute CREATE TABLE with: id, sourceBlockId, targetBlockId, linkType, reason, anchorText, anchorStart, anchorEnd, createdAt. Add UNIQUE(sourceBlockId, targetBlockId) constraint, FOREIGN KEY references with ON DELETE CASCADE for both sourceBlockId and targetBlockId. Create indexes: idx_notebook_links_source and idx_notebook_links_target. Add CHECK constraint to prevent self-links (sourceBlockId != targetBlockId). Call setSchemaVersion(17). Update migrations/index.ts to import and call migrateToV17.",
            "status": "pending",
            "testStrategy": "Run app and verify schema_version = 17, table exists with correct columns, indexes created, CASCADE deletion works when notebook_block deleted",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add DbNotebookLink and NotebookLinkRow types to database/types.ts",
            "description": "Define TypeScript interfaces for notebook links matching the schema from subtask 1",
            "dependencies": [
              1
            ],
            "details": "In electron/database/types.ts, add DbNotebookLink interface with linkType as union type 'same_concept' | 'related_topic' | 'cross_specialty' | 'comparison' | 'builds_on'. All fields match task description. Add NotebookLinkRow interface for internal DB row representation (same fields but reason, anchorText, anchorStart, anchorEnd are nullable using string | null). Export both interfaces. Follow pattern from DbNotebookBlock/NotebookBlockRow.",
            "status": "pending",
            "testStrategy": "TypeScript compilation succeeds, types properly exported and importable from database module",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create electron/database/notebook-links.ts query module",
            "description": "Implement database query functions for CRUD operations on notebook_links table",
            "dependencies": [
              2
            ],
            "details": "Create notebook-links.ts following pattern from notebook-blocks.ts. Export notebookLinkQueries object with methods: create(link: DbNotebookLink), getBySourceBlock(blockId: string): DbNotebookLink[], getByTargetBlock(blockId: string): DbNotebookLink[], delete(id: string), search(query: string, limit?: number) for finding blocks to link (searches notebook_blocks content). Use getDatabase().prepare() for all statements. For create, handle UNIQUE constraint conflict by returning existing link. Create parseNotebookLinkRow helper to convert NotebookLinkRow to DbNotebookLink. Import types from ./types.",
            "status": "pending",
            "testStrategy": "Unit test create/read/delete operations, verify UNIQUE constraint returns existing link, test getBySourceBlock and getByTargetBlock return correct links, test search finds blocks by content",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add IPC handlers for notebook links operations",
            "description": "Register IPC handlers in electron/ipc-handlers.ts for all notebook link operations",
            "dependencies": [
              3
            ],
            "details": "In electron/ipc-handlers.ts, import notebookLinkQueries and DbNotebookLink from ./database. Add handlers following existing pattern with success/failure wrappers: notebookLinks:create (takes DbNotebookLink), notebookLinks:getBySourceBlock (takes blockId string), notebookLinks:getByTargetBlock (takes blockId string), notebookLinks:delete (takes id string), notebookLinks:search (takes query string and optional limit number). All return IpcResult<T>. Follow pattern from cards:create and other handlers.",
            "status": "pending",
            "testStrategy": "Test each IPC handler returns proper IpcResult structure, error handling works, operations modify database correctly",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Wire up preload.ts and electron.d.ts for renderer access",
            "description": "Add notebook links API methods to preload bridge and TypeScript definitions",
            "dependencies": [
              4
            ],
            "details": "In electron/preload.ts, add notebookLinks object to api with methods: create(link: unknown), getBySourceBlock(blockId: string), getByTargetBlock(blockId: string), delete(id: string), search(query: string, limit?: number). Each invokes corresponding IPC channel. In src/types/electron.d.ts, add NotebookLinks interface with properly typed methods returning Promise<IpcResult<T>>. Add notebookLinks: NotebookLinks to ElectronAPI interface. Follow pattern from existing api.cards, api.notes sections.",
            "status": "pending",
            "testStrategy": "TypeScript compilation succeeds, window.api.notebookLinks accessible from renderer, all methods return properly typed IpcResult promises",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-16T18:35:19.227Z"
      },
      {
        "id": "127",
        "title": "Workflow 2 FIX: Prominent 'What did you learn?' Insight UI",
        "description": "Fix the critical learning gap in Add to Notebook workflow. The insight field (user's own words about what they learned) is the ENTIRE POINT of the notebook layer but is currently missing or de-emphasized.",
        "details": "WORKFLOW 2 FIX - THE LEARNING HAPPENS HERE:\n\nThis is where learning happens. The insight field is not optional metadata - it's the entire point. Users must articulate what they learned in their own words. Without this step, DougHub is just a content collector, not a learning tool.\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  ADD TO NOTEBOOK                                                    [X]     |\n|                                                                             |\n|  +-----------------------------------------------------------------------+  |\n|  | SOURCE PREVIEW (collapsed by default, expandable)                     |  |\n|  | \"CKD G3 - Leading Cause of Death\" (QBank - Correct)          [Expand] |  |\n|  +-----------------------------------------------------------------------+  |\n|                                                                             |\n|  Topic: [Chronic Kidney Disease v]     [+ Create New Topic]                |\n|                                                                             |\n|  =========================================================================  |\n|                                                                             |\n|   WHAT DID YOU LEARN?                                                      |\n|   Write it in your own words. This becomes your notebook entry.            |\n|                                                                             |\n|  +---------------------------------------------------------------------+   |\n|  |                                                                     |   |\n|  | CKD patients are 4-5x more likely to die of CVD than progress to   |   |\n|  | ESKD. Both CKD and albuminuria are independent CV risk factors.    |   |\n|  |                                                                     |   |\n|  | Key takeaway: Manage CV risk aggressively in CKD - statins, BP     |   |\n|  | control, smoking cessation. Don't just focus on slowing GFR        |   |\n|  | decline.                                                            |   |\n|  |                                                                     |   |\n|  +---------------------------------------------------------------------+   |\n|   Min 20 characters                                          [142 chars]   |\n|                                                                             |\n|  =========================================================================  |\n|                                                                             |\n|  Already in this topic:                                                    |\n|  - CKD Staging and GFR (your insight: \"G3a vs G3b distinction...\")        |\n|  - ACEi in CKD (your insight: \"Renoprotective independent of BP...\")      |\n|                                                                             |\n|  Tags: [Cardiology] [Management] [Cross-Topic]  [+ Add]                    |\n|                                                                             |\n|                    [ Save Draft ]              [ Save to Notebook ]        |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nDESIGN REQUIREMENTS:\n1. Insight field is PROMINENT - largest element, visually emphasized with border/background\n2. Source is collapsed by default - reference material, not the focus\n3. Minimum 20 character count ENFORCED - prevents empty/lazy entries\n4. Character count shown in real-time\n5. \"In your own words\" instruction - explicit to process, not copy\n6. Existing blocks show YOUR insights - reinforces learning focus\n7. Save Draft option for partial work\n8. CANNOT save with empty insight - button disabled until valid\n\nFLOW:\n1. User arrives from Quick Capture or Inbox\n2. Source preview collapsed (click to expand and review)\n3. AI suggests topic based on source tags/domain\n4. User selects topic OR creates new topic\n5. **THE KEY STEP**: User writes their insight - what they learned, in their own words\n6. Tags inherited from source, user can modify\n7. User clicks [Save to Notebook]\n\nDATABASE OPERATIONS:\n```typescript\n// On [Save to Notebook] - transaction\nasync function addToNotebook(sourceItem: DbSourceItem, topicId: string, userInsight: string) {\n  // 1. Get or create topic page\n  let page = await window.api.getNotebookTopicPageByTopic(topicId);\n  if (!page) {\n    page = await window.api.createNotebookTopicPage({\n      id: crypto.randomUUID(),\n      canonicalTopicId: topicId,\n      cardIds: [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    });\n  }\n\n  // 2. Get next position\n  const blocks = await window.api.getNotebookBlocksByPage(page.id);\n  const nextPosition = blocks.length;\n\n  // 3. Create block\n  await window.api.createNotebookBlock({\n    id: crypto.randomUUID(),\n    notebookTopicPageId: page.id,\n    sourceItemId: sourceItem.id,\n    content: userInsight,  // User's learning - the KEY field\n    position: nextPosition,\n    cardCount: 0,\n  });\n\n  // 4. Update source status\n  await window.api.updateSourceItemStatus(sourceItem.id, 'processed');\n}\n```\n\nEDGE CASES:\n\nTopic doesn't exist:\n- Show [+ Create New Topic] inline form\n- Minimal fields: name, domain\n- Create immediately, continue with block\n\nBlock already exists for this source in this topic:\n- Check: notebookBlockQueries.getBySourceAndPage(sourceId, pageId)\n- If found: \"You already have a block from this source in [Topic]\"\n- Options: [View Existing] | [Add Anyway] | [Choose Different Topic]\n\nNo source (direct entry creation):\n- Valid for clinical pearls entered directly\n- Create source_item with sourceType='manual' first, then link",
        "testStrategy": "Verify insight textarea is prominently displayed with visual emphasis. Test 20 char minimum enforced - save button disabled until met. Test character counter updates in real-time. Test source preview collapse/expand. Test existing blocks shown with insight snippets. Test Save Draft vs Save to Notebook. Test cannot save with empty insight. Test topic creation inline. Test duplicate block warning.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create collapsible source preview panel component",
            "description": "Build a collapsible panel to display source item details in a condensed format, collapsed by default with expand/collapse functionality.",
            "dependencies": [],
            "details": "Create a new component SourcePreviewPanel.tsx in src/components/notebook/ that accepts a SourceItem prop. Use Radix UI Collapsible component (already available at src/components/ui/collapsible.tsx). Display source title, type badge, and raw content preview when collapsed. Show full rawContent and metadata when expanded. Include ChevronDown/ChevronUp icon for visual affordance. Style with border and subtle background to distinguish from main content area.",
            "status": "done",
            "testStrategy": "Test panel renders collapsed by default. Test clicking trigger expands/collapses content. Test displays correct source title and type. Test shows full content when expanded. Test visual distinction from surrounding content.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T20:50:14.800Z"
          },
          {
            "id": 2,
            "title": "Build prominent insight textarea with validation and character counter",
            "description": "Create a large, visually prominent textarea for user insights with real-time character counting and 20-character minimum validation.",
            "dependencies": [],
            "details": "Build InsightTextarea component using shadcn Textarea (src/components/ui/textarea.tsx) with custom styling for visual prominence (larger min-height ~150px, distinct border/background using theme variables like border-primary or bg-accent). Add label 'WHAT DID YOU LEARN?' with subtitle 'Write it in your own words. This becomes your notebook entry.' Display real-time character count in bottom-right (e.g., '[142 chars]' or 'Min 20 characters' when under threshold). Implement onChange handler to track character count and validation state. Return validation state and value to parent component.",
            "status": "done",
            "testStrategy": "Test textarea renders with prominent styling. Test character counter updates in real-time as user types. Test shows 'Min 20 characters' when count < 20. Test shows actual count when >= 20. Test validation state correctly reflects 20-char minimum. Test uses theme color variables for themeable styling.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T20:50:14.810Z"
          },
          {
            "id": 3,
            "title": "Implement topic selector with inline create functionality",
            "description": "Build topic selection UI that suggests existing topics and allows inline creation of new topics without modal dialogs.",
            "dependencies": [],
            "details": "Create TopicSelector component using existing Combobox pattern from AddToNotebookDialog.tsx (lines 156-246) as reference. Use window.api.canonicalTopics.suggestMatches for search, with 300ms debounce. Display suggestions with canonical name and aliases. Show '+ Create New Topic' option when input doesn't match existing topics. On selection, return topic ID to parent. On create, call window.api.canonicalTopics.createOrGet with user input, return new topic ID. Include loading states for async operations. Style consistently with existing patterns.",
            "status": "done",
            "testStrategy": "Test search debounces properly (300ms). Test shows existing topic suggestions. Test shows aliases in suggestions. Test '+ Create New Topic' appears when no exact match. Test selecting existing topic returns correct ID. Test creating new topic calls API and returns new ID. Test loading states display during async operations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T20:50:14.816Z"
          },
          {
            "id": 4,
            "title": "Display existing blocks for selected topic with insight previews",
            "description": "Show a list of existing notebook blocks for the currently selected topic, displaying user insights to reinforce learning focus.",
            "dependencies": [
              3
            ],
            "details": "Create ExistingBlocksList component that accepts topicId prop. When topicId changes, fetch associated notebook topic page using window.api.notebookTopicPages.getByTopic, then fetch blocks using window.api.notebookBlocks.getByPage. Display blocks in a compact list showing insight content snippet (first 100 chars with ellipsis). Include source title reference for context. Show 'Already in this topic:' heading. Handle empty state ('No blocks yet in this topic'). Update list whenever topicId changes using useEffect.",
            "status": "done",
            "testStrategy": "Test fetches correct notebook page when topic selected. Test fetches blocks for that page. Test displays insight content snippets correctly. Test shows source title references. Test truncates long insights with ellipsis. Test shows empty state when no blocks exist. Test updates when topic selection changes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T20:50:14.823Z"
          },
          {
            "id": 5,
            "title": "Integrate all components with dual save buttons and database transaction",
            "description": "Replace AddToNotebookDialog with new redesigned workflow, implementing Save Draft and Save to Notebook buttons with proper database operations.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create new component AddToNotebookWorkflow.tsx that integrates SourcePreviewPanel, InsightTextarea, TopicSelector, and ExistingBlocksList. Accept sourceItem and open/onOpenChange props like current dialog. Implement two buttons: 'Save Draft' (saves source with status='processed') and 'Save to Notebook' (creates block with full transaction). Save to Notebook validates insight length, gets/creates notebook page, fetches existing blocks for position, creates block with window.api.notebookBlocks.create, updates source status to 'curated'. Include duplicate detection using notebookBlockQueries.getBySourceId (check if source already has blocks). Show confirmation dialog if duplicate found with options: View Existing, Add Anyway, Choose Different Topic. Disable Save to Notebook button until insight >= 20 chars and topic selected. Replace AddToNotebookDialog imports in InboxView.tsx and SourceItemRow.tsx with new component.\n<info added on 2026-01-16T20:50:09.170Z>\nI'll analyze the codebase to understand what was implemented and provide an accurate update for this subtask.Successfully verified implementation: AddToNotebookWorkflow.tsx created with all specified components (SourcePreviewPanel, InsightTextarea, TopicSelector, ExistingBlocksList). Save Draft and Save to Notebook buttons implemented with proper validation (20 char min, topic required). Duplicate detection via getBySourceId checks same-topic blocks and shows AlertDialog with Cancel/Add Anyway options. Full transaction flow: get/create page, fetch position, create block, update source status to 'curated'. InboxView.tsx imports AddToNotebookWorkflow (line 25). Confirmed removal of batchAddToNotebook from useAppStore.ts (grep shows no references in source files, only in tasks.json and DEFERRED.md). BatchActions.tsx props reduced to selectedCount, onDelete, onClearSelection (no onAddToNotebook). All lint checks verified clean.\n</info added on 2026-01-16T20:50:09.170Z>",
            "status": "done",
            "testStrategy": "Test Save to Notebook button disabled when insight < 20 chars. Test button disabled when no topic selected. Test button enabled when both conditions met. Test Save Draft updates source status to 'processed'. Test Save to Notebook creates block with correct fields. Test transaction creates/gets page correctly. Test position calculated from existing blocks. Test source status updated to 'curated'. Test duplicate detection shows confirmation dialog. Test dialog options (View/Add Anyway/Choose Different) work correctly. Test component integrates properly in InboxView and SourceItemRow.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T20:50:14.830Z"
          }
        ],
        "updatedAt": "2026-01-16T20:50:14.830Z"
      },
      {
        "id": "128",
        "title": "Workflow 1: Quick Capture Completion",
        "description": "Complete the Quick Capture workflow with AI analysis for auto-tagging, duplicate detection, and the 'Add to Notebook Now' direct path.",
        "details": "WORKFLOW 1: QUICK CAPTURE COMPLETION\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  CAPTURE                                                            [X]     |\n|                                                                             |\n|  +---------------------------------------------------------------------+   |\n|  | [Paste or type content here...]                                     |   |\n|  |                                                                     |   |\n|  |                                                                     |   |\n|  +---------------------------------------------------------------------+   |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  Title: [CKD G3 - Leading Cause of Death              ] [pencil]           |\n|                                                                             |\n|  Type:  [QBank v]     Result: (*) Correct  ( ) Incorrect                   |\n|                                                                             |\n|  Domain: [Nephrology v]                                                    |\n|                                                                             |\n|  Tags: [Cardiology] [Management] [Cross-Topic]  [+ Add]                    |\n|                                                                             |\n|  ! Similar item exists: \"CKD G3 - CV Risk\" [View]                          |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|           [ Save to Inbox ]              [ Add to Notebook Now -> ]        |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nFLOW:\n1. User opens capture (Ctrl+Shift+C or FAB button)\n2. User pastes content\n3. AI analyzes content (see AI Prompt below)\n4. Form auto-fills with AI suggestions\n5. Check for duplicates (search source_items by title similarity)\n6. User confirms/edits fields\n7. User clicks:\n   - [Save to Inbox] -> INSERT source_items, status='inbox', done\n   - [Add to Notebook Now ->] -> Go to Workflow 2 with this source\n\nAI PROMPT - CAPTURE ANALYSIS:\n```\nSYSTEM: Analyze medical content for tagging and organization.\n\nINPUT:\n{raw_content}\n\nOUTPUT JSON:\n{\n  \"title\": \"Short title (<10 words)\",\n  \"sourceType\": \"qbank|article|pdf|image|quickcapture|manual\",\n  \"domain\": \"Nephrology\",\n  \"secondaryDomains\": [\"Cardiology\"],\n  \"tags\": [\"Management\", \"Boards-HY\"],\n  \"extractedFacts\": [\"CKD 4-5x more likely CVD death than ESKD\", \"...\"],\n  \"suggestedTopic\": \"Chronic Kidney Disease\"\n}\n\nDETECTION RULES:\n- Contains \"A) B) C) D)\" AND \"Explanation\" -> sourceType = \"qbank\"\n- URL from UpToDate, PubMed -> sourceType = \"article\"\n- User-written, no citations -> sourceType = \"manual\"\n- Otherwise -> sourceType = \"quickcapture\"\n```\n\nDATABASE OPERATIONS:\n```typescript\n// On [Save to Inbox] - uses sourceItemQueries.create()\nawait window.api.createSourceItem({\n  id: crypto.randomUUID(),\n  sourceType: aiResult.sourceType,\n  sourceName: 'Quick Capture',\n  title: aiResult.title,\n  rawContent: content,\n  canonicalTopicIds: [],\n  tags: [...aiResult.secondaryDomains, ...aiResult.tags],\n  metadata: {\n    summary: aiResult.extractedFacts?.join('; '),\n    subject: aiResult.domain\n  },\n  status: 'inbox',\n  createdAt: new Date().toISOString(),\n});\n```\n\nDUPLICATE DETECTION:\n- After AI analysis or manual title entry, search: sourceItemQueries.search(title_keywords)\n- If similar found (fuzzy match on title), show warning banner\n- \"Similar item exists: [Title]\" with [View] button\n- User can still save (might be different angle on same topic)\n\nEDGE CASES:\n\nAI fails or times out:\n- Show form with defaults: sourceType='quickcapture', title=first 50 chars, domain='General', tags=[]\n- Never block capture. User can fill manually.\n- Show subtle warning: \"AI analysis unavailable. Please fill fields manually.\"\n\nDuplicate detected:\n- Search: sourceItemQueries.search(keywords)\n- If found, show warning with [View Existing] option\n- User can still save (might be different angle on same topic)\n\nImage/PDF pasted:\n- Store base64 in tempImageData, sourceType='image' or 'pdf'\n- AI cannot analyze -> manual tagging required\n- Show: \"Image captured. Please add title and tags.\"\n\n[Add to Notebook Now] BUTTON:\n- Saves source item first (status='inbox')\n- Then navigates to AddToNotebook modal with sourceItem pre-loaded\n- Enables single-step capture-to-notebook flow",
        "testStrategy": "Test AI analysis populates form fields correctly. Test AI timeout/failure shows defaults and warning. Test duplicate detection shows warning with View button. Test Save to Inbox creates source_item with correct fields. Test Add to Notebook Now saves then navigates to Workflow 2. Test image/PDF paste shows manual entry prompt. Test Correct/Incorrect toggle for qbank items.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement AI Analysis Service for Quick Capture",
            "description": "Create AI analysis endpoint in ai-service.ts to auto-tag quick capture content with sourceType, domain, tags, and extracted facts",
            "dependencies": [],
            "details": "Add new function analyzeCaptureContent() to electron/ai-service.ts that accepts raw content and returns structured JSON with: title (short, <10 words), sourceType (qbank|article|pdf|image|quickcapture|manual), domain (medical specialty), secondaryDomains array, tags array (Management, Boards-HY, etc.), extractedFacts array, suggestedTopic. Use prompt template with detection rules: contains 'A) B) C) D)' AND 'Explanation' -> qbank; URL from UpToDate/PubMed -> article; user-written without citations -> manual; otherwise -> quickcapture. Implement content hashing for AI result cache (TTL 5 min) to avoid redundant API calls. Handle timeout/failure gracefully with null return.",
            "status": "pending",
            "testStrategy": "Test with qbank question content returns sourceType='qbank' with correct domain/tags. Test with plain text returns sourceType='quickcapture'. Test with article URL returns sourceType='article'. Test cache hit returns instantly. Test AI timeout returns null without throwing. Test extracted facts array populated for medical content.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add AI Analysis Integration to QuickCaptureModal Component",
            "description": "Integrate AI analysis call into QuickCaptureModal.tsx to auto-populate form fields after content paste with loading state and fallback handling",
            "dependencies": [
              1
            ],
            "details": "In src/components/modals/QuickCaptureModal.tsx, add state for aiAnalysisResult, isAnalyzing, and aiError. Create useEffect hook that triggers 500ms after content change (debounced). Call window.api.ai.analyzeCaptureContent(content) and populate: title, detectedType from aiResult.sourceType, suggested domain (display as Badge), suggested tags (display as removable Badges with [x] button). Add loading spinner badge during analysis. On timeout/failure, show subtle warning banner: 'AI analysis unavailable. Please fill fields manually.' and allow user to proceed with defaults (sourceType='quickcapture', title=first 50 chars, domain='General', tags=[]). Never block capture. Add Domain dropdown (Select) and Tags multi-select (Combobox) below title input, pre-filled from AI but user-editable.",
            "status": "pending",
            "testStrategy": "Test content paste triggers AI analysis after 500ms debounce. Test loading spinner shows during analysis. Test form fields auto-populate from AI response. Test AI failure shows warning but allows manual entry. Test domain dropdown shows AI-suggested domain pre-selected. Test tags are displayed as removable badges. Test clearing content clears AI suggestions. Test image content skips AI analysis.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Duplicate Detection via Title Search",
            "description": "Add duplicate detection in QuickCaptureModal that searches existing source_items by title similarity and shows warning banner with View button",
            "dependencies": [
              2
            ],
            "details": "In QuickCaptureModal.tsx, add useEffect hook that triggers 600ms after title changes (debounced, longer than AI). Extract keywords from title (split by whitespace, remove stop words like 'the', 'a', 'of'). Call window.api.sourceItems.search(titleKeywords) using existing searchQueries.search() with filter='inbox'. If results found with similarity score >0.7 (use simple Levenshtein or token overlap), set duplicateWarning state. Show warning banner (Alert component with variant='warning') below form: 'Similar item exists: [First matching title]' with [View Existing] button. Button opens SourceItemViewerDialog with matching item. User can still save (might be different angle). Add IPC handler 'source-items:search' in ipc-handlers.ts that wraps searchQueries.search() and returns IpcResult.",
            "status": "pending",
            "testStrategy": "Test title entry triggers search after 600ms. Test exact title match shows duplicate warning. Test similar title (80% match) shows warning. Test dissimilar title shows no warning. Test View Existing button opens correct source item. Test warning doesn't block save action. Test search returns within <200ms. Test no results shows no warning. Test multiple similar items shows first match only.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Complete Save to Inbox Path with AI-Enhanced Metadata",
            "description": "Update handleSave() in QuickCaptureModal to save source_item with AI-analyzed fields including domain, tags, and metadata summary",
            "dependencies": [
              2,
              3
            ],
            "details": "In QuickCaptureModal.tsx handleSave(), construct sourceItem object using: id from crypto.randomUUID(), sourceType from aiAnalysisResult?.sourceType || sourceMap[detectedType], sourceName='Quick Capture', title from title input (user-editable, fallback to AI suggestion), rawContent from content textarea, canonicalTopicIds=[] (empty, curated later), tags from user-selected tags (merge AI suggestions + user additions), questionId undefined (not qbank yet), metadata object with summary from aiAnalysisResult?.extractedFacts.join('; ') and subject from aiAnalysisResult?.domain, status='inbox', createdAt/updatedAt timestamps. Call window.api.sourceItems.create(sourceItem). On success, refresh counts via useAppStore.refreshCounts(), show toast 'Saved to inbox - Process when you're rested', reset form state, close modal.",
            "status": "pending",
            "testStrategy": "Test Save to Inbox creates source_item with correct fields. Test AI-suggested domain stored in metadata.subject. Test AI-suggested tags saved to tags array. Test extractedFacts joined into metadata.summary. Test manual title overrides AI suggestion. Test status='inbox' set correctly. Test createdAt timestamp is ISO string. Test counts refresh after save. Test toast notification shows. Test modal closes and form resets. Test save works even without AI analysis (uses defaults).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Add to Notebook Now Navigation Path",
            "description": "Add 'Add to Notebook Now' button that saves source_item to inbox then navigates to AddToNotebookDialog with pre-loaded item for immediate processing",
            "dependencies": [
              4
            ],
            "details": "In QuickCaptureModal.tsx DialogFooter, add new Button with variant='default', icon=<PlayCircle>, text='Add to Notebook Now ->' positioned after 'Save to Inbox'. Replace existing disabled 'Process Now' button. On click, call handleAddToNotebookNow() which: 1) Saves source_item using same logic as handleSave() (extract to shared function saveCaptureItem()), 2) On successful save, call useAppStore.setSelectedSourceItems([savedItem.id]), 3) Call useAppStore.openAddToNotebookDialog(), 4) Close QuickCaptureModal via onClose(). Update AddToNotebookDialog.tsx to check useAppStore.selectedSourceItems on open and pre-populate if items exist. This enables single-step capture-to-notebook flow. Button disabled if content empty or AI analysis still running.",
            "status": "pending",
            "testStrategy": "Test Add to Notebook Now button visible and enabled after content entry. Test button disabled while AI analyzing. Test click saves source_item to database with status='inbox'. Test AddToNotebookDialog opens after save completes. Test AddToNotebookDialog pre-populates with saved item. Test QuickCaptureModal closes after navigation. Test error during save shows toast and doesn't navigate. Test single-step flow from capture to notebook. Test button tooltip explains workflow.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "129",
        "title": "Workflow 4: Browse Inbox - Archive Status and Polish",
        "description": "Complete the Browse Inbox workflow by fixing Archive to use status change instead of delete, and adding minor polish.",
        "details": "WORKFLOW 4: BROWSE INBOX COMPLETION\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  INBOX (23 items)                                                          |\n|                                                                             |\n|  [Search...]                    [Sort: Newest v]  [Filter: All Types v]    |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  [ ] CKD G3 - CV Mortality                [Nephro] QBank check   2 hrs ago |\n|  [ ] Afib Rate Control vs Rhythm          [Cardio] QBank x       3 hrs ago |\n|  [ ] COPD Exacerbation Management         [Pulm]   QBank check   Yesterday |\n|  [ ] Diabetic Ketoacidosis Workup         [Endo]   QBank x       Yesterday |\n|  [ ] UpToDate: Heart Failure Guidelines   [Cardio] Article       2 days    |\n|  ...                                                                        |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  With selected: [Add to Notebook] [Archive] [Delete]                       |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nCURRENT STATE:\n- List view works\n- Search works\n- Delete works\n\nMISSING/BROKEN:\n1. Archive uses DELETE instead of status='curated'\n2. Filter by sourceType not implemented\n3. Sort options not implemented\n4. Batch selection not implemented\n\nFLOW:\n1. User opens Inbox from sidebar\n2. Load items: sourceItemQueries.getByStatus('inbox')\n3. User can:\n   - Click item -> View source detail modal\n   - Select + [Add to Notebook] -> Workflow 2\n   - Select + [Archive] -> status = 'curated' (NOT delete)\n   - Select + [Delete] -> DELETE with confirmation\n4. Filters: by sourceType, domain (from metadata.subject)\n5. Sort: by createdAt (newest/oldest)\n\nDATABASE OPERATIONS:\n```typescript\n// List inbox\nconst items = await window.api.getSourceItemsByStatus('inbox');\n\n// Archive (mark as curated) - FIX THIS\nawait window.api.updateSourceItemStatus(id, 'curated');\n\n// Delete\nawait window.api.deleteSourceItem(id);\n```\n\nFILTERS TO ADD:\n- sourceType: qbank, article, pdf, image, quickcapture, manual, all\n- domain: from metadata.subject field, dynamically populated\n\nSORT OPTIONS:\n- Newest first (default)\n- Oldest first\n- By domain (alphabetical)\n- By type\n\nBATCH OPERATIONS:\n- Checkbox selection on each row\n- \"Select All\" checkbox in header\n- Batch actions: Add to Notebook (opens for first selected), Archive, Delete\n- Archive batch: no confirmation needed\n- Delete batch: \"Delete X items? This cannot be undone.\"\n\nEDGE CASES:\n\nEmpty inbox:\n- Show: \"Inbox empty! Capture some content to get started.\" [Capture]\n\nBatch actions on many items:\n- Archive: Update all, no confirmation needed\n- Delete: Confirm \"Delete X items? This cannot be undone.\"",
        "testStrategy": "Test Archive changes status to 'curated' not delete. Test archived items no longer appear in inbox. Test filter by sourceType works. Test sort by newest/oldest works. Test batch selection with Select All. Test batch archive updates all without confirmation. Test batch delete shows confirmation. Test empty inbox shows capture prompt.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "130",
        "title": "Workflow 5: Browse Notebook - Filters and Cross-Block Search",
        "description": "Complete the Browse Notebook workflow with filters (Cross-Topic, Boards-HY, No Cards) and cross-block content search.",
        "details": "WORKFLOW 5: BROWSE NOTEBOOK COMPLETION\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  NOTEBOOK                                                [Search...]       |\n|                                                                             |\n|  +--------------+ +----------------------------------------------------+   |\n|  | DOMAINS      | |  Chronic Kidney Disease                   12 blocks|   |\n|  |              | |                                                    |   |\n|  | v Nephrology | |  +----------------------------------------------+ |   |\n|  |   - CKD (12) | |  | CKD - CV Mortality Risk            2hrs ago  | |   |\n|  |   - AKI (5)  | |  | [Cardio] [Mgmt] [Cross-Topic]                | |   |\n|  |   - GN (3)   | |  | \"CKD patients 4-5x more likely to die...\"    | |   |\n|  |              | |  | Links: 3  Source: 1  Cards: 0                | |   |\n|  | > Cardiology | |  +----------------------------------------------+ |   |\n|  | > Pulmonology| |                                                    |   |\n|  | > GI         | |  +----------------------------------------------+ |   |\n|  | > Endocrine  | |  | CKD Staging and GFR                2 days ago| |   |\n|  | ...          | |  | [Dx] [Boards-HY]                             | |   |\n|  |              | |  | \"Stage G3a: 45-59, G3b: 30-44...\"            | |   |\n|  | ------------ | |  | Links: 2  Source: 2  Cards: 1                | |   |\n|  | FILTERS:     | |  +----------------------------------------------+ |   |\n|  | [ ] Cross-Top| |                                                    |   |\n|  | [ ] Boards-HY| |  [+ Add Block]                                    |   |\n|  | [ ] No Cards | |                                                    |   |\n|  +--------------+ +----------------------------------------------------+   |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nCURRENT STATE:\n- Domain tree sidebar works\n- Topic selection works\n- Block list works\n\nMISSING:\n1. Cross-block search (search all blocks by content)\n2. Filters in sidebar: Cross-Topic, Boards-HY, No Cards\n3. Block counts in domain tree\n\nFLOW:\n1. User opens Notebook from sidebar\n2. Left sidebar: domains with nested topics\n   - Expand domain -> show topics with block counts\n3. Click topic -> load blocks for that topic's page\n4. Click block card -> Workflow 6 (Block Detail)\n5. Filters affect block list\n6. Search searches across ALL blocks (content field)\n\nDATABASE QUERIES:\n```typescript\n// Get domain tree with counts\nconst topics = await window.api.getAllCanonicalTopics();\n// Group by domain, count blocks per topic\n\n// Get blocks for topic\nconst page = await window.api.getNotebookTopicPageByTopic(topicId);\nconst blocks = await window.api.getNotebookBlocksByPage(page.id);\n\n// For each block, fetch source info\nfor (const block of blocks) {\n  block.source = await window.api.getSourceItem(block.sourceItemId);\n}\n\n// NEW: Search all blocks by content\nconst searchResults = await window.api.searchNotebookBlocks(query);\n// Returns blocks with topic name, content excerpt, match highlights\n```\n\nFILTERS (sidebar checkboxes):\n\n[ ] Cross-Topic:\n- Show only blocks where source has multiple canonicalTopicIds\n- OR blocks tagged with 'Cross-Topic'\n\n[ ] Boards-HY:\n- Show only blocks tagged with 'Boards-HY' or 'High-Yield'\n\n[ ] No Cards:\n- Show only blocks where cardCount = 0\n- Helps identify content not yet converted to cards\n\nSEARCH:\n- Search box in header searches ALL notebook blocks\n- Searches block.content field\n- Returns results grouped by topic\n- Click result -> navigate to that topic and highlight block\n\nIPC TO ADD:\n```typescript\n// Search notebook blocks by content\nwindow.api.searchNotebookBlocks(query: string): Promise<Array<{\n  block: DbNotebookBlock;\n  topicName: string;\n  excerpt: string;  // Content snippet with match\n}>>\n```\n\nUI UPDATES:\n- Add search input in notebook header\n- Add filter checkboxes in sidebar below domain tree\n- Add block count badges next to each topic in tree\n- Search results appear in main area, replacing topic view temporarily",
        "testStrategy": "Test cross-block search finds blocks by content. Test search results show topic name and excerpt. Test clicking search result navigates to topic. Test Cross-Topic filter shows multi-topic blocks. Test Boards-HY filter shows tagged blocks. Test No Cards filter shows blocks with cardCount=0. Test block counts appear in domain tree. Test filters can be combined.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "131",
        "title": "Workflow 7: Edit Block",
        "description": "Implement the Edit Block workflow to allow users to refine their insights over time, with stale card warnings.",
        "details": "WORKFLOW 7: EDIT BLOCK\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  <- Back                                              [Cancel] [Save]       |\n|                                                                             |\n|  EDITING: CKD - CV Mortality Risk                                          |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  Content (your insight):                                                   |\n|  +---------------------------------------------------------------------+   |\n|  | CKD patients are 4-5x more likely to die of CVD than progress to   |   |\n|  | ESKD. Both CKD and albuminuria are independent CV risk factors.    |   |\n|  | Key management: treat CV risk factors (statins, BP control).       |   |\n|  |                                                                     |   |\n|  | UPDATE: Also important to control phosphorus in later stages.      |   |\n|  +---------------------------------------------------------------------+   |\n|                                                                             |\n|  ! This block has 2 cards. Editing may make them stale.                    |\n|     [View Cards]                                                           |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nFLOW:\n1. User clicks [Edit] on block detail view\n2. Content field becomes editable textarea\n3. User modifies content (their insight)\n4. If block has cards (cardCount > 0), show warning banner\n5. User clicks [Save]\n6. Update block content in database\n7. Return to block detail view\n\nVALIDATION:\n- Same 20 character minimum as Workflow 2\n- Cannot save empty content\n- Show character count\n\nDATABASE OPERATIONS:\n```typescript\n// Update block content\nawait window.api.updateNotebookBlock(blockId, {\n  content: newContent,\n});\n```\n\nIPC TO ADD (if not exists):\n```typescript\n// electron.d.ts\nupdateNotebookBlock(blockId: string, updates: Partial<DbNotebookBlock>): Promise<void>;\n```\n\nSTALE CARD WARNING:\n- Check block.cardCount before rendering\n- If cardCount > 0:\n  - Show yellow warning banner: \"This block has X cards. Editing may make them stale.\"\n  - Include [View Cards] button to see affected cards\n  - Cards are NOT auto-updated (user decides if regeneration needed)\n\nFUTURE ENHANCEMENT (not in this task):\n- Re-run backlink detection if content changed significantly\n- Track content history for undo\n\nEDGE CASES:\n\nNo changes made:\n- [Save] with identical content -> no database update, just close\n\nUnsaved changes + navigate away:\n- Show confirmation: \"Discard unsaved changes?\" [Discard] [Keep Editing]\n\nBlock deleted while editing:\n- Rare race condition\n- Show error: \"This block no longer exists.\" [Close]",
        "testStrategy": "Test edit mode opens with current content. Test 20 char minimum enforced. Test stale card warning shows when cardCount > 0. Test View Cards button navigates to affected cards. Test Save updates database. Test Cancel discards changes. Test no-change save doesn't write to DB. Test unsaved changes confirmation on navigate away.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "132",
        "title": "Workflow 8: Add Source to Another Topic",
        "description": "Implement cross-topic knowledge workflow: same source can create blocks in multiple topics with different insights per topic.",
        "details": "WORKFLOW 8: ADD SOURCE TO ANOTHER TOPIC\n\nThis is the KEY workflow for cross-topic knowledge. When a source touches multiple domains (e.g., \"CKD causes CVD\"), the user should add it to both Nephrology AND Cardiology.\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  ADD TO ANOTHER TOPIC                                               [X]     |\n|                                                                             |\n|  Source: \"CKD G3 - Leading Cause of Death\" (QBank)                         |\n|                                                                             |\n|  Already in:                                                                |\n|  - Chronic Kidney Disease (Nephrology) - \"CKD patients are 4-5x...\"        |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  Add to: [Cardiovascular Disease v]     [+ Create New Topic]               |\n|                                                                             |\n|  What's the Cardiology angle? (write a different insight)                  |\n|  +---------------------------------------------------------------------+   |\n|  | CV disease is the leading cause of death in CKD patients, NOT       |   |\n|  | progression to dialysis. Statins and BP control are essential.      |   |\n|  | Consider CKD as a coronary risk equivalent.                         |   |\n|  +---------------------------------------------------------------------+   |\n|                                                                             |\n|  [ ] Link these blocks (show connection in both topics)                    |\n|                                                                             |\n|                                              [ Add to Topic ]              |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nFLOW:\n1. User clicks [+ Add to Another Topic] on:\n   - Source item in Knowledge Bank\n   - Existing block in Notebook (shows \"Already in: X\")\n\n2. Show source info and existing blocks from this source\n\n3. User selects different topic (same topic disabled/hidden)\n\n4. User writes NEW insight for this topic's perspective\n   - Nephrology angle: \"CKD patients die of CVD, manage CV risk\"\n   - Cardiology angle: \"CKD is a coronary risk equivalent, screen for it\"\n   - Minimum 20 characters enforced\n\n5. Optional: Check \"Link these blocks\" to create notebook_link with type='cross_specialty'\n\n6. Creates new block in new topic, same sourceItemId\n\nDATABASE OPERATIONS:\n```typescript\nasync function addSourceToAnotherTopic(\n  sourceItem: DbSourceItem,\n  newTopicId: string,\n  newInsight: string,\n  linkToExisting: boolean,\n  existingBlockId?: string\n) {\n  // 1. Get or create topic page\n  let page = await window.api.getNotebookTopicPageByTopic(newTopicId);\n  if (!page) {\n    page = await window.api.createNotebookTopicPage({\n      id: crypto.randomUUID(),\n      canonicalTopicId: newTopicId,\n      cardIds: [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    });\n  }\n\n  // 2. Get next position\n  const blocks = await window.api.getNotebookBlocksByPage(page.id);\n  const nextPosition = blocks.length;\n\n  // 3. Create new block (same source, different topic, different insight)\n  const newBlockId = crypto.randomUUID();\n  await window.api.createNotebookBlock({\n    id: newBlockId,\n    notebookTopicPageId: page.id,\n    sourceItemId: sourceItem.id,  // SAME source\n    content: newInsight,           // DIFFERENT insight\n    position: nextPosition,\n    cardCount: 0,\n  });\n\n  // 4. Optionally create link between blocks\n  if (linkToExisting && existingBlockId) {\n    await window.api.createNotebookLink({\n      id: crypto.randomUUID(),\n      sourceBlockId: existingBlockId,\n      targetBlockId: newBlockId,\n      linkType: 'cross_specialty',\n      reason: 'Same source, different topic perspective',\n      createdAt: new Date().toISOString(),\n    });\n  }\n\n  // 5. Update source status if still inbox\n  if (sourceItem.status === 'inbox') {\n    await window.api.updateSourceItemStatus(sourceItem.id, 'processed');\n  }\n}\n```\n\nIPC TO ADD:\n```typescript\n// Get all blocks for a source item (to show \"Already in:\")\nwindow.api.getNotebookBlocksBySource(sourceId: string): Promise<Array<{\n  block: DbNotebookBlock;\n  topicName: string;\n}>>\n```\n\nEDGE CASES:\n\nBlock already exists in target topic:\n- Check: notebookBlockQueries.getBySourceAndPage(sourceId, pageId)\n- If found: \"You already have this source in [Topic]. View it?\"\n- Options: [View Existing] | [Create Anyway] | [Choose Different Topic]\n\nUser wants to copy insight instead of writing new:\n- Offer [Copy from existing] button next to textarea\n- Pre-fills textarea with existing insight, user can modify\n\nNo existing blocks (source from inbox):\n- Hide \"Already in:\" section\n- Hide \"Link these blocks\" checkbox (no block to link to)\n\nTopic dropdown excludes already-used topics:\n- Filter out topics where this source already has a block",
        "testStrategy": "Test modal shows source info and existing blocks. Test topic dropdown excludes already-used topics. Test NEW insight required (20 char min). Test Copy from existing pre-fills textarea. Test creates block with same sourceItemId but different topicPageId. Test Link checkbox creates notebook_link. Test duplicate block warning when target topic already has this source. Test source status updated to processed if was inbox.",
        "priority": "high",
        "dependencies": [
          "126"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add IPC handler for getNotebookBlocksBySource",
            "description": "Create database query and IPC handler to fetch all notebook blocks associated with a source item, including topic page information for display in the 'Already in:' section.",
            "dependencies": [],
            "details": "Add query to notebook-blocks.ts: getBySourceId returning array of blocks with joined topic info. Add IPC handler in ipc-handlers.ts. Add method to electron.d.ts: notebookBlocks.getBySource(sourceId: string) => Promise<IpcResult<Array<{ block: NotebookBlock; topicName: string; pageId: string }>>>. Use JOIN with notebook_topic_pages and canonical_topics tables to get topic names.",
            "status": "pending",
            "testStrategy": "Test query returns all blocks for a source across multiple topics. Test includes topic names and pageIds. Test empty array when source has no blocks. Test SQL JOIN correctly retrieves canonical topic names.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create AddSourceToTopicModal component structure",
            "description": "Build React modal component with Dialog, source info display, 'Already in:' list, topic selector dropdown, insight textarea, and link checkbox matching the mockup design.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/notebook/AddSourceToTopicModal.tsx using shadcn Dialog, Popover, Command, Textarea, Checkbox. Display source title and type at top. Conditionally render 'Already in:' section showing existing blocks with topic names (only if blocks exist). Include topic selector using Command/Popover pattern from AddToNotebookDialog.tsx. Add textarea for new insight (min 20 chars). Add 'Link these blocks' checkbox that only shows when existing blocks present. Style with theme variables.",
            "status": "pending",
            "testStrategy": "Test modal renders with source info. Test 'Already in:' section shows/hides based on existing blocks. Test topic dropdown populated from API. Test textarea validation (20 char min). Test checkbox visibility based on existing blocks. Test theme colors used correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement topic filtering to exclude already-used topics",
            "description": "Filter topic suggestions dropdown to exclude topics where the source already has blocks, preventing duplicate blocks in same topic.",
            "dependencies": [
              1,
              2
            ],
            "details": "In AddSourceToTopicModal, fetch existing blocks via notebookBlocks.getBySource(sourceId). Extract used pageIds and topicIds. When calling canonicalTopics.suggestMatches(), filter results to exclude topics already containing this source. Show helpful message if user tries selecting used topic. Consider edge case: source in inbox with no existing blocks (show all topics).",
            "status": "pending",
            "testStrategy": "Test topic dropdown excludes topics with existing blocks. Test all topics shown for inbox sources with no blocks. Test filter updates when blocks added. Test edge case: source has blocks in all topics. Test suggestion API called with correct parameters.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add 'Copy from existing' button for insight textarea",
            "description": "Implement button to pre-fill insight textarea with content from existing blocks, allowing users to modify instead of rewriting from scratch.",
            "dependencies": [
              2
            ],
            "details": "Add 'Copy from existing' button next to textarea label. On click, show dropdown/popover listing existing blocks with truncated content preview and topic names. When user selects a block, copy its content to textarea (allowing edits). Use Command component for searchable list if multiple blocks exist. Button only visible when existing blocks present.",
            "status": "pending",
            "testStrategy": "Test button appears only when existing blocks present. Test dropdown shows all existing blocks with topic context. Test selecting block copies content to textarea. Test textarea remains editable after copy. Test works with single and multiple existing blocks.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement addSourceToAnotherTopic database operation and IPC",
            "description": "Create database transaction to add block to new topic, optionally create cross_specialty notebook link, update source status, and wire up IPC handler.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add IPC handler: notebookBlocks.addToAnotherTopic(sourceId, topicId, insight, linkToBlockId?) in ipc-handlers.ts. Use database transaction: 1) Get/create topic page via notebookTopicPageQueries, 2) Get next position from existing blocks, 3) Create new block with same sourceItemId but different pageId and content, 4) If linkToBlockId provided, create notebook_link record (requires notebook_links table from T126), 5) Update source status from 'inbox' to 'processed' if needed. Return created block. Add to electron.d.ts.",
            "status": "pending",
            "testStrategy": "Test creates block in correct topic page. Test position calculated correctly. Test same sourceItemId preserved. Test link created when requested (depends on T126). Test source status updated from inbox to processed. Test transaction rollback on error. Test duplicate detection: block already exists in target topic.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "133",
        "title": "Workflow 9: Add Manual Link",
        "description": "Create explicit connections between blocks across topics with search, link type selection, and optional anchor text.",
        "details": "WORKFLOW 9: ADD MANUAL LINK\n\nCreate explicit connections between blocks across topics.\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  + ADD LINK                                                         [X]     |\n|                                                                             |\n|  Linking from: \"CKD - CV Mortality Risk\" (Nephrology)                      |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  Search blocks: [statin                    ]                               |\n|                                                                             |\n|  +------------------------------------------------------------------------+ |\n|  | (*) Statin Therapy - When to Start                        [Cardio]    | |\n|  |     \"High-intensity statins for all diabetics...\"                     | |\n|  |                                                                        | |\n|  | ( ) Statin Side Effects                                   [Pharm]     | |\n|  |     \"Myopathy risk factors include...\"                                | |\n|  |                                                                        | |\n|  | ( ) CKD and Dyslipidemia                                  [Nephro]    | |\n|  |     \"LDL targets in CKD differ from general population...\"            | |\n|  +------------------------------------------------------------------------+ |\n|                                                                             |\n|  Link type: [Related Topic v]                                              |\n|                                                                             |\n|  Optional anchor text (highlight in your block):                           |\n|  Selected: \"statins\"                                                       |\n|                                                                             |\n|                                                        [Create Link]       |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nFLOW:\n1. User clicks [+ Add Link] in block detail sidebar\n2. Search modal opens with source block info shown\n3. User searches by keyword, filters by topic/domain\n4. User selects target block (radio button)\n5. User selects link type from dropdown:\n   - same_concept: Same idea, different words\n   - related_topic: Connected but distinct concepts\n   - cross_specialty: Same content, different specialty perspective\n   - comparison: Compare/contrast these concepts\n   - builds_on: This block extends/depends on that one\n6. Optional: User highlights text in current block for anchor\n   - Show current block content with text selection enabled\n   - Selected text becomes anchorText\n7. Creates notebook_link record\n\nDATABASE OPERATIONS:\n```typescript\n// Search for blocks\nconst results = await window.api.searchNotebookBlocks(searchTerm);\n// Returns blocks with topic name, excerpt\n\n// Create link\nawait window.api.createNotebookLink({\n  id: crypto.randomUUID(),\n  sourceBlockId: currentBlockId,\n  targetBlockId: selectedBlockId,\n  linkType: selectedLinkType,\n  reason: 'Manual link',\n  anchorText: selectedText || null,\n  anchorStart: selectionStart || null,\n  anchorEnd: selectionEnd || null,\n  createdAt: new Date().toISOString(),\n});\n```\n\nSEARCH RESULTS:\n- Search block.content field\n- Show topic name badge\n- Show content excerpt (first 100 chars)\n- Exclude current block from results\n- Show max 10 results, with \"Load more\" if needed\n\nLINK TYPE DESCRIPTIONS (show as tooltip or help text):\n- same_concept: \"Same idea expressed differently\"\n- related_topic: \"Connected concepts worth reviewing together\"\n- cross_specialty: \"Same topic from different specialty's perspective\"\n- comparison: \"Compare or contrast these concepts\"\n- builds_on: \"Understanding this requires understanding that first\"\n\nANCHOR TEXT SELECTION:\n- Show source block content in readonly textarea\n- User can select/highlight a phrase\n- Selected text stored as anchorText with start/end positions\n- Used later for hover-highlight in links sidebar\n\nEDGE CASES:\n\nLink already exists:\n- Check before creating: getNotebookLinkByBlocks(sourceId, targetId)\n- If exists: \"Already linked. Update anchor text?\" [Update] [Cancel]\n- Update only changes anchorText fields, preserves linkType\n\nSelf-link:\n- Filter current block from search results entirely\n\nCircular links:\n- A→B and B→A are both valid (bidirectional relationship)\n- Show both in respective sidebars\n- No special handling needed\n\nNo search results:\n- Show: \"No blocks found matching '[query]'. Try different keywords.\"",
        "testStrategy": "Test search finds blocks by content. Test search excludes current block. Test radio selection enables Create Link button. Test all 5 link types can be selected. Test anchor text selection captures text and positions. Test link created with correct fields. Test duplicate link shows update option. Test created link appears in sidebar immediately.",
        "priority": "high",
        "dependencies": [
          "126"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "134",
        "title": "Workflow 10: Remove Link",
        "description": "Delete notebook links with confirmation, handling bidirectional links independently.",
        "details": "WORKFLOW 10: REMOVE LINK\n\nSCREEN MOCKUP:\n```\nIn block detail sidebar, each link shows [x] button:\n\n+-------------------------+\n| REFERENCES              |\n|                         |\n| -> CKD Staging     [x]  |\n|    \"CKD patients\"       |\n|                         |\n| -> Statin Therapy  [x]  |\n|    \"statins\"            |\n+-------------------------+\n```\n\nFLOW:\n1. User clicks [x] on link in sidebar\n2. Show confirmation dialog: \"Remove link to [Topic: Block Title]?\" [Remove] [Cancel]\n3. On confirm: DELETE FROM notebook_links WHERE id = ?\n4. Sidebar refreshes to show updated links\n\nDATABASE OPERATIONS:\n```typescript\n// On confirm\nawait window.api.deleteNotebookLink(linkId);\n\n// Refresh sidebar\nconst linksFrom = await window.api.getNotebookLinksFromBlock(blockId);\nconst linksTo = await window.api.getNotebookLinksToBlock(blockId);\n```\n\nCONFIRMATION DIALOG:\n- Title: \"Remove Link?\"\n- Message: \"Remove link to [Target Topic]: '[Target Block Title excerpt]'?\"\n- Buttons: [Cancel] [Remove] (Remove is destructive/red)\n- No \"Don't ask again\" option - always confirm\n\nEDGE CASES:\n\nBidirectional links:\n- Removing A→B does NOT remove B→A\n- Each direction is independent\n- If user wants to remove both, they must delete each separately\n- Show both directions in sidebar with own [x] buttons\n\nLink to deleted block:\n- If target block was deleted, link should have been cascade-deleted\n- But if not (data integrity issue), show: \"Target block no longer exists\" and allow removal\n\nRace condition - link already deleted:\n- If DELETE returns 0 rows affected, show subtle toast: \"Link already removed\"\n- Still refresh sidebar\n\nUI REFRESH:\n- After deletion, immediately update sidebar without full page reload\n- Use optimistic UI: remove from list immediately, rollback if delete fails",
        "testStrategy": "Test [x] button shows on each link. Test confirmation dialog appears with correct target info. Test Remove deletes link from database. Test Cancel closes dialog without deletion. Test sidebar refreshes after removal. Test A→B removal doesn't affect B→A. Test optimistic UI removes link immediately. Test error handling for already-deleted links.",
        "priority": "high",
        "dependencies": [
          "126",
          "133"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "135",
        "title": "Workflow 6 Enhancement: Links Sidebar with Hover-Highlight",
        "description": "Add a links sidebar to Block Detail View showing references (outgoing) and linked-from (incoming) with hover-highlight of anchor text.",
        "details": "WORKFLOW 6 ENHANCEMENT: LINKS SIDEBAR\n\nSCREEN MOCKUP (Default - Sidebar Collapsed):\n```\n+-----------------------------------------------------------------------------+\n|  <- Back to CKD                                         [Edit] [...]       |\n|                                                                             |\n|  CKD - CV Mortality Risk                                                   |\n|  [Nephrology] [Cardiology] [Management] [Cross-Topic]                      |\n|                                                                     +-----+|\n|  ===================================================================|Lnk 3||\n|                                                                     |  >  ||\n|  CKD patients are 4-5x more likely to die of CVD than progress     |     ||\n|  to ESKD. Both CKD and albuminuria are independent CV risk         |     ||\n|  factors. Key management: treat CV risk factors (statins, BP       |     ||\n|  control).                                                          |     ||\n|                                                                     |     ||\n|  ===================================================================|     ||\n|                                                                     +-----+|\n|  SOURCE                                                     [View Full]   |\n|  QBank: CKD G3 - Leading Cause of Death  (check) Correct                   |\n|                                                                             |\n|  CARDS: None                                          [Generate Card]     |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nSCREEN MOCKUP (Sidebar Expanded):\n```\n+-----------------------------------------------------------------------------+\n|  <- Back to CKD                                               [Edit] [...]  |\n|                                                                             |\n|  +---------------------------------------------+-------------------------+  |\n|  |                                             | REFERENCES              |  |\n|  |  CKD - CV Mortality Risk                    |                         |  |\n|  |  [Nephro] [Cardio] [Mgmt] [Cross]          | -> CKD Staging          |  |\n|  |                                             |    \"CKD patients\"       |  |\n|  |  =========================================  |                         |  |\n|  |                                             | -> Statin Therapy       |  |\n|  |  CKD patients are 4-5x more likely to die  |    \"statins\"            |  |\n|  |  of CVD than progress to ESKD. Both CKD    |                         |  |\n|  |  and albuminuria are independent CV risk   | -> HTN in CKD           |  |\n|  |  factors. Key management: treat CV risk    |    \"BP control\"         |  |\n|  |  factors (statins, BP control).            |                         |  |\n|  |                                             | --------------------    |  |\n|  |  =========================================  |                         |  |\n|  |                                             | LINKED FROM             |  |\n|  |  SOURCE                          [View]    | <- Diabetic Nephro      |  |\n|  |  QBank: CKD G3...  (check)                 |                         |  |\n|  |                                             | [+ Add Link]            |  |\n|  |  CARDS: None          [Generate Card]      |                         |  |\n|  |                                             |                         |  |\n|  +---------------------------------------------+-------------------------+  |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nINTERACTIONS:\n- Hover \"-> CKD Staging\" -> \"CKD patients\" highlights in content\n- Click \"-> CKD Staging\" -> Navigate to that block\n- Sidebar collapsed by default, click link count badge to expand\n- Click outside sidebar or [<] to collapse\n\nSIDEBAR SECTIONS:\n\n1. REFERENCES (outgoing links):\n- Links FROM this block TO other blocks\n- Format: \"-> [Topic Name]\" with anchor text below\n- Each has [x] button for removal (Workflow 10)\n\n2. LINKED FROM (incoming links):\n- Links FROM other blocks TO this block\n- Format: \"<- [Topic Name]\"\n- No [x] button (delete from source block)\n\n3. [+ Add Link] button:\n- Opens Workflow 9 modal\n\nDATABASE QUERIES:\n```typescript\n// Get block with source\nconst block = await window.api.getNotebookBlock(blockId);\nconst source = await window.api.getSourceItem(block.sourceItemId);\nconst topic = await window.api.getCanonicalTopic(page.canonicalTopicId);\n\n// Get cards for this block\nconst cards = await window.api.getCardsBySourceBlock(blockId);\n\n// Get links (requires v16 migration)\nconst linksTo = await window.api.getNotebookLinksFromBlock(blockId);\nconst linkedFrom = await window.api.getNotebookLinksToBlock(blockId);\n```\n\nHOVER-HIGHLIGHT IMPLEMENTATION:\n- Each link stores anchorText, anchorStart, anchorEnd\n- On hover over link in sidebar:\n  - Find text span in content matching anchorStart:anchorEnd\n  - Apply highlight CSS class (yellow background)\n- On mouse leave: remove highlight\n- If anchorText but no positions: search for text and highlight first match\n\nLINK BADGE (collapsed state):\n- Show total link count: linksTo.length + linkedFrom.length\n- Badge color: neutral if 0, accent if >0\n- Click badge to expand sidebar\n\nNAVIGATION:\n- Click link row -> navigate to target block's topic page\n- Scroll to and highlight target block\n- Add to browser history for back button",
        "testStrategy": "Test sidebar shows link count badge. Test clicking badge expands sidebar. Test REFERENCES shows outgoing links with anchor text. Test LINKED FROM shows incoming links. Test hover highlights anchor text in content. Test click navigates to target block. Test [x] button triggers Workflow 10 removal. Test [+ Add Link] opens Workflow 9. Test sidebar collapses on outside click. Test empty state when no links.",
        "priority": "high",
        "dependencies": [
          "126",
          "133",
          "134"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create collapsible sidebar structure with link count badge",
            "description": "Implement collapsible sidebar UI component in TopicPageView showing link count badge when collapsed, expanding to show links panel on click.",
            "dependencies": [],
            "details": "Add state management for sidebar open/closed in TopicPageView.tsx. Create sidebar container component with fixed positioning on right side. Implement badge showing total link count (linksTo.length + linkedFrom.length) with accent color when count > 0, neutral when 0. Badge click handler toggles sidebar expansion. Include collapse button [<] in expanded state. Use shadcn/ui components (Sheet or custom div with animations) following existing patterns in NotebookBlock.tsx. Position sidebar to not overlap block content area.",
            "status": "pending",
            "testStrategy": "Test sidebar renders collapsed by default. Test badge shows correct count (0 initially). Test clicking badge expands sidebar. Test [<] button collapses sidebar. Test clicking outside sidebar collapses it. Test sidebar doesn't overlap content. Test badge color changes based on link count.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement REFERENCES section for outgoing links",
            "description": "Display outgoing links from current block to other blocks, showing target topic name and anchor text with delete button.",
            "dependencies": [
              1
            ],
            "details": "In expanded sidebar, create REFERENCES section header. Query notebook_links table via window.api.getNotebookLinksFromBlock(blockId) to fetch outgoing links. For each link, display format: '-> [Topic Name]' with anchor text below in smaller muted text. Fetch target block and topic names via window.api.getNotebookBlock() and window.api.getCanonicalTopic(). Add [x] button for each link that triggers Workflow 10 removal (onClick handler only, actual deletion in subtask 5). Use lucide-react icons (ArrowRight for ->). Handle loading states and empty state ('No references').",
            "status": "pending",
            "testStrategy": "Test REFERENCES section renders with correct header. Test outgoing links display with correct topic names. Test anchor text shows below each link. Test [x] button appears on each link. Test loading state shows spinner. Test empty state message when no links. Test link data fetched from correct IPC calls.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement LINKED FROM section for incoming links",
            "description": "Display incoming links to current block from other blocks, showing source topic names without delete buttons.",
            "dependencies": [
              1
            ],
            "details": "In expanded sidebar below REFERENCES section, add horizontal divider then LINKED FROM section header. Query notebook_links table via window.api.getNotebookLinksToBlock(blockId) to fetch incoming links. For each link, display format: '<- [Topic Name]' without anchor text (since text is in source block, not current block). Fetch source block and topic names. No [x] button (must delete from source block). Use lucide-react ArrowLeft icon for <-. Add [+ Add Link] button at bottom that opens Workflow 9 modal (placeholder onClick for now). Handle loading and empty states.",
            "status": "pending",
            "testStrategy": "Test LINKED FROM section renders below REFERENCES with divider. Test incoming links display with correct topic names. Test no [x] button on incoming links. Test [+ Add Link] button renders. Test empty state message when no incoming links. Test section separated from REFERENCES visually.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement hover-highlight of anchor text in block content",
            "description": "Highlight anchor text spans in block content when hovering over links in sidebar using anchorStart/anchorEnd positions.",
            "dependencies": [
              2
            ],
            "details": "For each link in REFERENCES section with anchorText/anchorStart/anchorEnd data, add onMouseEnter and onMouseLeave handlers. On hover, identify the text span in NotebookBlock content div (contentRef) matching positions anchorStart:anchorEnd. Apply highlight CSS class (bg-yellow-200 dark:bg-yellow-900/30) to create span wrapper around target text. Use document.createRange() and Range API to wrap text. On mouse leave, remove highlight wrapper and restore original text. Fallback: if positions missing but anchorText exists, search for first text match and highlight. Store highlight cleanup function in ref to prevent memory leaks. Test with multiple simultaneous hovers.",
            "status": "pending",
            "testStrategy": "Test hovering link highlights correct text in content. Test highlighting uses correct positions (anchorStart:anchorEnd). Test highlight removes on mouse leave. Test fallback search works when positions missing. Test multiple rapid hovers don't break highlighting. Test highlight styling visible in light/dark themes. Test no highlight when anchorText not found.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement navigation on link click to target block",
            "description": "Navigate to target block's topic page when clicking a link, scrolling to and highlighting the target block with browser history support.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add onClick handler to each link row in both REFERENCES and LINKED FROM sections. On click, extract targetBlockId from link data. Call useAppStore.setCurrentView('notebook', targetPageId) to navigate to target topic page. After navigation, use scrollIntoView() to scroll to target block element (requires block elements to have id='block-{blockId}'). Add temporary highlight animation to target block (bg-accent flash for 2s). Update NotebookBlock.tsx to add id attribute to block container. Use router or native browser history.pushState() to enable back button navigation. Handle case where target page/block not found with error toast.",
            "status": "pending",
            "testStrategy": "Test clicking outgoing link navigates to target page. Test clicking incoming link navigates to source page. Test page scrolls to target block after navigation. Test target block highlights temporarily. Test back button returns to previous page. Test navigation with missing target shows error. Test browser history updated correctly.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "136",
        "title": "Workflow 13: Edit Card - Add Reset Progress Button",
        "description": "Add the Reset Progress button to the Edit Card screen to allow users to reset FSRS scheduling data.",
        "details": "WORKFLOW 13: EDIT CARD - RESET PROGRESS\n\nSCREEN MOCKUP:\n```\n+-----------------------------------------------------------------------------+\n|  EDIT CARD                                                          [X]     |\n|                                                                             |\n|  From block: \"CKD - CV Mortality Risk\"                                     |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|  FRONT:                                                                    |\n|  +---------------------------------------------------------------------+   |\n|  | A patient with CKD stage G3 is more likely to _____ than progress  |   |\n|  | to ESKD requiring dialysis.                                         |   |\n|  +---------------------------------------------------------------------+   |\n|                                                                             |\n|  BACK:                                                                     |\n|  +---------------------------------------------------------------------+   |\n|  | Die of cardiovascular disease (4-5x more likely)                    |   |\n|  |                                                                     |   |\n|  | -> Manage CV risk factors: statins, BP control                     |   |\n|  +---------------------------------------------------------------------+   |\n|                                                                             |\n|  Type: [Cloze v]        Status: [Active v]                                |\n|                                                                             |\n|  -------------------------------------------------------------------------  |\n|                                                                             |\n|       [Reset Progress]                              [Cancel] [Save]        |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n```\n\nRESET PROGRESS BUTTON:\n- Located in footer, left side (destructive action, separate from Save)\n- Styled as outline/ghost button with warning color\n- Requires confirmation before executing\n\nCONFIRMATION DIALOG:\n```\n+----------------------------------------+\n|  Reset Card Progress?                  |\n|                                        |\n|  This will:                            |\n|  - Reset the card to \"New\" state      |\n|  - Clear all scheduling data           |\n|  - Card will appear in next review     |\n|                                        |\n|  Review history will be preserved.     |\n|                                        |\n|       [Cancel]        [Reset]          |\n+----------------------------------------+\n```\n\nDATABASE OPERATIONS:\n```typescript\n// Normal save (keep FSRS progress)\nawait window.api.updateCard(cardId, {\n  front: newFront,\n  back: newBack,\n  cardType: newType,\n});\n\n// Reset progress\nawait window.api.updateCard(cardId, {\n  stability: 0,\n  difficulty: 0,\n  dueDate: new Date().toISOString(),  // Due immediately\n  state: 0,  // New\n  reps: 0,\n  lapses: 0,\n  elapsedDays: 0,\n  scheduledDays: 0,\n  lastReview: null,\n});\n```\n\nWHEN TO SHOW RESET BUTTON:\n- Only show if card has been reviewed at least once (reps > 0)\n- For new cards (reps === 0), hide the button (nothing to reset)\n\nPOST-RESET BEHAVIOR:\n- Show success toast: \"Card progress reset. It will appear in your next review.\"\n- Stay on edit screen (don't close modal)\n- Update any visible stats on the screen\n\nREVIEW HISTORY PRESERVATION:\n- Do NOT delete review_logs entries\n- Historical data preserved for analytics\n- Only FSRS scheduling fields reset\n\nEDGE CASES:\n\nCard not yet reviewed:\n- Hide Reset Progress button entirely\n- Or show disabled with tooltip: \"No progress to reset\"\n\nReset + Save in same session:\n- Reset is independent of Save\n- Reset executes immediately on confirmation\n- User can then edit content and Save, or Cancel\n\nReset then Cancel:\n- Reset already executed - cannot be undone\n- Cancel only discards content changes, not the reset",
        "testStrategy": "Test Reset Progress button visible for reviewed cards (reps > 0). Test button hidden for new cards (reps === 0). Test confirmation dialog appears on click. Test Cancel closes dialog without reset. Test Reset clears all FSRS fields. Test dueDate set to now. Test state set to 0 (New). Test review_logs preserved after reset. Test success toast shown. Test card appears in next review session.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      },
      {
        "id": "137",
        "title": "Workflow 3: AI Backlink Detection (Async)",
        "description": "Implement async AI backlink detection that runs after notebook block creation to find and suggest related blocks.",
        "details": "WORKFLOW 3: AI BACKLINK DETECTION (ASYNC)\n\nStatus: Requires notebook_links table (v16 migration)\n\nWHEN IT RUNS:\n- After notebook block created (Workflow 2)\n- After notebook block edited with significant content change (Workflow 7)\n- Runs asynchronously - NEVER blocks the save operation\n\nTRIGGER POINTS:\n```typescript\n// In addToNotebook (Workflow 2), after block created:\nawait window.api.createNotebookBlock({ ... });\n// Trigger async - don't await\nwindow.api.queueBacklinkDetection(newBlockId);\n\n// In updateBlock (Workflow 7), if content changed significantly:\nif (levenshteinRatio(oldContent, newContent) > 0.3) {\n  window.api.queueBacklinkDetection(blockId);\n}\n```\n\nAI PROMPT - BACKLINK DETECTION:\n```\nSYSTEM: Find related notebook blocks and identify anchor phrases.\n\nNEW BLOCK:\nContent: {content}\nTopic: {topicName}\nTags: {tags}\n\nEXISTING BLOCKS (candidates):\n[\n  { \"id\": \"abc123\", \"topicName\": \"CKD Staging\", \"excerpt\": \"GFR cutoffs...\" },\n  { \"id\": \"def456\", \"topicName\": \"Statin Therapy\", \"excerpt\": \"When to start...\" },\n  ...\n]\n\nOUTPUT JSON:\n{\n  \"relatedBlocks\": [\n    {\n      \"blockId\": \"abc123\",\n      \"reason\": \"Same disease context\",\n      \"linkType\": \"same_concept\",\n      \"anchorText\": \"CKD patients\",\n      \"anchorStart\": 0,\n      \"anchorEnd\": 12\n    }\n  ]\n}\n\nRULES:\n- Max 5 related blocks\n- Only genuinely related content (high confidence)\n- anchorText must be exact substring of content\n- Prefer specific phrases over generic terms\n- linkType must be one of: same_concept, related_topic, cross_specialty, comparison, builds_on\n```\n\nBACKEND PROCESSING:\n```typescript\n// In main process - background job queue\nasync function processBacklinkDetection(blockId: string) {\n  const block = await db.getNotebookBlock(blockId);\n  const page = await db.getNotebookTopicPage(block.notebookTopicPageId);\n  const topic = await db.getCanonicalTopic(page.canonicalTopicId);\n  \n  // Get candidate blocks (limit to prevent huge context)\n  const candidates = await db.getRecentNotebookBlocks(100); // Last 100 blocks\n  const candidatesExcludingSelf = candidates.filter(c => c.id !== blockId);\n  \n  // Call AI\n  const aiResult = await callAI(buildBacklinkPrompt(block, topic, candidatesExcludingSelf));\n  \n  // Create links\n  for (const rel of aiResult.relatedBlocks) {\n    await db.run(`\n      INSERT INTO notebook_links (\n        id, sourceBlockId, targetBlockId, linkType, reason,\n        anchorText, anchorStart, anchorEnd, createdAt\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(sourceBlockId, targetBlockId) DO UPDATE SET\n        reason = excluded.reason,\n        anchorText = excluded.anchorText,\n        anchorStart = excluded.anchorStart,\n        anchorEnd = excluded.anchorEnd\n    `, [uuid(), blockId, rel.blockId, rel.linkType, rel.reason,\n        rel.anchorText, rel.anchorStart, rel.anchorEnd, new Date().toISOString()]);\n  }\n  \n  // Notify renderer that links updated\n  mainWindow.webContents.send('backlinks-updated', { blockId });\n}\n```\n\nUI NOTIFICATION:\n- While processing: subtle indicator in links sidebar (spinner icon)\n- When complete: refresh links sidebar, show count badge update\n- If AI found links: subtle toast \"Found X related blocks\"\n- No blocking UI - user can continue working\n\nCANDIDATE SELECTION:\n- Don't send ALL blocks to AI (context limits)\n- Strategy: Recent 100 blocks across all topics\n- Future enhancement: Use embeddings for semantic similarity pre-filter\n\nEDGE CASES:\n\nAI timeout/failure:\n- Log error, don't retry immediately\n- No user-facing error (async background task)\n- Retry on next app launch or manual trigger\n\nDuplicate detection run:\n- If block edited multiple times quickly, debounce\n- Only run once per block per 30 seconds\n\nNo related blocks found:\n- Valid result - not everything is related\n- Don't create any links, don't notify user\n\nBlock deleted before processing:\n- Check block exists before processing\n- If deleted, skip silently",
        "testStrategy": "Test backlink detection triggered after block creation. Test runs asynchronously (doesn't block save). Test AI prompt includes block content and candidates. Test links created with correct fields. Test ON CONFLICT updates existing links. Test UI notified via IPC when complete. Test links sidebar refreshes. Test debounce prevents rapid re-runs. Test graceful handling of AI timeout. Test deleted block handled gracefully.",
        "priority": "medium",
        "dependencies": [
          "126",
          "127"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create v16 migration for notebook_links table",
            "description": "Add notebook_links table schema in new v16 migration file to store bidirectional links between notebook blocks with anchor text positions.",
            "dependencies": [],
            "details": "Create electron/database/migrations/v16.ts following the pattern from v15.ts. The table should include: id (TEXT PRIMARY KEY), sourceBlockId (TEXT NOT NULL), targetBlockId (TEXT NOT NULL), linkType (TEXT NOT NULL - values: same_concept, related_topic, cross_specialty, comparison, builds_on), reason (TEXT NOT NULL), anchorText (TEXT), anchorStart (INTEGER), anchorEnd (INTEGER), createdAt (TEXT NOT NULL), isManual (INTEGER DEFAULT 0). Add UNIQUE constraint on (sourceBlockId, targetBlockId). Add foreign keys to notebook_blocks with ON DELETE CASCADE. Create indices on sourceBlockId and targetBlockId. Update electron/database/migrations/index.ts to import and call migrateToV16. Update electron/database/client.ts to run v16 if currentVersion < 16.",
            "status": "pending",
            "testStrategy": "Test migration creates table with correct schema. Test UNIQUE constraint prevents duplicate links. Test foreign keys cascade deletes. Test indices are created. Test migration runs on app startup when schema version is 15.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement background job queue for backlink detection",
            "description": "Create async job queue system in main process to handle backlink detection without blocking notebook operations.",
            "dependencies": [
              1
            ],
            "details": "Create electron/services/backlink-queue.ts with: 1) In-memory Map to track queued jobs (blockId -> timestamp), 2) 30-second debounce per blockId to prevent duplicate runs, 3) queueBacklinkDetection(blockId) function that adds job to queue and triggers processing, 4) processBacklinkDetection(blockId) async function that: fetches block + page + topic, gets recent 100 blocks (excluding self) via notebookBlockQueries, calls AI service with backlink detection prompt, creates/updates links in notebook_links table using INSERT ON CONFLICT, sends 'backlinks-updated' IPC event to renderer. Handle edge cases: block deleted before processing (check exists), AI timeout/failure (log only, no retry), duplicate detection (debounce). Export queue functions for use in ipc-handlers.",
            "status": "pending",
            "testStrategy": "Test debounce prevents multiple runs within 30 seconds. Test queue processes jobs asynchronously. Test block deletion before processing is handled gracefully. Test AI failure doesn't crash queue. Test 'backlinks-updated' IPC sent after completion.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add AI backlink detection prompt to ai-service.ts",
            "description": "Implement detectBacklinks function in ai-service.ts that calls AI with structured prompt to find related blocks and suggest anchor text.",
            "dependencies": [
              1
            ],
            "details": "Add detectBacklinks(block, topic, candidateBlocks) function to electron/ai-service.ts following the pattern from existing functions like findRelatedNotes. Build prompt with: NEW BLOCK (content, topicName, tags), EXISTING BLOCKS array (id, topicName, excerpt - first 200 chars). Request JSON output with relatedBlocks array containing: blockId, reason, linkType (enum), anchorText (exact substring), anchorStart, anchorEnd. Rules: max 5 related blocks, high confidence only, anchorText must be exact substring of content, prefer specific phrases over generic terms. Use aiCache for caching with key based on block content + candidate IDs. Handle AI timeout (return empty results), invalid JSON (log error, return empty), missing required fields (skip that link). Export type BacklinkDetectionResult with relatedBlocks array.",
            "status": "pending",
            "testStrategy": "Test prompt includes block content and candidates. Test max 5 results enforced. Test anchorText validation (must be substring). Test linkType enum validation. Test cache hit returns cached result. Test AI timeout returns empty array. Test invalid JSON handled gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add IPC handlers and trigger points for backlink detection",
            "description": "Wire up IPC handler for queueBacklinkDetection and add trigger calls in createNotebookBlock and updateNotebookBlock handlers.",
            "dependencies": [
              2,
              3
            ],
            "details": "In electron/ipc-handlers.ts: 1) Add ipcMain.handle('notebook:queueBacklinkDetection', async (_, blockId) => { queueBacklinkDetection(blockId); return { data: null, error: null }; }). 2) In existing 'notebook:createBlock' handler, after block created successfully, add non-awaited call: queueBacklinkDetection(newBlock.id). 3) In existing 'notebook:updateBlock' handler (if exists, otherwise create in subtask), after update succeeds, calculate content change using simple comparison (e.g., oldContent !== newContent), if changed call queueBacklinkDetection(blockId). In electron/preload.ts: Add notebook.queueBacklinkDetection: (blockId: string) => ipcRenderer.invoke('notebook:queueBacklinkDetection', blockId). In src/types/electron.d.ts: Add queueBacklinkDetection to notebook interface. Note: Don't await the queue call - it must be fire-and-forget.",
            "status": "pending",
            "testStrategy": "Test queueBacklinkDetection IPC exists. Test createBlock triggers detection without blocking save. Test updateBlock triggers detection on content change. Test no detection on no-op update. Test preload exposes queueBacklinkDetection. Test TypeScript types updated.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement notebook_links database queries and IPC for UI refresh",
            "description": "Create notebook-links.ts queries module and IPC handler for getBlockLinks, plus IPC listener in renderer for backlinks-updated events.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create electron/database/notebook-links.ts with: 1) notebookLinkQueries.getBySourceBlock(blockId) - returns links where sourceBlockId matches, JOIN with notebook_blocks and notebook_topic_pages to get target block content + topic name, 2) notebookLinkQueries.getByTargetBlock(blockId) - reverse lookup (backlinks), 3) notebookLinkQueries.insert(link) - create new link, 4) notebookLinkQueries.delete(id) - remove link. Export from electron/database.ts. In electron/ipc-handlers.ts: Add 'notebook:getBlockLinks' handler that calls getBySourceBlock and getByTargetBlock, returns { outgoing, incoming }. In electron/preload.ts: Add notebook.getBlockLinks(blockId) and notebook.onBacklinksUpdated(callback) with cleanup. In src/types/electron.d.ts: Add NotebookLink type and interfaces. Update src/stores/useAppStore.ts to add refreshBlockLinks action (optional - depends on UI implementation in later tasks).",
            "status": "pending",
            "testStrategy": "Test getBySourceBlock returns correct links. Test getByTargetBlock returns incoming links. Test link insertion with all fields. Test link deletion. Test IPC handler returns outgoing + incoming. Test onBacklinksUpdated listener receives events. Test cleanup removes listener.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-12T21:00:00.000Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-16T20:50:14.830Z",
      "taskCount": 42,
      "completedCount": 25,
      "tags": [
        "master"
      ]
    }
  }
}