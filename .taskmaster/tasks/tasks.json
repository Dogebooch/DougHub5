{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Database schema expansion for Quick Dump queue and medical features",
        "description": "Add quick_dumps table and extend cards/notes tables to support medical list processing, partial credit, response time tracking, and connection suggestions",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create quick_dumps table schema and migration logic",
            "description": "Add quick_dumps table to database.ts with proper schema, types, and version migration from user_version=1 to user_version=2",
            "dependencies": [],
            "details": "In electron/database.ts: Add DbQuickDump interface with id, content, extractionStatus, createdAt, processedAt fields. Add QuickDumpRow interface and parseQuickDumpRow helper. In initDatabase(), add schema version migration check. Migration creates quick_dumps table and idx_quick_dumps_status index. Update user_version to 2.",
            "status": "pending",
            "testStrategy": "Open existing database, verify migration runs only once, confirm quick_dumps table exists with correct columns using SQLite browser, verify index via EXPLAIN QUERY PLAN",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extend cards table with medical feature columns",
            "description": "Add cardType, parentListId, and listPosition columns to cards table through schema migration",
            "dependencies": [
              1
            ],
            "details": "In electron/database.ts: Update DbCard and CardRow interfaces to include cardType, parentListId, listPosition. In migration block, add ALTER TABLE statements for new columns. Create indexes idx_cards_cardType and idx_cards_parentListId. Update parseCardRow and cardQueries methods.",
            "status": "pending",
            "testStrategy": "Verify ALTER TABLE succeeds, confirm new columns exist with correct defaults, test cardQueries.insert with cardType='vignette', verify indexes via EXPLAIN QUERY PLAN",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extend review_logs table with performance tracking columns",
            "description": "Add responseTimeMs and partialCreditScore columns to review_logs table for tracking review performance metrics",
            "dependencies": [
              1
            ],
            "details": "In electron/database.ts: Update DbReviewLog and ReviewLogRow interfaces to include responseTimeMs and partialCreditScore. In migration block, add ALTER TABLE statements with CHECK constraint for partialCreditScore (0-1 range). Update reviewLogQueries.insert. Update src/types/index.ts ReviewLog interface.",
            "status": "pending",
            "testStrategy": "Verify ALTER TABLE succeeds, test reviewLogQueries.insert with responseTimeMs=1500 and partialCreditScore=0.75, verify CHECK constraint rejects invalid values",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create connections table for semantic note relationships",
            "description": "Add connections table to store semantic relationships between notes with similarity scores",
            "dependencies": [
              1
            ],
            "details": "In electron/database.ts: Add DbConnection and ConnectionRow interfaces and parseConnectionRow helper. In migration block, create connections table with foreign key constraints to notes table with CASCADE delete. Create three indexes: idx_connections_sourceNoteId, idx_connections_targetNoteId, idx_connections_semanticScore.",
            "status": "pending",
            "testStrategy": "Verify connections table created with foreign key constraints, test CASCADE delete, confirm all indexes exist via EXPLAIN QUERY PLAN, verify semanticScore accepts REAL values",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement query functions and IPC handlers for new tables",
            "description": "Create quickDumpQueries and connectionQueries objects, add corresponding IPC handlers in ipc-handlers.ts, and expose via preload.ts",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "In electron/database.ts: Add quickDumpQueries with getAll, getByStatus, insert, update, delete methods. Add connectionQueries with getAll, getBySourceNote, getByTargetNote, insert, delete methods. In electron/ipc-handlers.ts: Add IPC handlers for quickDumps and connections operations. In electron/preload.ts: Expose quickDumps and connections API. In src/types/electron.d.ts: Add QuickDump and Connection interfaces and extend ElectronAPI.",
            "status": "pending",
            "testStrategy": "Test quickDumpQueries operations, verify IPC roundtrip from renderer, test connectionQueries methods, verify all handlers return IpcResult format, test error handling",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-05T00:05:06.017Z"
      },
      {
        "id": "2",
        "title": "AI service integration layer",
        "description": "Create local-first AI service with Ollama auto-detection, cloud fallbacks (OpenAI, DeepSeek, Anthropic), concept extraction, card format suggestions, and medical content processing",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AI provider abstraction and type definitions",
            "description": "Set up local-first provider detection, OpenAI-compatible SDK configuration, and all AI-related types",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:12:15.700Z"
          },
          {
            "id": 2,
            "title": "Implement concept extraction and card validation functions",
            "description": "Build extractConcepts and validateCard functions with provider-aware timeout and retry logic",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:15:33.268Z"
          },
          {
            "id": 3,
            "title": "Implement medical list detection and vignette conversion",
            "description": "Create functions to detect medical lists and convert list items to clinical vignettes",
            "dependencies": [
              1,
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:17:15.711Z"
          },
          {
            "id": 4,
            "title": "Implement tag suggestions and semantic similarity search",
            "description": "Build AI-powered tag suggestion and note similarity matching functions",
            "dependencies": [
              1,
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:19:43.555Z"
          },
          {
            "id": 5,
            "title": "Add caching layer and IPC handlers for AI service",
            "description": "Implement 5-minute result caching, provider status, and integrate AI service with IPC layer",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T01:22:53.351Z"
          }
        ],
        "updatedAt": "2026-01-05T01:22:53.351Z"
      },
      {
        "id": "3",
        "title": "AI-guided capture interface",
        "description": "Replace manual capture interface with AI concept extraction workflow: paste → highlight → confirm → format suggestion → save",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add paste detection and content state management",
            "description": "Implement paste area UI with auto-detection and state management for pasted content, extracted concepts, selected concepts, and processing state",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T14:29:44.663Z"
          },
          {
            "id": 2,
            "title": "Create concept extraction display with checkboxes",
            "description": "Build ConceptCheckbox component to display extracted concepts with selection, format badges, and edit capability",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T14:29:44.666Z"
          },
          {
            "id": 3,
            "title": "Implement AI concept extraction integration",
            "description": "Wire up AI service calls for concept extraction with loading states and error handling",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T14:29:44.669Z"
          },
          {
            "id": 4,
            "title": "Add format suggestion display and validation warnings",
            "description": "Create ValidationWarning component and integrate real-time card validation for each selected concept",
            "dependencies": [
              2,
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T14:29:44.671Z"
          },
          {
            "id": 5,
            "title": "Implement batch card creation and auto-note generation",
            "description": "Create batch card creation flow with auto-generated parent Note and save feedback within 500ms",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T14:29:44.672Z"
          }
        ],
        "updatedAt": "2026-01-05T14:29:44.672Z"
      },
      {
        "id": "4",
        "title": "Medical list processing and clinical vignette generation",
        "description": "Convert medical lists (differentials, procedures) into clinical vignettes and overlapping cloze cards to prevent sibling contamination",
        "details": "Create src/lib/medical-processor.ts:\n- processMedicalList(content: string, listType): Promise<ProcessedCard[]>\n- For 'differential' type: generate individual clinical vignettes per item (e.g., '5 causes of chest pain' → 5 separate patient scenarios)\n- For 'procedure' type: create overlapping cloze deletions (step N shows context from N-1 and N+1)\n- For 'algorithm' type: similar to procedure with decision tree context\n- Each vignette includes: patient demographics, presentation, key findings\n- Use ai-service.convertToVignette for generation\n- Store parentListId to link related cards\n- Add MedicalListConverter component for preview before creation\n- Integration in CaptureInterface: detect list → show preview → confirm → batch create\n- Ensure zero sibling contamination: each card is independently answerable\n- Add cardType field to distinguish vignettes from standard Q&A",
        "testStrategy": "Test with real medical lists: 'DDx for acute MI', '5 steps of BLS'. Verify each card is independently answerable without seeing siblings. Check overlapping cloze maintains context. Validate vignettes are clinically realistic.",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement list detection and parsing in medical processor",
            "description": "Create src/lib/medical-processor.ts with list detection logic that identifies medical lists (differential diagnoses, procedures, algorithms) from pasted content and parses them into structured data",
            "dependencies": [],
            "details": "Create src/lib/medical-processor.ts with these functions:\n- detectListType(content: string): 'differential' | 'procedure' | 'algorithm' | null - Detect if content contains a medical list using pattern matching (e.g., numbered items, 'DDx', 'steps', 'causes')\n- parseListItems(content: string): string[] - Extract individual list items from the content\n- Add TypeScript types: MedicalListType, ParsedListItem { text: string, order: number }\n- Handle various list formats: numbered (1., 2.), bulleted (-, *), implicit lists\n- Return null for non-list content to bypass medical processing",
            "status": "pending",
            "testStrategy": "Test with medical list samples: '5 causes of chest pain:\\n1. MI\\n2. PE\\n3. Pneumothorax\\n4. GERD\\n5. Costochondritis'. Verify detectListType returns 'differential'. Test procedure steps, algorithm content. Verify non-list content returns null.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build differential diagnosis to clinical vignette converter",
            "description": "Implement processDifferentialList function that converts each differential diagnosis item into an independent clinical vignette with patient demographics, presentation, and key findings",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "deferred",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T15:44:19.524Z"
          },
          {
            "id": 3,
            "title": "Create overlapping cloze generator for procedures and algorithms",
            "description": "Implement processProcedureList and processAlgorithmList functions that create overlapping cloze deletions where step N shows context from steps N-1 and N+1 to maintain procedural flow",
            "dependencies": [
              1
            ],
            "details": "In src/lib/medical-processor.ts, add:\n- processProcedureList(items: string[], parentTitle: string): ProcessedCard[] - Create overlapping cloze for procedures\n- processAlgorithmList(items: string[], parentTitle: string): ProcessedCard[] - Similar with decision tree context\n- Overlapping cloze format: front shows step N-1 (if exists) + '[...blank...]' + step N+1 (if exists), back shows step N\n- Example: Step 2 of BLS -> front: '1. Check responsiveness\\n[...?...]\\n3. Call for help', back: '2. Open airway'\n- Edge cases: first step shows only N+1, last step shows only N-1\n- Each card has cardType='cloze', parentListId for grouping\n- Ensure contextual continuity prevents 'naked' questions\n<info added on 2026-01-05T15:45:40.548Z>\nI need to analyze the codebase to understand the current implementation and provide accurate, code-specific guidance for this expanded subtask.Now let me check if there's a medical-processor.ts file or any AI concept extraction patterns:Let me check the AI types and see the extractConcepts implementation:Based on my analysis of the codebase, I can now generate the subtask update text:\n\nSCOPE CHANGE: All list types (differential, procedure, algorithm) now use unified overlapping cloze approach instead of clinical vignettes. Clinical vignettes deferred to post-MVP.\n\nOVERLAPPING CLOZE MECHANISM:\nEach list item becomes individual FSRS-scheduled card. Front shows cloze target with 2-3 shuffled sibling items as context. Shuffle happens at review time to prevent pattern matching.\n\nDATABASE SCHEMA ALREADY IN PLACE:\nSchema updates complete in electron/database.ts:28-31 - cardType, parentListId (UUID linking all cards from same list), listPosition (original index for List Health view). Indexes idx_cards_cardType and idx_cards_parentListId exist. Default cardType='qa' in migration.\n\nCREATE src/lib/medical-processor.ts:\n- processAllListTypes(items: string[], parentTitle: string, listType: 'differential' | 'procedure' | 'algorithm'): ProcessedCard[] - Unified processor for all list types\n- generateOverlappingCloze(item: string, index: number, allItems: string[], listType: string): { front: string, back: string } - Core cloze generator\n- For each item at position N, front shows: shuffled selection of 2-3 sibling items + cloze placeholder for target item. Back shows target item.\n- Shuffle logic: at review time in review interface, randomize context items order and selection to maximize anti-pattern-matching\n- Edge handling: lists with <3 items show all available siblings, single-item lists become standard Q&A\n- Each card: cardType='list-cloze', parentListId=uuid() shared across all cards from same list, listPosition=original index\n- Return ProcessedCard[] array with all FSRS defaults (state=0, reps=0, dueDate=now)\n\nINTEGRATION POINT:\nHook into existing AI concept extraction at src/components/capture/CaptureInterface.tsx:286-288 where cardType is already set. When list detected, call processAllListTypes instead of standard card creation.\n\nVALIDATION:\nEnsure cards independently answerable without seeing siblings. Verify context items shuffled across reviews. Test with 'DDx for chest pain', 'BLS steps', 'Sepsis algorithm'.\n</info added on 2026-01-05T15:45:40.548Z>",
            "status": "pending",
            "testStrategy": "Test with '5 steps of BLS' procedure list. Verify 5 cloze cards generated with overlapping context. Check step 1 shows step 2 context, step 3 shows steps 2 and 4, step 5 shows step 4. Verify cardType='cloze' and consistent parentListId.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build MedicalListConverter preview component with batch creation",
            "description": "Create src/components/capture/MedicalListConverter.tsx component that displays preview of generated cards before creation, allows editing/removal, and handles batch card creation with parentListId tracking",
            "dependencies": [
              2,
              3
            ],
            "details": "Create MedicalListConverter component:\n- Props: { content: string, listType: MedicalListType, onConfirm: (cards: ProcessedCard[]) => void, onCancel: () => void }\n- Use medical-processor to generate preview cards on mount\n- Display cards in grid/list with Card component from shadcn/ui\n- Show card type badge (Vignette/Cloze), front preview (truncated), edit/remove buttons\n- Allow inline editing of front/back text before confirmation\n- Confirm button calls onConfirm with final ProcessedCard[] array\n- Show parentListId indicator to visualize card relationships\n- Use existing UI components: Card, Button, Badge, ScrollArea from src/components/ui/",
            "status": "pending",
            "testStrategy": "Render MedicalListConverter with differential list. Verify preview shows 5 vignette cards with front/back preview. Test edit functionality updates card text. Test remove reduces card count. Click confirm, verify onConfirm receives ProcessedCard[] with all edits applied.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate medical list workflow into CaptureInterface with database schema updates",
            "description": "Extend CaptureInterface to detect medical lists on paste, show MedicalListConverter preview, batch create cards with new cardType and parentListId fields, and update database schema to support these fields",
            "dependencies": [
              4
            ],
            "details": "Update multiple files:\n1. src/types/index.ts: Add cardType?: 'standard' | 'vignette' | 'cloze' and parentListId?: string to Card interface\n2. electron/database.ts: Add cardType and parentListId columns to cards table schema (nullable for backward compatibility)\n3. src/components/capture/CaptureInterface.tsx:\n   - Add state: detectedListType, showMedicalConverter (boolean)\n   - On paste event, call medical-processor.detectListType\n   - If list detected, set detectedListType and show MedicalListConverter modal\n   - MedicalListConverter onConfirm: batch create cards via useAppStore.addCard with cardType and parentListId fields\n   - Update handleCreateCards to preserve cardType/parentListId when provided\n   - Add parentListId to CardWithFSRS construction in CaptureInterface.tsx:63-80\n4. electron/database.ts DbCard interface: Add cardType and parentListId fields\n5. Maintain backward compatibility: cardType defaults to 'standard', parentListId defaults to null for non-list cards",
            "status": "pending",
            "testStrategy": "E2E test: Paste 'DDx for MI: 1. Unstable angina 2. PE 3. Aortic dissection' into CaptureInterface. Verify MedicalListConverter modal appears. Review generated vignettes, confirm creation. Query database, verify 3 cards created with cardType='vignette' and matching parentListId. Test normal card creation still works (cardType='standard', parentListId=null).",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-05T15:44:19.524Z"
      },
      {
        "id": "5",
        "title": "Zero-decision review interface (eliminate grading buttons)",
        "description": "Replace 4-button grading (Again/Hard/Good/Easy) with Show Answer → Continue flow, letting FSRS auto-schedule based on response time",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove grading buttons and interval preview UI",
            "description": "Remove the 4-button grading interface (Again/Hard/Good/Easy) and interval previews from ReviewInterface.tsx",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.586Z"
          },
          {
            "id": 2,
            "title": "Implement Show Answer → Continue flow with response time tracking",
            "description": "Replace grading buttons with single Continue button and add response time tracking from card shown to Continue pressed",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.591Z"
          },
          {
            "id": 3,
            "title": "Implement auto-rating algorithm based on response time",
            "description": "Create algorithm to automatically determine Rating based on response time: <5s=Easy, 5-15s=Good, 15-30s=Hard, >30s=Again",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.595Z"
          },
          {
            "id": 4,
            "title": "Update scheduleReview to accept and store responseTimeMs",
            "description": "Modify scheduleReview function and review_logs table to accept and persist response time in milliseconds",
            "dependencies": [
              3
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.598Z"
          },
          {
            "id": 5,
            "title": "UI cleanup and zero-decision interface verification",
            "description": "Clean up UI after removing grading buttons, verify progress bar and session stats work, ensure FSRS performance <100ms",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.600Z"
          },
          {
            "id": 6,
            "title": "Auto-grade animation feedback display",
            "description": "Show brief visual feedback of the auto-determined grade (Easy/Good/Hard/Again) for ~1 second after Continue pressed, before advancing to next card",
            "dependencies": [
              5
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.603Z"
          },
          {
            "id": 7,
            "title": "Quick override mechanism during feedback display",
            "description": "Allow user to override auto-grade during the 1-second feedback window using keyboard shortcuts (1-4) or clicking alternative grades",
            "dependencies": [
              6
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T00:32:13.607Z"
          }
        ],
        "updatedAt": "2026-01-06T00:32:13.607Z"
      },
      {
        "id": "6",
        "title": "Auto note creation and bidirectional linking",
        "description": "Automatically create Notes from extraction sessions and maintain bidirectional links between cards and source notes",
        "details": "Update src/components/capture/CaptureInterface.tsx:\n- On card creation, auto-generate parent Note with: title (first line or 'Extraction - [timestamp]'), content (original pasted text), cardIds (all created card IDs), tags (AI-suggested + user tags)\n- Update all created cards with noteId referencing parent Note\n- Add NoteContext component in ReviewInterface: shows source note title, 'View source' link, related cards count\n- Create src/components/notes/NoteViewer.tsx: displays note content, derived cards list, metadata (created date, tags)\n- Add navigation: clicking noteId in review → opens NoteViewer modal\n- NoteViewer shows all cards derived from note with edit/delete actions\n- Update store: when deleting card, remove cardId from parent note.cardIds; when deleting note, orphan cards (noteId = '')\n- Ensure referential integrity: transactions for create/update/delete operations\n- Add 'View source' button in ReviewInterface below card content",
        "testStrategy": "Create cards from paste → verify Note created with correct content and cardIds. Review card → click 'View source' → verify Note displayed with all derived cards. Delete card → verify cardIds updated in Note. Delete Note → verify cards orphaned.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Connection suggestions and semantic linking",
        "description": "AI surfaces related notes during extraction based on semantic similarity to help build knowledge connections",
        "details": "Create src/components/capture/ConnectionSuggestions.tsx:\n- During extraction, call ai-service.findRelatedNotes(pastedContent, existingNotes)\n- Display gentle highlight banner: 'Related notes found: [NoteTitle1], [NoteTitle2]' with similarity scores\n- Allow one-click linking: creates connection record in connections table\n- Show in ReviewInterface: 'Related cards' section below answer (if connections exist)\n- Implement semantic search using embeddings (OpenAI text-embedding-3-small or local model)\n- Cache embeddings in notes table (add embeddingVector TEXT field - JSON array)\n- Compute cosine similarity for matching (threshold: >0.7 for suggestions)\n- ConnectionSuggestions displays top 3 matches with preview snippet\n- Add 'Link' button to create bidirectional connection\n- Store semantic score for future ranking/filtering\n- Integration: non-intrusive, doesn't block workflow, dismissible",
        "testStrategy": "Create note about 'Acute MI pathophysiology', then paste related content about 'Chest pain differential'. Verify suggestions appear with correct similarity scores. Link notes → verify connection in DB. Review card from linked note → verify 'Related cards' appears.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Extraction queue for Quick Dump processing",
        "description": "Process Quick Dumps later with same AI-assisted extraction workflow, show queue indicator, batch processing support",
        "details": "Create src/components/queue/ExtractionQueue.tsx:\n- Fetch all quick_dumps with extractionStatus='pending' on mount\n- Display list: title (first 50 chars), timestamp, 'Process' button\n- Clicking 'Process' opens guided extraction flow (same as CaptureInterface but pre-populated with quick_dump.content)\n- After successful extraction, update quick_dump.extractionStatus='completed', processedAt=now\n- Add queue indicator in Header: badge showing pending count, click to open ExtractionQueue\n- Support batch selection: checkboxes, 'Process all selected' button\n- Update QuickDumpModal to save to quick_dumps table instead of notes\n- Add IPC handlers: quickDumps:getAll, quickDumps:updateStatus\n- Integration in AppLayout: new route/view for queue\n- Queue view shows: content preview, creation date, actions (Process/Delete)\n- Empty state: 'No pending extractions. Use Quick Dump (Cmd+Shift+S) to capture content.'",
        "testStrategy": "Save 3 Quick Dumps → verify queue shows 3 pending. Process one → verify AI extraction flow works. Complete extraction → verify count decreases. Test batch processing. Verify quick dumps don't interfere with normal notes.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Tag-based organization with AI suggestions",
        "description": "Implement tag-only organization (no folders), AI suggests medical domain tags during capture, search/filter by tags",
        "details": "Update CaptureInterface and types:\n- During extraction, call ai-service.suggestTags(content) to get medical domain tags\n- Display suggested tags as chips with '+' to add, show common tags: 'cardiology', 'pharmacology', 'pathophysiology', etc.\n- Allow manual tag entry: input field with autocomplete from existing tags\n- Create src/components/tags/TagManager.tsx: displays all tags with card counts, filter view\n- Add tag filtering to SearchBar: clicking tag shows all cards/notes with that tag\n- Store tags in cards.tags and notes.tags (JSON array)\n- Create tag index query: SELECT DISTINCT json_each.value as tag FROM cards, json_each(cards.tags)\n- Add TagChip component: displays tag with color based on domain (cardio=red, pharm=blue, etc.)\n- TagManager shows tag hierarchy (domain-based grouping)\n- No folder UI, purely tag-based navigation\n- Search supports tag:cardiology syntax",
        "testStrategy": "Paste cardiology content → verify AI suggests 'cardiology', 'acute coronary syndrome'. Add custom tag → verify autocomplete. Filter by tag → verify only matching cards shown. Test tag persistence across sessions.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Global search with <200ms response time",
        "description": "Implement fast unified search across cards and notes with FTS5 full-text search, Cmd+F shortcut, instant results",
        "details": "Add to database.ts:\n- Create FTS5 virtual table: CREATE VIRTUAL TABLE cards_fts USING fts5(id, front, back, content=cards, content_rowid=rowid)\n- Create FTS5 for notes: CREATE VIRTUAL TABLE notes_fts USING fts5(id, title, content, content=notes, content_rowid=rowid)\n- Add triggers to keep FTS tables synchronized with cards/notes on INSERT/UPDATE/DELETE\n- Create searchQueries.search(query: string): {cards: DbCard[], notes: DbNote[], responseTimeMs: number}\n- Use FTS5 MATCH for fast search (ORDER BY rank)\n- Update src/components/layout/SearchBar.tsx:\n  * Real-time search as user types (debounced 150ms)\n  * Display unified results: cards (front snippet) + notes (title)\n  * Keyboard navigation: Up/Down arrows, Enter to open\n  * Cmd+F global shortcut to focus search\n  * Results dropdown with highlights, max 10 results\n  * Show 'View all X results' if >10 matches\n- Add search highlighting using FTS5 snippet() function\n- Log search performance, warn if >200ms\n- Support tag: prefix for tag filtering\n- Create SearchResults component for full results page",
        "testStrategy": "Index 1000 cards, search 'acute MI', verify <200ms response. Test special chars, partial matches. Verify Cmd+F focuses search. Test keyboard navigation. Confirm FTS tables stay synchronized on card create/update/delete.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create FTS5 virtual tables for cards, notes, and source_items with sync triggers",
            "description": "Implement FTS5 full-text search tables with automatic synchronization triggers for all searchable content",
            "dependencies": [],
            "details": "In electron/database.ts, create three FTS5 virtual tables:\n\n1. cards_fts: CREATE VIRTUAL TABLE cards_fts USING fts5(id UNINDEXED, front, back, content=cards, content_rowid=rowid)\n2. notes_fts: CREATE VIRTUAL TABLE notes_fts USING fts5(id UNINDEXED, title, content, content=notes, content_rowid=rowid)\n3. source_items_fts: CREATE VIRTUAL TABLE source_items_fts USING fts5(id UNINDEXED, title, rawContent, sourceName, content=source_items, content_rowid=rowid)\n\nAdd sync triggers for each table (INSERT, UPDATE, DELETE) to keep FTS tables synchronized:\n- cards_fts_insert, cards_fts_update, cards_fts_delete\n- notes_fts_insert, notes_fts_update, notes_fts_delete\n- source_items_fts_insert, source_items_fts_update, source_items_fts_delete\n\nImplement in initializeDatabase() function and add to schema migration (v4). Test with existing data to verify initial population and trigger synchronization.",
            "status": "pending",
            "testStrategy": "Create test card, verify FTS entry exists. Update card front text, verify FTS updated. Delete card, verify FTS entry removed. Repeat for notes and source_items. Query SELECT * FROM cards_fts WHERE cards_fts MATCH 'test' to verify indexing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement searchQueries.search() with filter support and performance tracking",
            "description": "Create unified search function that queries all FTS tables with filter options (all/cards/notes/inbox) and tracks response time",
            "dependencies": [
              1
            ],
            "details": "In electron/database.ts, create new searchQueries object with search() method:\n\ninterface SearchResult {\n  cards: DbCard[];\n  notes: DbNote[];\n  sourceItems: DbSourceItem[];\n  responseTimeMs: number;\n  totalMatches: number;\n}\n\ntype SearchFilter = 'all' | 'cards' | 'notes' | 'inbox';\n\nsearchQueries.search(query: string, filter: SearchFilter = 'all', limit: number = 10): SearchResult\n\nImplementation:\n1. Start performance timer (Date.now())\n2. Sanitize query (escape FTS5 special chars unless using tag: prefix)\n3. Handle tag: prefix → convert to tags LIKE query\n4. Handle # prefix → convert to tag: automatically\n5. Use FTS5 MATCH with ORDER BY rank for relevance\n6. Query based on filter:\n   - 'all': Query all three FTS tables\n   - 'cards': Only cards_fts\n   - 'notes': Only notes_fts  \n   - 'inbox': Only source_items_fts WHERE status='inbox'\n7. Join FTS results with main tables to get full records\n8. Calculate responseTimeMs, log warning if >200ms\n9. Return SearchResult with results + metadata\n\nUse snippet() function for highlighted excerpts in future subtasks.",
            "status": "pending",
            "testStrategy": "Index 1000 cards. Search 'acute MI' with filter='all', verify <200ms. Search with filter='cards', verify only cards returned. Search 'tag:cardiology', verify tag filtering. Search '#nephrology', verify # converts to tag. Test special characters (quotes, parentheses). Verify responseTimeMs accuracy.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add IPC handler, preload exposure, and TypeScript types for search",
            "description": "Wire up search functionality through IPC layer with proper type definitions",
            "dependencies": [
              2
            ],
            "details": "1. In electron/database.ts, export SearchResult interface and searchQueries object\n\n2. In electron/ipc-handlers.ts, add handler:\nipcMain.handle('search:query', async (_, query: string, filter: SearchFilter, limit?: number): Promise<IpcResult<SearchResult>> => {\n  try {\n    const startTime = Date.now();\n    const results = searchQueries.search(query, filter, limit);\n    return success(results);\n  } catch (error) {\n    return failure(error);\n  }\n});\n\n3. In electron/preload.ts, expose search API:\nsearch: {\n  query: (query: string, filter: SearchFilter, limit?: number) => ipcRenderer.invoke('search:query', query, filter, limit)\n}\n\n4. In src/types/index.ts, add:\nexport interface SearchResult {\n  cards: Card[];\n  notes: Note[];\n  sourceItems: SourceItem[];\n  responseTimeMs: number;\n  totalMatches: number;\n}\nexport type SearchFilter = 'all' | 'cards' | 'notes' | 'inbox';\n\n5. In src/types/electron.d.ts, add to ElectronAPI:\nsearch: {\n  query: (query: string, filter: SearchFilter, limit?: number) => Promise<IpcResult<SearchResult>>;\n}\n\nTest by calling window.api.search.query() from browser console.",
            "status": "pending",
            "testStrategy": "Open DevTools console, call await window.api.search.query('test', 'all'). Verify IpcResult<SearchResult> returned. Test with filter='cards', verify type safety. Confirm TypeScript compilation with no errors.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build basic SearchBar component with debounced query and results dropdown",
            "description": "Replace placeholder SearchBar with functional component that performs real-time search with debounced input and displays top 10 results in dropdown",
            "dependencies": [
              3
            ],
            "details": "Update src/components/layout/SearchBar.tsx:\n\n1. Add state:\n   - query: string (search input)\n   - results: SearchResult | null\n   - isOpen: boolean (dropdown visibility)\n   - activeFilter: SearchFilter (default 'all')\n   - isLoading: boolean\n\n2. Implement debounced search (150ms) using useEffect:\n   - Clear timeout on query change\n   - If query.length >= 2, call window.api.search.query(query, activeFilter, 10)\n   - Update results state, set isOpen=true\n   - If query empty, clear results, set isOpen=false\n\n3. Results dropdown UI:\n   - Position absolute below input\n   - Max height with scroll\n   - Show cards section (if results.cards.length > 0)\n   - Show notes section (if results.notes.length > 0)\n   - Show source items section (if results.sourceItems.length > 0)\n   - Each result shows:\n     * Type icon (Card/Note/Inbox indicator)\n     * Title/front text (truncated)\n     * onClick → navigate to item\n   - Show 'No results' if totalMatches === 0\n   - Close dropdown on click outside (useEffect with document listener)\n\n4. Performance display:\n   - Show responseTimeMs in dropdown footer\n   - Warn if >200ms (yellow indicator)\n\nDefer keyboard navigation and filter chips to later subtasks. Focus on core search functionality.",
            "status": "pending",
            "testStrategy": "Type 'acu' in SearchBar, wait 150ms, verify API called with 'acu'. Type 'acute', verify only one API call made (debounce working). Click result, verify navigation. Click outside dropdown, verify closes. Test with empty query, verify dropdown hidden. Check DevTools Network tab for response time display accuracy.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add horizontal filter chips UI with toggleable selection and count badges",
            "description": "Implement filter chip buttons (All/Cards/Notes/Inbox) above search results with active state and result counts",
            "dependencies": [
              4
            ],
            "details": "Update src/components/layout/SearchBar.tsx to add filter chips:\n\n1. Create FilterChip component:\n   - Props: label, count, isActive, onClick\n   - Visual: horizontal pill button with badge\n   - Active state: purple background (bg-primary)\n   - Inactive state: gray background (bg-secondary/20)\n   - Count badge: small circle with number (only show if count > 0)\n\n2. Filter chips container:\n   - Position: inside results dropdown, above results list\n   - Layout: flex row, gap-2, horizontal scroll if needed\n   - Chips: ['All', 'Cards', 'Notes', 'Inbox']\n   - Display counts from SearchResult:\n     * All: results.totalMatches\n     * Cards: results.cards.length\n     * Notes: results.notes.length\n     * Inbox: results.sourceItems.length (filtered by status='inbox')\n\n3. Click behavior:\n   - Set activeFilter state to clicked filter\n   - Trigger new search with updated filter\n   - Update active chip visual state\n   - Only one chip active at a time\n\n4. Styling:\n   - Use Tailwind classes for consistent look\n   - Match DougHub purple theme for active state\n   - Smooth transition on filter change\n   - Mobile responsive (horizontal scroll on small screens)\n\n5. Update search logic:\n   - Pass activeFilter to window.api.search.query()\n   - Re-render results based on filter\n   - Preserve scroll position when switching filters",
            "status": "pending",
            "testStrategy": "Search 'test', verify 'All' chip active and shows total count. Click 'Cards' chip, verify only cards displayed and chip highlights purple. Verify count badges update correctly. Click 'All' again, verify all results return. Test with query that has 0 cards, verify Cards chip shows count=0. Test horizontal scroll on mobile viewport.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement keyboard navigation and Ctrl+F global shortcut",
            "description": "Add full keyboard support for search including Up/Down/Enter/Escape navigation and global Ctrl+F hotkey to focus search bar",
            "dependencies": [
              5
            ],
            "details": "Update src/components/layout/SearchBar.tsx for keyboard controls:\n\n1. Global Ctrl+F shortcut:\n   - Use useEffect with document keydown listener\n   - Check if (e.ctrlKey && e.key === 'f')\n   - e.preventDefault() to override browser search\n   - Focus SearchBar input using ref\n   - Show dropdown if results exist\n   - Cleanup listener on unmount\n\n2. Dropdown navigation state:\n   - Add selectedIndex: number state (-1 = none selected)\n   - Calculate flattened results array (cards + notes + sourceItems)\n   - Highlight selected result with different background color\n\n3. Arrow key navigation (when dropdown open):\n   - ArrowDown: increment selectedIndex, wrap to 0 if at end, prevent default scroll\n   - ArrowUp: decrement selectedIndex, wrap to last if at -1, prevent default\n   - Auto-scroll selected item into view (element.scrollIntoView({ block: 'nearest' }))\n\n4. Enter key behavior:\n   - If dropdown open && selectedIndex >= 0: navigate to selected item, close dropdown\n   - If dropdown closed: open dropdown (trigger search if query exists)\n\n5. Escape key:\n   - First press: clear selection (selectedIndex = -1)\n   - Second press: close dropdown (isOpen = false)\n   - Third press: blur input and clear query\n\n6. Mouse interaction:\n   - onMouseEnter on result item: update selectedIndex\n   - Preserve keyboard selection on mouse move\n\n7. Accessibility:\n   - Add aria-activedescendant to input\n   - Add role='listbox' to dropdown\n   - Add role='option' to each result",
            "status": "pending",
            "testStrategy": "Press Ctrl+F from review view, verify SearchBar focused. Type query, press ArrowDown 3 times, verify 3rd result highlighted. Press Enter, verify navigated to that item. Press Escape, verify dropdown closes. Test ArrowUp wrapping to last item. Test from any view (Capture, Review, Settings). Verify browser default Ctrl+F prevented. Test mouse hover updates selectedIndex.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add search term highlighting in result snippets",
            "description": "Implement visual highlighting of matched search terms in result text using FTS5 snippet() function",
            "dependencies": [
              4
            ],
            "details": "Implement search term highlighting:\n\n1. Update searchQueries.search() in electron/database.ts:\n   - Use FTS5 snippet() function to generate highlighted excerpts:\n     snippet(cards_fts, 1, '<mark>', '</mark>', '...', 32)\n   - snippet params: (table, column_idx, start_tag, end_tag, ellipsis, max_tokens)\n   - For cards: snippet front (col 1) and back (col 2)\n   - For notes: snippet title (col 1) and content (col 2)\n   - For source_items: snippet title (col 1) and rawContent (col 2)\n   - Add snippet fields to SearchResult interface:\n     cards: Array<DbCard & { frontSnippet?: string, backSnippet?: string }>\n     notes: Array<DbNote & { titleSnippet?: string, contentSnippet?: string }>\n     sourceItems: Array<DbSourceItem & { titleSnippet?: string, contentSnippet?: string }>\n\n2. Update SearchBar.tsx result rendering:\n   - Create HighlightedText component:\n     * Takes html string with <mark> tags\n     * Uses dangerouslySetInnerHTML with sanitization\n     * Styles <mark> with yellow background (bg-yellow-200 dark:bg-yellow-800)\n   - Render frontSnippet instead of plain front text\n   - Show backSnippet in smaller gray text below\n   - Fallback to original text if snippet undefined\n\n3. Security:\n   - Sanitize HTML before rendering (use DOMPurify or strip all tags except <mark>)\n   - Only allow <mark> tags through sanitization\n\n4. Styling:\n   - Highlighted terms: bg-yellow-200/50 for light mode, bg-yellow-700/30 for dark\n   - Bold text for emphasis\n   - Smooth visual distinction from surrounding text",
            "status": "pending",
            "testStrategy": "Search 'myocardial', verify 'myocardial' highlighted in yellow in card results. Search 'acute MI', verify both terms highlighted. Search special characters like 'C. difficile', verify proper highlighting. Test XSS by searching '<script>alert(1)</script>', verify script tags stripped but search works. Verify ellipsis (...) appears for long content.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create full SearchResults page component with sections and view-all navigation",
            "description": "Build dedicated full-page search results view with categorized sections, showing all matches beyond the 10-result dropdown limit",
            "dependencies": [
              7
            ],
            "details": "Create src/components/search/SearchResultsPage.tsx:\n\n1. Page structure:\n   - Full-height layout with SearchBar at top (pre-filled with query)\n   - Tabbed sections: All / Cards / Notes / Inbox\n   - Each section shows paginated results (20 per page)\n   - Performance metrics in header (X results in Yms)\n\n2. Result sections:\n   - Cards section:\n     * Grid layout (2 columns on desktop, 1 on mobile)\n     * Card preview with front/back text\n     * Due date badge, tag pills\n     * Click → navigate to ReviewInterface with that card\n   - Notes section:\n     * List layout with title + content preview\n     * Click → navigate to note detail view\n   - Inbox section:\n     * Source items with type icon, title, source name\n     * Status badge (inbox/processed/curated)\n     * Click → navigate to source item detail\n\n3. Empty states:\n   - No results: 'No matches found for \"query\"'\n   - Suggestions: 'Try different keywords' / 'Use tag:name to filter'\n\n4. View-all link in SearchBar dropdown:\n   - Show at bottom if totalMatches > 10\n   - Text: 'View all {totalMatches} results →'\n   - onClick: navigate to /search?q={query}&filter={activeFilter}\n   - Preserve filter state in URL\n\n5. URL state management:\n   - Read query params: ?q=searchterm&filter=cards\n   - Update URL on filter/query change (pushState)\n   - Allow browser back/forward navigation\n\n6. Performance:\n   - Virtualized list for >100 results (react-window)\n   - Debounced query updates (same 150ms as SearchBar)\n   - Show loading skeleton while searching\n\n7. Routing:\n   - Add /search route to App.tsx router\n   - Make SearchResultsPage accessible from SearchBar 'View all' link",
            "status": "pending",
            "testStrategy": "Search query with 50 results, click 'View all 50 results' in dropdown. Verify navigation to /search?q=... page. Verify all 50 results displayed in sections. Click 'Cards' tab, verify filter applied and URL updates. Click browser back button, verify returns to previous view. Test pagination with 100+ results. Verify performance <200ms even on full results page. Test empty state with nonsense query.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-06T05:12:32.737Z"
      },
      {
        "id": "11",
        "title": "Command palette (Cmd+K)",
        "description": "Keyboard-first command palette for search, create, navigate with fuzzy matching and recent actions",
        "details": "Update src/components/modals/CommandPalette.tsx:\n- Cmd+K global shortcut (prevent default browser behavior)\n- Fuzzy search using Fuse.js or similar\n- Command categories:\n  * Navigation: 'Go to Capture', 'Go to Review', 'Go to Queue', 'Go to Settings'\n  * Actions: 'Create new card', 'Quick Dump', 'Process queue item'\n  * Search: 'Search cards...', 'Search notes...', 'Filter by tag...'\n- Recent actions history (last 5), stored in localStorage\n- Keyboard-only operation: Up/Down to navigate, Enter to execute, Esc to close\n- Display keyboard shortcuts next to commands\n- Integrate with AppView navigation via useAppStore.setCurrentView\n- Add command execution handlers for each action\n- Show command descriptions and shortcuts\n- Support typeahead: typing narrows results\n- Visual: centered modal, 500px width, max 8 results visible",
        "testStrategy": "Press Cmd+K → verify palette opens. Type 'cap' → verify 'Go to Capture' suggested. Press Enter → verify navigation. Test all commands execute correctly. Verify recent actions persist across sessions. Test keyboard navigation.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Response time tracking and FSRS personalization",
        "description": "Track response times during review, store in review_logs, use for interval adjustments and domain-specific scheduling",
        "details": "Extend FSRS integration in electron/fsrs-service.ts:\n- Add responseTimeMs parameter to scheduleReview()\n- Store in DbReviewLog.responseTimeMs (already added in task 1)\n- Create analytics module: electron/fsrs-analytics.ts\n  * calculatePersonalParams(cardId: string): Promise<FSRSParams> - analyzes review history for card\n  * getDomainStats(domain: string): {avgResponseTime: number, accuracy: number}\n  * getOptimizedRetention(userId: string): number - personalized retention rate based on performance\n- Track domain from card tags (first tag = primary domain)\n- Implement forgetting curve optimization: adjust retention target per domain based on historical performance\n- Add settings UI to display stats: average response time by domain, accuracy trends\n- Use response time intelligence to detect cards needing reformulation (consistently >30s)\n- Create IPC handlers for analytics queries\n- Privacy: all data stays local, no external tracking",
        "testStrategy": "Review 20 cards with varying response times. Query analytics → verify response times stored. Check domain stats → verify cardiology vs pharmacology tracked separately. Test personalized params applied to new reviews.",
        "priority": "low",
        "dependencies": [
          "1",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "Partial credit tracking for medical list cards",
        "description": "Track individual list item recall for clinical vignettes (3/5 correct schedules differently than 1/5)",
        "details": "Update ReviewInterface for cardType='vignette':\n- After showing answer, display checklist of list items (e.g., 5 causes)\n- User checks items they recalled correctly\n- Calculate partialCreditScore = recalled / total (0.0 to 1.0)\n- Store in review_logs.partialCreditScore\n- Modify FSRS rating calculation:\n  * score >= 0.8: Rating.Good\n  * score 0.5-0.79: Rating.Hard\n  * score < 0.5: Rating.Again\n- Add PartialCreditInput component: renders checkboxes for each list item\n- Extract list items from card.back (parse numbered list or use stored listItems metadata)\n- Update card update flow to preserve individual item scheduling\n- Alternative: split list cards into individual cards with parentListId for granular tracking\n- Add UI indicator in review: 'Recalled 3/5 items'\n- Store itemScores as JSON in review_log for detailed analytics",
        "testStrategy": "Review vignette card with 5 causes. Check 3/5 recalled → verify score=0.6, rating=Hard. Review same card later → verify interval reflects partial credit. Test edge cases: 0/5, 5/5.",
        "priority": "low",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Data persistence and crash recovery",
        "description": "Auto-save on every action, session restoration, hourly backups retained 7 days, zero data loss guarantee",
        "details": "Enhance electron/database.ts:\n- All mutations already use WAL mode (enabled in initDatabase)\n- Add backup system: electron/backup-service.ts\n  * Hourly backup: copy doughub.db → backups/doughub-[timestamp].db\n  * Retention: delete backups older than 7 days\n  * Use electron's app.getPath('userData') + '/backups/'\n  * Backup on app close (before quit)\n- Session state persistence:\n  * Store currentView, reviewQueue, currentQueueIndex in localStorage\n  * Restore on app launch via useAppStore.initialize()\n- Auto-save indicators:\n  * Show 'Saved ✓' toast <500ms after DB write\n  * Status bar indicator: 'Last saved: 2s ago'\n- Crash recovery:\n  * On app launch, check for incomplete transactions (SQLite handles this)\n  * Restore draft from localStorage if exists\n- Test data integrity: simulate crash (kill process), verify no data loss\n- Add 'Restore from backup' option in Settings",
        "testStrategy": "Create card, kill app process immediately → restart → verify card saved. Simulate power loss during review → verify queue restored. Test hourly backup creation. Verify 7-day retention cleanup. Test restore from backup.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backup-service.ts for automated database backups",
            "description": "Implement hourly backup system with 7-day retention policy",
            "dependencies": [],
            "details": "Create electron/backup-service.ts module with functions for: 1) createBackup() - copies doughub.db to backups/doughub-[ISO timestamp].db using fs.copyFileSync, 2) cleanupOldBackups() - deletes backups older than 7 days using fs.readdirSync/fs.statSync/fs.unlinkSync, 3) initBackupService() - sets up hourly interval (setInterval 3600000ms) and returns cleanup function, 4) backupOnQuit() - one-time backup before app close. Use app.getPath('userData') for paths. Add proper error handling and logging for all operations.",
            "status": "pending",
            "testStrategy": "Unit tests: verify backup file creation with correct timestamp format, test retention cleanup removes files >7 days old while preserving recent ones. Integration test: run app for test period, verify hourly backups created, simulate 8-day period and verify only 7 days retained.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate backup service into main.ts lifecycle",
            "description": "Hook backup service into Electron app initialization and shutdown",
            "dependencies": [
              1
            ],
            "details": "Update electron/main.ts to: 1) Import initBackupService and backupOnQuit from backup-service.ts, 2) Call initBackupService() after database initialization in app.whenReady() and store cleanup function, 3) Add IPC handler 'backup:restore' in ipc-handlers.ts that takes backup filename, closes current DB, copies backup to doughub.db, and reinitializes DB, 4) Update preload.ts to expose backup.restore(filename) API, 5) Modify before-quit handler to call backupOnQuit() before closeDatabase(). Ensure proper sequencing and error handling.",
            "status": "pending",
            "testStrategy": "Test app startup creates hourly backup timer, verify before-quit creates final backup. Test restore: create backup, add test card, restore backup, verify card doesn't exist. Test error handling: attempt restore with invalid filename.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement session state persistence with localStorage",
            "description": "Persist and restore currentView and review queue state across app restarts",
            "dependencies": [],
            "details": "Update src/stores/useAppStore.ts: 1) Add persistSessionState() function that saves currentView, current card ID during review to localStorage under 'doughub-session' key as JSON, 2) Add restoreSessionState() function to read from localStorage and return parsed session object or null, 3) Modify initialize() method to call restoreSessionState() and apply to store if exists, 4) Add middleware to useAppStore that calls persistSessionState() whenever currentView changes or review progresses, 5) Add clearSessionState() for clean shutdown. Use try-catch for localStorage access with fallback for quota errors.",
            "status": "pending",
            "testStrategy": "Test persistence: navigate to review, close app (kill process), restart, verify returns to review at same position. Test with no saved state (first launch). Test localStorage quota exceeded scenario. Test invalid JSON in localStorage handled gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add auto-save toast indicators with <500ms feedback",
            "description": "Show 'Saved ✓' toast after successful DB writes within 500ms",
            "dependencies": [
              3
            ],
            "details": "Update useAppStore.ts actions (addCard, updateCard, deleteCard, addNote, updateNote, deleteNote): 1) Import { toast } from '@/hooks/use-toast', 2) After successful DB operation (result.data exists), call toast({ title: 'Saved ✓', duration: 2000 }) - ensure this happens <500ms after write completes, 3) On error, show error toast with result.error message, 4) Optional: Add lastSaved timestamp to store state and display 'Last saved: Xs ago' in a status indicator component. Use performance.now() to measure DB operation timing in development mode and log warning if >500ms.",
            "status": "pending",
            "testStrategy": "Test toast appears within 500ms of card creation (use performance.now() to measure). Test error toast on DB failure (simulate by passing invalid data). Verify toast doesn't block UI interaction. Test rapid successive saves don't create toast spam (TOAST_LIMIT=1 helps).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Settings UI for backup restoration",
            "description": "Create Settings interface with 'Restore from backup' functionality",
            "dependencies": [
              2
            ],
            "details": "Create src/components/settings/SettingsView.tsx (or update existing): 1) Add IPC handler 'backup:list' in ipc-handlers.ts that returns array of { filename, timestamp, size } from backups directory, 2) Expose window.api.backup.list() in preload.ts, 3) In Settings UI, create 'Data & Backup' section with: list of available backups (fetch via api.backup.list()), each showing formatted date/time and size, 'Restore' button per backup, 4) On restore click, show confirmation dialog (AlertDialog from shadcn/ui) warning data loss, 5) Call window.api.backup.restore(filename) and reload app state via store.initialize(), 6) Add currentView === 'settings' case in App.tsx router.",
            "status": "pending",
            "testStrategy": "Test backup list displays correctly with multiple backups. Test restore confirmation dialog appears. Test successful restore loads correct data (create card, backup, create another card, restore first backup, verify only first card exists). Test error handling for corrupted backup file.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "15",
        "title": "Evidence-based card validation system",
        "description": "Real-time warnings for pattern-matching cards, multi-fact violations, and minimum information principle enforcement",
        "details": "Create src/lib/card-validation.ts:\n- validateMinimumInformation(card): checks if card tests one concept only\n- detectPatternMatching(card): detects format recognition cues (e.g., 'Which of the following...', multiple choice artifacts)\n- detectMultiFact(card): warns if answer contains multiple independent facts\n- detectMedicalList(card): checks for list-style answers without clinical context\n- Create ValidationWarning component: displays warnings with explanation and fix suggestions\n- Integrate in CaptureInterface: show warnings as user confirms concepts\n- Use ai-service.validateCard for AI-powered detection\n- Validation categories:\n  * ERROR (blocks save): pattern-matching detected, empty fields\n  * WARNING (allows save with confirm): multi-fact, complex answer, list without context\n  * INFO: suggestions for improvement\n- Add 'Fix automatically' option for some violations (e.g., split multi-fact into multiple cards)\n- Store validation history for analytics (which warnings users dismiss most)\n- Settings: enable/disable specific validation rules",
        "testStrategy": "Create card with 'What are the 5 causes of X?' → verify list warning. Create pattern-matching card → verify error blocks save. Create multi-fact card → verify warning with split suggestion. Test auto-fix splits card correctly.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Global floating capture window (Ctrl+Enter)",
        "description": "Implement floating capture window accessible via Ctrl+Enter hotkey from anywhere in the app, allowing quick card creation without breaking workflow",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "3"
        ],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Auto-start Ollama from Electron on first AI request",
        "description": "Automatically start Ollama when the app needs AI services, eliminating the friction of manually starting Ollama before using the app",
        "details": "Update electron/ai-service.ts to auto-start Ollama:\n\n1. Create ensureOllamaRunning() function:\n   - Check if Ollama is already running via detectOllamaAvailable()\n   - If not running, spawn('ollama', ['serve']) with detached: true, stdio: 'ignore'\n   - Wait for Ollama to be ready (retry detection up to 10 times with 500ms intervals)\n   - Return true if started successfully, false if failed\n\n2. Update getClient() or initializeClient():\n   - Before returning client, call ensureOllamaRunning() if provider is 'ollama'\n   - Log startup status to console\n   - If Ollama can't start, fall back to cloud provider and notify user via IPC\n\n3. Add IPC handler for AI status notifications:\n   - ai:ollamaStarted - notify renderer when Ollama auto-started\n   - ai:ollamaFailed - notify renderer when Ollama couldn't start (show toast)\n\n4. Handle Windows/macOS/Linux differences:\n   - Windows: 'ollama.exe' may need full path or PATH lookup\n   - macOS/Linux: 'ollama' should work if installed via standard methods\n   - Check for ollama in PATH first, then common install locations\n\n5. Graceful degradation:\n   - If Ollama not installed, detect and inform user\n   - Offer to use cloud API as fallback (requires API key)\n   - Don't block app startup, just disable AI features gracefully",
        "testStrategy": "Test with Ollama installed but not running → verify auto-start works. Test with Ollama already running → verify no duplicate process. Test with Ollama not installed → verify graceful fallback message. Test on Windows specifically. Verify AI extraction works after auto-start.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ensureOllamaRunning() function with process spawning",
            "description": "Create function to check Ollama status and spawn it if not running",
            "dependencies": [],
            "details": "In electron/ai-service.ts, add:\n- Import { spawn } from 'child_process'\n- Create async function ensureOllamaRunning(): Promise<boolean>\n- First check if already running via existing detectOllamaAvailable() logic\n- If not running, spawn('ollama', ['serve'], { detached: true, stdio: 'ignore', shell: true })\n- Use process.unref() to allow parent to exit independently\n- Implement retry loop: 10 attempts, 500ms between each, checking detectOllamaAvailable()\n- Return true on success, false on failure after all retries\n- Add proper error handling for spawn failures (e.g., ollama not in PATH)",
            "status": "pending",
            "testStrategy": "Test with Ollama not running → verify spawn is called. Test with Ollama already running → verify no spawn. Test retry logic with mock delayed startup. Test error handling when ollama executable not found.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate auto-start into AI client initialization",
            "description": "Update initializeClient() to call ensureOllamaRunning() when Ollama provider is detected",
            "dependencies": [
              1
            ],
            "details": "In electron/ai-service.ts:\n- Update initializeClient() to be async if not already\n- Before creating OpenAI client for Ollama provider, call ensureOllamaRunning()\n- Log result: 'Ollama auto-started successfully' or 'Failed to start Ollama, falling back to...'\n- If ensureOllamaRunning() returns false and no cloud API key configured, set a flag for graceful degradation\n- Update getClient() to handle async initialization properly\n- Ensure first AI request waits for Ollama to be ready",
            "status": "pending",
            "testStrategy": "Test first extractConcepts() call triggers Ollama startup. Verify subsequent calls don't retry startup. Test fallback when Ollama fails to start. Verify logs show startup status.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add user notification for Ollama status via IPC",
            "description": "Notify renderer process about Ollama auto-start status so user sees feedback",
            "dependencies": [
              2
            ],
            "details": "In electron/ipc-handlers.ts:\n- Add IPC send (not handle) for 'ai:ollamaStatus' that sends { status: 'starting' | 'started' | 'failed', message: string }\n- In ai-service.ts, emit status updates during ensureOllamaRunning()\n- In renderer (CaptureInterface or App.tsx), listen for ai:ollamaStatus via window.api\n- Show toast: 'Starting local AI...' (info), 'Local AI ready' (success), 'Could not start local AI' (warning)\n- Update preload.ts to expose ai.onStatus(callback) listener\n- Update electron.d.ts with new IPC types",
            "status": "pending",
            "testStrategy": "Verify toast appears when Ollama auto-starts. Test 'failed' toast shows when Ollama unavailable. Verify no duplicate toasts on subsequent AI calls. Test listener cleanup on component unmount.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Handle cross-platform Ollama executable detection",
            "description": "Ensure Ollama can be found and started on Windows, macOS, and Linux",
            "dependencies": [
              1
            ],
            "details": "In electron/ai-service.ts:\n- Create findOllamaExecutable(): string | null function\n- Windows: Check PATH, then common locations like %LOCALAPPDATA%\\Programs\\Ollama\\ollama.exe\n- macOS: Check PATH, then /usr/local/bin/ollama, ~/.ollama/ollama\n- Linux: Check PATH, then /usr/local/bin/ollama, ~/.local/bin/ollama\n- Use which/where command as fallback to find in PATH\n- Update spawn() call to use full path when available\n- Add shell: true option for Windows compatibility\n- Log found path or 'Ollama not found in PATH or common locations'",
            "status": "pending",
            "testStrategy": "Test on Windows with Ollama installed via official installer. Test PATH detection. Test with Ollama not installed → verify appropriate error message. Verify spawn works with full path.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-06T05:29:32.390Z"
      },
      {
        "id": "18",
        "title": "Implement Quick Dump modal with Cmd+Shift+S shortcut",
        "description": "Zero-friction emergency capture modal for saving content when too exhausted to process, with global keyboard shortcut and auto-save to quick_dumps queue",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.483Z"
      },
      {
        "id": "19",
        "title": "Build extraction queue UI with guided processing workflow",
        "description": "Display pending quick dumps with process button that opens AI-guided extraction flow, batch processing support, queue indicator in header",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "18"
        ],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.514Z"
      },
      {
        "id": "20",
        "title": "Enhance review interface with source context and partial credit UI",
        "description": "Show source note context during review with 'View source' link, implement partial credit checklist for vignette cards, display related cards count",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.517Z"
      },
      {
        "id": "21",
        "title": "Create NoteViewer modal for source navigation",
        "description": "Build modal component to display full note content, all derived cards, metadata, and enable navigation between notes and cards during review",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          "20"
        ],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.520Z"
      },
      {
        "id": "22",
        "title": "Implement FTS5 full-text search with <200ms performance",
        "description": "Add SQLite FTS5 virtual tables for cards and notes, create synchronized triggers, build unified search function with performance tracking",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.523Z"
      },
      {
        "id": "23",
        "title": "Build command palette with fuzzy search and recent actions",
        "description": "Keyboard-first Cmd+K command palette for navigation, actions, and search with fuzzy matching, recent history, and keyboard-only operation",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.526Z"
      },
      {
        "id": "24",
        "title": "Implement tag system with AI suggestions and filtering",
        "description": "Tag-based organization with AI medical domain suggestions during capture, manual tag entry with autocomplete, tag filtering in search, and TagManager UI",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.528Z"
      },
      {
        "id": "25",
        "title": "Build connection suggestions and semantic linking system",
        "description": "AI surfaces related notes during extraction using semantic similarity, displays gentle suggestion banner, enables one-click linking, shows related cards during review",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "21"
        ],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.531Z"
      },
      {
        "id": "26",
        "title": "Implement FSRS analytics and response time intelligence",
        "description": "Track response times and domain-specific performance, create analytics module for personalized FSRS parameters, forgetting curve optimization, and card reformulation detection",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.533Z"
      },
      {
        "id": "27",
        "title": "Implement evidence-based card validation with auto-fix suggestions",
        "description": "Real-time validation warnings for pattern-matching, multi-fact violations, minimum information principle with auto-fix options and validation history tracking",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-05T15:14:47.536Z"
      },
      {
        "id": "28",
        "title": "AI Settings Configuration UI",
        "description": "Create Settings page section for AI provider configuration with provider selection, API keys, model dropdowns, connection testing, and persistence",
        "details": "Create AI configuration UI in Settings:\n\n1. PROVIDER SELECTION:\n- Radio group: Ollama (local), OpenAI, Anthropic, DeepSeek\n- Show provider status indicator (connected/disconnected)\n- Auto-detect Ollama on page load\n\n2. API KEY INPUTS:\n- Secure password inputs for cloud provider API keys\n- Keys stored in electron-store (encrypted) not SQLite\n- Show/hide toggle for each key\n- Validation on blur (format check)\n\n3. MODEL SELECTION:\n- Dropdown per provider with available models\n- Ollama: fetch from localhost:11434/api/tags\n- OpenAI: gpt-4o, gpt-4o-mini, gpt-3.5-turbo\n- Anthropic: claude-3-5-sonnet, claude-3-haiku\n- DeepSeek: deepseek-chat, deepseek-coder\n\n4. CONNECTION TEST:\n- 'Test Connection' button per provider\n- Shows success/failure with response time\n- Validates API key works\n\n5. TIMEOUT/RETRY SETTINGS:\n- Timeout slider: 3s-30s (default 10s local, 3s cloud)\n- Max retries: 1-5 (default 3)\n\nSTORAGE:\n- Use electron-store for settings persistence\n- Create electron/settings-store.ts\n- IPC handlers: settings:get, settings:set\n\nINTEGRATION:\n- Update ai-service.ts to read from settings-store\n- Restart AI client when settings change",
        "testStrategy": "Open Settings, verify AI section displays. Select OpenAI, enter API key, click Test Connection, verify success/failure. Change model, verify persists after app restart. Test Ollama auto-detection. Verify invalid API key shows error.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create electron-store settings persistence layer",
            "description": "Install electron-store and create settings-store.ts for encrypted AI settings storage, separate from SQLite database",
            "dependencies": [],
            "details": "Install electron-store package via npm. Create electron/settings-store.ts module that initializes Store instance with schema for AI provider settings (provider type, API keys, models, timeout, maxRetries). Keys must be encrypted using electron-store's built-in encryption. Define TypeScript interfaces for AISettings matching the settings structure from task description. Export functions: getSettings(), updateSettings(partial), resetSettings(). Settings schema should include: provider ('ollama' | 'openai' | 'anthropic' | 'deepseek'), apiKeys (object with keys per provider), selectedModels (object with model per provider), timeout (number, 3-30s), maxRetries (number, 1-5). Use file location: electron/settings-store.ts. Reference existing ai-service.ts at electron/ai-service.ts:1-959 for provider types and configuration structure.",
            "status": "pending",
            "testStrategy": "Unit test getSettings returns default values on first load. Test updateSettings persists changes and getSettings retrieves them. Verify API keys are encrypted in the store file. Test resetSettings returns to defaults.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add settings IPC handlers for renderer communication",
            "description": "Extend electron IPC handlers and preload script with settings:get and settings:set operations for secure settings access from React UI",
            "dependencies": [
              1
            ],
            "details": "In electron/ipc-handlers.ts, add two new IPC handlers: ipcMain.handle('settings:get', () => getSettings()) and ipcMain.handle('settings:set', (_, updates) => updateSettings(updates)). Import getSettings and updateSettings from settings-store.ts. In electron/preload.ts:87, add settings object to api with get() and set(updates) methods that invoke the IPC channels. In src/types/electron.d.ts:52, add settings interface to ElectronAPI type with matching method signatures returning Promise<IpcResult<AISettings>>. Follow existing IPC pattern seen in electron/preload.ts:62-86 for ai handlers and src/types/electron.d.ts:106-130 for AI type definitions. Ensure proper typing for settings updates (Partial<AISettings>).",
            "status": "pending",
            "testStrategy": "Test window.api.settings.get() returns settings from main process. Test window.api.settings.set() updates and persists settings. Verify IPC communication works bidirectionally. Test type safety in TypeScript.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build AI Settings UI component with provider selection and configuration",
            "description": "Create SettingsInterface.tsx React component with tabbed layout, AI provider selection radio group, API key inputs, model dropdowns, and connection testing UI",
            "dependencies": [
              2
            ],
            "details": "Create src/components/settings/SettingsInterface.tsx component. Use shadcn/ui components: Tabs for sections (AI, FSRS, Data), RadioGroup (src/components/ui/radio-group.tsx) for provider selection (Ollama, OpenAI, Anthropic, DeepSeek), Input for API keys with type='password' and show/hide toggle (Eye icon from lucide-react), Select for model dropdowns, Button for test connection, Slider (src/components/ui/slider.tsx) for timeout (3-30s) and max retries (1-5). Layout: AI tab contains provider selection at top, conditional API key input (hidden for Ollama), model dropdown populated based on provider (Ollama: fetch from localhost:11434/api/tags, OpenAI: hardcoded list [gpt-4o, gpt-4o-mini, gpt-3.5-turbo], Anthropic: [claude-3-5-sonnet, claude-3-haiku], DeepSeek: [deepseek-chat, deepseek-coder]), Test Connection button with loading state and success/error toast feedback, timeout/retry sliders at bottom. Use useAppStore or create local state for form values. Call window.api.settings.get() on mount, window.api.settings.set() on save. Display provider status indicator (green dot for connected, red for disconnected) using window.api.ai.getProviderStatus() from electron/preload.ts:63. Reference existing CaptureInterface at src/components/capture/CaptureInterface.tsx:1-289 for component structure patterns.",
            "status": "pending",
            "testStrategy": "Render component, verify AI tab displays with all UI elements. Select different providers, verify correct model options shown. Enter API key for OpenAI, click Test Connection, verify success/failure toast. Change timeout slider, verify value updates. Save settings, reload app, verify settings persisted. Test Ollama auto-detection on page load.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate settings with ai-service and enable dynamic reconfiguration",
            "description": "Update ai-service.ts to read configuration from settings-store instead of environment variables, and implement settings change handlers to reinitialize AI client",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Modify electron/ai-service.ts:217-232 getProviderConfig() to call getSettings() from settings-store and use stored values as priority over env vars (settings > env > presets). Update electron/ai-service.ts:251-277 initializeClient() to accept optional forceReinit parameter that clears the singleton and recreates client with new config. In electron/ipc-handlers.ts, create handler for settings:set that calls updateSettings() and then aiService.initializeClient(undefined, true) to restart client. Update electron/ai-service.ts:159-203 detectProvider() to check settings-store first before trying auto-detection. Add settings change watcher in settings-store.ts that emits event when settings change (use EventEmitter pattern). Settings should include defaults: timeout: 10s for Ollama, 3s for cloud providers, maxRetries: 3. Ensure existing ai-service.ts exports (lines 949-958) remain unchanged. Follow existing PROVIDER_PRESETS pattern at electron/ai-service.ts:111-144.",
            "status": "pending",
            "testStrategy": "Change AI provider in settings UI, verify ai-service reinitializes with new provider. Test API calls use new settings (timeout, model). Verify Ollama detection still works when settings have no provider set. Test settings persist after app restart and ai-service loads them correctly. Verify env vars still work as fallback when settings are empty.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "29",
        "title": "Quick Model Switcher in Capture Interface",
        "description": "Add model selector dropdown to CaptureInterface header for quick switching between configured AI models without navigating to Settings",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "28"
        ],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": "30",
        "title": "Recommended Ollama Models for Medical Extraction",
        "description": "Research, document, and configure optimal Ollama models for medical concept extraction - one GPU-optimized model and one lightweight CPU model",
        "details": "Research and configure medical-optimized models:\n\n1. GPU MODEL (Heavy Hitter):\n- Research options: meditron:70b, medllama2:13b, llama3:70b, mixtral:8x22b\n- Evaluate on medical terminology extraction accuracy\n- Document VRAM requirements\n- Add to PROVIDER_PRESETS as 'ollama-medical-gpu'\n\n2. CPU MODEL (Lightweight):\n- Research options: phi3:mini, llama3.2:3b, qwen2:1.5b, gemma2:2b\n- Must run on 8GB RAM laptop\n- Acceptable accuracy for basic extraction\n- Add to PROVIDER_PRESETS as 'ollama-medical-cpu'\n\n3. MODEL DOWNLOAD HELPER:\n- Add 'Download recommended models' button in Settings\n- Executes: ollama pull [model]\n- Shows download progress\n- IPC handler: ai:downloadModel(modelName)\n\n4. AUTO-SELECT LOGIC:\n- Detect available VRAM via Electron\n- If >8GB VRAM: default to GPU model\n- If <8GB VRAM: default to CPU model\n- User can override in settings\n\n5. DOCUMENTATION:\n- Add docs/AI-MODELS.md with recommendations\n- Include benchmark results\n- Installation instructions\n\nPROMPT OPTIMIZATION:\n- Test prompts with each model\n- Adjust extractConcepts prompt for smaller models\n- May need more explicit instructions for lightweight models",
        "testStrategy": "Download recommended GPU model, run extraction on medical text, verify quality. Download CPU model, run same test, compare. Test on machine with <8GB VRAM, verify CPU model auto-selected. Test download progress UI.",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and document recommended Ollama models for medical extraction",
            "description": "Research GPU-optimized and CPU-optimized Ollama models suitable for medical concept extraction, documenting VRAM requirements, accuracy benchmarks, and installation instructions",
            "dependencies": [],
            "details": "Create comprehensive documentation file docs/AI-MODELS.md with:\n\n1. GPU MODEL RECOMMENDATIONS:\n- Research meditron:70b, medllama2:13b, llama3:70b, mixtral:8x22b\n- Document VRAM requirements for each model\n- Test extraction quality on sample medical text (e.g., 'DDx for chest pain')\n- Benchmark accuracy for medical terminology extraction\n- Recommend best GPU model based on accuracy vs. resource tradeoffs\n\n2. CPU MODEL RECOMMENDATIONS:\n- Research phi3:mini, llama3.2:3b, qwen2:1.5b, gemma2:2b\n- Verify each model runs on 8GB RAM laptop\n- Test extraction quality with same sample medical text\n- Document acceptable accuracy degradation vs. GPU models\n- Recommend best lightweight CPU model\n\n3. DOCUMENTATION STRUCTURE:\n- Overview of why model selection matters\n- GPU model section: name, VRAM requirement, accuracy rating, use case\n- CPU model section: name, RAM requirement, accuracy rating, use case\n- Installation instructions: ollama pull commands\n- Benchmark results table comparing extraction quality\n- Prompt optimization notes for each model type\n\nFile location: docs/AI-MODELS.md\nReference existing PROVIDER_PRESETS in electron/ai-service.ts:111-144",
            "status": "pending",
            "testStrategy": "Review docs/AI-MODELS.md for completeness. Verify all recommended models exist in Ollama registry. Test installation commands work. Validate VRAM/RAM requirements are accurate.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add GPU and CPU model presets to PROVIDER_PRESETS configuration",
            "description": "Extend PROVIDER_PRESETS in ai-service.ts with two new Ollama configurations: ollama-medical-gpu for high-performance systems and ollama-medical-cpu for resource-constrained systems",
            "dependencies": [
              1
            ],
            "details": "Update electron/ai-service.ts PROVIDER_PRESETS object:\n\n1. ADD GPU PRESET (based on research from subtask 1):\n```typescript\n'ollama-medical-gpu': {\n  type: 'openai-compatible',\n  baseURL: 'http://localhost:11434/v1',\n  apiKey: 'ollama',\n  model: '[selected-gpu-model]', // e.g., 'llama3:70b' or 'meditron:70b'\n  timeout: 60000, // 60s for large models\n  isLocal: true,\n}\n```\n\n2. ADD CPU PRESET (based on research from subtask 1):\n```typescript\n'ollama-medical-cpu': {\n  type: 'openai-compatible',\n  baseURL: 'http://localhost:11434/v1',\n  apiKey: 'ollama',\n  model: '[selected-cpu-model]', // e.g., 'phi3:mini' or 'llama3.2:3b'\n  timeout: 45000, // 45s for lightweight models\n  isLocal: true,\n}\n```\n\n3. UPDATE TYPE DEFINITIONS:\n- Update AIProviderType in src/types/ai.ts:13 to include 'ollama-medical-gpu' | 'ollama-medical-cpu'\n- Ensure backward compatibility with existing 'ollama' preset\n\n4. ADJUST PROMPTS IF NEEDED:\n- Test PROMPTS.conceptExtraction (line 363) with lightweight models\n- Add model-specific prompt variations if smaller models need more explicit instructions\n\nFiles to modify:\n- electron/ai-service.ts (PROVIDER_PRESETS and possibly PROMPTS)\n- src/types/ai.ts (AIProviderType)",
            "status": "pending",
            "testStrategy": "Verify TypeScript compiles without errors. Test both presets with sample medical content extraction. Confirm GPU preset works with high VRAM model, CPU preset works with lightweight model. Validate timeout values are appropriate.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement model download helper with IPC handlers and progress UI",
            "description": "Create IPC handler for downloading Ollama models via 'ollama pull' command, add download button to settings interface, and show real-time download progress to user",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement model download functionality across Electron main and renderer processes:\n\n1. ELECTRON IPC HANDLER (electron/ipc-handlers.ts):\n- Add handler: ipcMain.handle('ai:downloadModel', async (_, modelName: string))\n- Execute: spawn('ollama', ['pull', modelName])\n- Stream stdout/stderr to track download progress\n- Parse Ollama progress output (e.g., 'downloading layer X/Y')\n- Return progress updates via IPC streaming or polling pattern\n- Handle errors: Ollama not installed, network issues, invalid model name\n\n2. PRELOAD BRIDGE (electron/preload.ts):\n- Add ai.downloadModel(modelName: string): Promise<void>\n- Add ai.onDownloadProgress(callback: (progress: number) => void)\n\n3. TYPE DEFINITIONS (src/types/electron.d.ts):\n- Extend ElectronAPI interface with downloadModel method\n- Define DownloadProgress type with percentage and status\n\n4. SETTINGS UI (create src/components/settings/ModelDownloader.tsx):\n- Display recommended GPU and CPU models from docs/AI-MODELS.md\n- 'Download' button next to each model\n- Progress bar showing download percentage\n- Toast notifications for success/failure\n- Disable button while downloading\n- Show installed models with checkmark\n\n5. INTEGRATE INTO APP:\n- Add ModelDownloader component to settings/preferences view\n- Position near AI provider configuration\n\nFiles to create/modify:\n- electron/ipc-handlers.ts (new handler)\n- electron/preload.ts (new API method)\n- src/types/electron.d.ts (type definitions)\n- src/components/settings/ModelDownloader.tsx (new component)",
            "status": "pending",
            "testStrategy": "Test download flow: click 'Download' button for recommended GPU model, verify progress bar updates, confirm model appears in Ollama after completion. Test error cases: Ollama not running, invalid model name, network disconnection. Verify toast messages show appropriate feedback.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement auto-select logic based on available system VRAM",
            "description": "Detect available GPU VRAM at startup using Electron system APIs, automatically select GPU or CPU model preset based on memory availability, and allow user override in settings",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add intelligent model selection based on system capabilities:\n\n1. VRAM DETECTION (electron/ai-service.ts):\n- Create async function detectSystemVRAM(): Promise<number>\n- Use Electron's screen.getPrimaryDisplay() for basic GPU info\n- For Windows: execute 'wmic path win32_VideoController get AdapterRAM' via child_process\n- For macOS: execute 'system_profiler SPDisplaysDataType' and parse VRAM\n- For Linux: read /proc/driver/nvidia/gpus/*/information or use lspci\n- Return VRAM in GB (0 if detection fails)\n- Cache result to avoid repeated system calls\n\n2. AUTO-SELECT LOGIC (electron/ai-service.ts):\n- Update detectProvider() or create detectOptimalProvider()\n- Call detectSystemVRAM() on first initialization\n- If VRAM >= 8GB: default to 'ollama-medical-gpu'\n- If VRAM < 8GB: default to 'ollama-medical-cpu'\n- If detection fails: default to existing 'ollama' preset\n- Log selection reasoning to console\n\n3. USER OVERRIDE (add to settings UI):\n- Display detected VRAM amount in settings\n- Show auto-selected model preset with explanation\n- Dropdown to manually override: 'Auto-detect' | 'GPU Model' | 'CPU Model'\n- Save preference to localStorage or config file\n- Respect user override in getProviderConfig()\n\n4. IPC HANDLERS:\n- Add 'ai:getSystemInfo' handler returning { vram: number, autoSelectedProvider: string }\n- Add 'ai:setProviderOverride' handler for user preference\n\n5. SETTINGS DISPLAY:\n- Show: 'Detected VRAM: X GB → Using [model-name]'\n- Allow override with explanation of tradeoffs\n\nFiles to modify:\n- electron/ai-service.ts (detection and auto-select logic)\n- electron/ipc-handlers.ts (new handlers)\n- src/components/settings/ModelDownloader.tsx (display system info and override option)",
            "status": "pending",
            "testStrategy": "Test on high-VRAM machine (>8GB): verify GPU model auto-selected. Test on low-VRAM machine (<8GB): verify CPU model auto-selected. Test manual override: select CPU model on GPU machine, verify subsequent extractions use CPU model. Test VRAM detection across Windows/macOS/Linux if possible.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "31",
        "title": "BUG FIX: Quick Dump saves to notes table instead of quick_dumps table",
        "description": "QuickDumpModal incorrectly saves content as a regular note instead of to the quick_dumps table, breaking the extraction queue workflow",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:11:06.148Z"
      },
      {
        "id": "32",
        "title": "POST-MVP: Space bar continues to next card after showing answer (auto-grade as Good)",
        "description": "Add convenience feature where pressing Space after answer is visible auto-grades as 'Good' and moves to next card, reducing friction in review flow",
        "details": "CURRENT BEHAVIOR:\n- Space bar shows answer when answerVisible=false\n- Space bar does nothing when answerVisible=true (lines 154-158 in ReviewInterface.tsx)\n- User must press 1-4 keys or click buttons to grade\n\nREQUESTED BEHAVIOR:\n- Space shows answer (unchanged)\n- Space again after answer visible = auto-grade as Rating.Good and move to next card\n- This is a convenience shortcut for 'I knew it' flow\n\nIMPLEMENTATION:\n1. Update keyboard handler in ReviewInterface.tsx lines 154-158\n2. Add else branch: if (answerVisible && !isSubmitting) { handleRating(Rating.Good); }\n3. Consider: should this be configurable? Some users may want Space=Again for harder study\n\nUX CONSIDERATION:\n- This changes Space from 'show answer only' to 'show answer OR grade good'\n- Could cause accidental grading if user double-taps Space\n- Consider adding small delay or different key (Enter) for grade-and-continue\n\nALTERNATIVE APPROACH (Task 5 conflict):\n- Task 5 removes grading buttons entirely and auto-grades based on response time\n- This task may be superseded by Task 5's implementation\n- Mark as deferred until Task 5 design is finalized\n\nNOTE: Marking as post-MVP since Task 5 (zero-decision review) may make this unnecessary.",
        "testStrategy": "Review card, press Space to show answer, press Space again, verify card grades as Good and moves to next. Test rapid double-Space doesn't skip cards. Verify works with keyboard only (no mouse).",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "33",
        "title": "Back button with navigation history persistence",
        "description": "Add a back button allowing users to return to their previous screen with state persistence",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": "34",
        "title": "Modern cloze UI with click-based creation and cleaner review display",
        "description": "Replace {{c1::}} syntax with intuitive click/select-based cloze creation and modern review rendering",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": "35",
        "title": "[v2-T1] Data model v3: SourceItem, CanonicalTopic, NotebookTopicPage, SmartView schemas",
        "description": "Implement the v2 architecture data model with new tables for 3-layer system: Knowledge Bank (SourceItem), Notebook (NotebookTopicPage, NotebookBlock), and enhanced Cards with provenance. Add CanonicalTopic for topic normalization and SmartView for filtered access.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces for v3 data model",
            "description": "Create TypeScript interfaces in src/types/index.ts for SourceItem, CanonicalTopic, NotebookTopicPage, NotebookBlock, SmartView, and SmartViewFilter. Update Card interface with optional provenance fields.",
            "dependencies": [],
            "details": "Add to src/types/index.ts:\n\n1. SourceType = 'qbank' | 'article' | 'pdf' | 'image' | 'audio' | 'quickcapture' | 'manual'\n2. SourceItemStatus = 'inbox' | 'processed' | 'curated'\n3. SourceItem interface with all fields (id, sourceType, sourceName, sourceUrl, title, rawContent, mediaPath, transcription, canonicalTopicIds as string[], tags as string[], questionId, status, createdAt, processedAt, updatedAt)\n4. CanonicalTopic interface (id, canonicalName, aliases as string[], domain, parentTopicId, createdAt)\n5. NotebookTopicPage interface (id, canonicalTopicId, cardIds as string[], createdAt, updatedAt)\n6. NotebookBlock interface (id, notebookTopicPageId, sourceItemId, content, annotations, mediaPath, position)\n7. SmartViewFilter interface with domain, tags, status, createdAfter, createdBefore fields\n8. SmartView interface (id, name, icon, filter as SmartViewFilter, sortBy, isSystem)\n9. Update Card interface: add notebookTopicPageId?: string and sourceBlockId?: string (optional for backwards compat)\n\nAll new types exported from index.ts. Follow existing pattern with JSON array fields stored as string[] in TypeScript layer.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes. Ensure all new types are properly exported. Check that Card interface extension maintains backwards compatibility with existing card objects.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create database schema v3 with migration from v2",
            "description": "Implement new tables (source_items, canonical_topics, notebook_topic_pages, notebook_blocks, smart_views) in electron/database.ts with migration from schema v2 to v3.",
            "dependencies": [
              1
            ],
            "details": "In electron/database.ts:\n\n1. Create migrateToV3() function following migrateToV2 pattern with backup/restore safety\n2. Add source_items table: id TEXT PRIMARY KEY, sourceType TEXT, sourceName TEXT, sourceUrl TEXT, title TEXT, rawContent TEXT, mediaPath TEXT, transcription TEXT, canonicalTopicIds TEXT (JSON), tags TEXT (JSON), questionId TEXT, status TEXT DEFAULT 'inbox', createdAt TEXT, processedAt TEXT, updatedAt TEXT\n3. Add canonical_topics table: id TEXT PRIMARY KEY, canonicalName TEXT UNIQUE, aliases TEXT (JSON), domain TEXT, parentTopicId TEXT FK, createdAt TEXT\n4. Add notebook_topic_pages table: id TEXT PRIMARY KEY, canonicalTopicId TEXT FK, cardIds TEXT (JSON), createdAt TEXT, updatedAt TEXT\n5. Add notebook_blocks table: id TEXT PRIMARY KEY, notebookTopicPageId TEXT FK, sourceItemId TEXT FK, content TEXT, annotations TEXT, mediaPath TEXT, position INTEGER\n6. Add smart_views table: id TEXT PRIMARY KEY, name TEXT, icon TEXT, filter TEXT (JSON), sortBy TEXT, isSystem INTEGER\n7. ALTER TABLE cards ADD COLUMN notebookTopicPageId TEXT, ADD COLUMN sourceBlockId TEXT (nullable for existing cards)\n8. Create indexes: idx_source_items_status, idx_source_items_sourceType, idx_canonical_topics_domain, idx_notebook_blocks_page, idx_cards_notebook_page\n9. Migrate existing quick_dumps to source_items with sourceType='quickcapture', status='inbox', map content→rawContent, createdAt→createdAt\n10. Call migrateToV3 in initDatabase() when version < 3, set version to 3 after successful migration\n\nUse transactions for safety, follow existing columnExists/tableExists pattern.",
            "status": "pending",
            "testStrategy": "Open database in SQLite browser after migration, verify all 5 new tables exist with correct schemas. Check indexes via EXPLAIN QUERY PLAN. Verify existing cards table has new nullable columns. Verify existing quick_dumps migrated to source_items with correct field mappings. Test migration rollback on simulated failure.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CRUD functions for new tables",
            "description": "Add database query functions for SourceItem, NotebookTopicPage, NotebookBlock, CanonicalTopic, and SmartView in electron/database.ts following existing pattern.",
            "dependencies": [
              2
            ],
            "details": "In electron/database.ts, add query objects following cardQueries/noteQueries pattern:\n\n1. sourceItemQueries:\n   - getAll(): DbSourceItem[]\n   - getByStatus(status: SourceItemStatus): DbSourceItem[]\n   - getById(id: string): DbSourceItem | null\n   - insert(item: DbSourceItem): void\n   - update(id: string, updates: Partial<DbSourceItem>): void\n   - delete(id: string): void\n   Include parseSourceItemRow() to handle JSON fields (canonicalTopicIds, tags)\n\n2. notebookTopicPageQueries:\n   - getAll(): DbNotebookTopicPage[]\n   - getById(id: string): DbNotebookTopicPage | null\n   - insert(page: DbNotebookTopicPage): void\n   - update(id: string, updates: Partial<DbNotebookTopicPage>): void\n   Include parseNotebookTopicPageRow() for cardIds JSON array\n\n3. notebookBlockQueries:\n   - getByPage(pageId: string): DbNotebookBlock[]\n   - insert(block: DbNotebookBlock): void\n   - update(id: string, updates: Partial<DbNotebookBlock>): void\n   - delete(id: string): void\n\n4. canonicalTopicQueries:\n   - getAll(): DbCanonicalTopic[]\n   - getByDomain(domain: string): DbCanonicalTopic[]\n   Include parseCanonicalTopicRow() for aliases JSON array\n\n5. smartViewQueries:\n   - getAll(): DbSmartView[]\n   - getSystemViews(): DbSmartView[]\n   Include parseSmartViewRow() for filter JSON object\n\n6. seedSystemSmartViews() function called in initDatabase():\n   Create 7 system views: Inbox (status=inbox), Today (dueDate=today), Queue (state=0), Notebook (all notebook pages), Topics (group by topic), Stats (analytics), Weak Topics (low accuracy)\n\nDefine DbSourceItem, DbNotebookTopicPage, DbNotebookBlock, DbCanonicalTopic, DbSmartView interfaces matching db schema.",
            "status": "pending",
            "testStrategy": "Write unit tests for each CRUD operation. Test sourceItemQueries with all status values. Test notebookBlockQueries.getByPage with multiple blocks. Test canonicalTopicQueries.getByDomain filtering. Verify JSON fields correctly serialized/deserialized. Test seedSystemSmartViews creates exactly 7 views on fresh db.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Wire IPC handlers for new CRUD operations",
            "description": "Register IPC handlers in ipc-handlers.ts, expose via preload.ts, and declare types in electron.d.ts for all new database operations.",
            "dependencies": [
              3
            ],
            "details": "1. In electron/ipc-handlers.ts, add handlers following existing pattern:\n   - sourceItems:getAll, sourceItems:getByStatus, sourceItems:getById, sourceItems:create, sourceItems:update, sourceItems:remove\n   - notebookPages:getAll, notebookPages:getById, notebookPages:create, notebookPages:update\n   - notebookBlocks:getByPage, notebookBlocks:create, notebookBlocks:update, notebookBlocks:remove\n   - canonicalTopics:getAll, canonicalTopics:getByDomain\n   - smartViews:getAll, smartViews:getSystem\n   All handlers wrap in IpcResult<T> using success/failure helpers\n\n2. In electron/preload.ts, expose via contextBridge:\n   - window.api.sourceItems object with all methods\n   - window.api.notebookPages object\n   - window.api.notebookBlocks object\n   - window.api.canonicalTopics object\n   - window.api.smartViews object\n   Each method invokes corresponding IPC channel using ipcRenderer.invoke\n\n3. In src/types/electron.d.ts, extend ElectronAPI interface:\n   - Add sourceItems, notebookPages, notebookBlocks, canonicalTopics, smartViews with full method signatures\n   - Return types use IpcResult<SourceItem>, IpcResult<NotebookTopicPage>, etc.\n   - Import new types from './index'\n\nFollow exact pattern from existing cards/notes/quickDumps handlers for consistency.",
            "status": "pending",
            "testStrategy": "Build application, verify TypeScript compilation. Test each IPC call from renderer DevTools console (window.api.sourceItems.getAll(), etc.). Verify error handling returns proper IpcResult with error field. Test status filtering for sourceItems. Verify all methods properly typed in electron.d.ts with autocomplete working.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update test helpers with new schema",
            "description": "Add new table creation to tests/helpers/db-helpers.ts ensuring test database schema matches production v3 schema.",
            "dependencies": [
              2
            ],
            "details": "If tests/helpers/db-helpers.ts exists, update it:\n\n1. Add source_items table creation in test schema initialization\n2. Add canonical_topics table creation\n3. Add notebook_topic_pages table creation  \n4. Add notebook_blocks table creation\n5. Add smart_views table creation\n6. Update cards table schema to include notebookTopicPageId and sourceBlockId columns\n7. Add all indexes matching production schema\n8. Ensure foreign key constraints match production\n9. Add helper functions: createTestSourceItem(), createTestNotebookPage(), createTestCanonicalTopic() for test data fixtures\n10. Set schema version to 3 in test initialization\n\nIf db-helpers.ts doesn't exist, create basic structure with schema matching electron/database.ts after v3 migration.\n\nTest schema must be identical to production to catch schema mismatch bugs early.",
            "status": "pending",
            "testStrategy": "Run existing test suite, verify all tests pass with new schema. Compare test schema with production schema field-by-field. Test helper fixture functions create valid test data. Verify foreign key constraints work in test environment. Check that test database version pragma shows 3.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "36",
        "title": "[v2-T1.1] Topic normalization: alias table, matching rules, dedupe prevention",
        "description": "Implement topic alias matching system that normalizes user input to canonical topics. 'HOCM', 'HCM', 'hypertrophic cardiomyopathy' should all resolve to the same CanonicalTopic.",
        "details": "CORE FUNCTIONS in electron/topic-service.ts:\n\n1. resolveTopicAlias(input: string): Promise<CanonicalTopic | null>\n- Normalize input (lowercase, trim)\n- Check canonicalName exact match first\n- Then check aliases array (case-insensitive)\n- Return matched CanonicalTopic or null\n\n2. createOrGetTopic(name: string, domain?: string): Promise<CanonicalTopic>\n- Try resolveTopicAlias first\n- If found, return existing topic\n- If not found, create new CanonicalTopic with name as canonicalName\n- Auto-generate common aliases (lowercase, acronyms)\n\n3. suggestTopicMatches(input: string): Promise<CanonicalTopic[]>\n- Fuzzy search across canonicalName and aliases\n- Return top 5 matches sorted by similarity\n- Use for autocomplete/typeahead\n\n4. addTopicAlias(topicId: string, alias: string): Promise<void>\n- Add alias to existing topic's aliases array\n- Prevent duplicates\n- Check alias doesn't belong to another topic\n\n5. mergeTopics(sourceId: string, targetId: string): Promise<void>\n- Move all aliases from source to target\n- Update all source_items referencing source topic\n- Update all notebook_topic_pages\n- Delete source topic\n\nIPC HANDLERS:\n- topic:resolve, topic:createOrGet, topic:suggest, topic:addAlias, topic:merge\n\nUI AUTOCOMPLETE:\n- When user types topic name, show suggestions\n- Allow creating new topic if no match\n- Show alias count/common aliases in dropdown",
        "testStrategy": "Test 'HOCM' resolves to same topic as 'Hypertrophic Cardiomyopathy'. Test fuzzy search finds 'cardio' matches 'cardiology'. Test merge preserves all references. Test dedupe prevents same alias on multiple topics.",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "37",
        "title": "[v2-T1.2] Metadata schema: minimal fields, AI templates per source type",
        "description": "Define minimal required metadata fields per source type and create AI prompt templates for extracting/suggesting metadata from raw content.",
        "details": "METADATA TEMPLATES per sourceType:\n\n1. qbank:\n- Required: questionId, sourceName (UWorld/AMBOSS/etc)\n- AI extract: topic, key concept, correct answer rationale\n\n2. article:\n- Required: title, sourceUrl or sourceName\n- AI extract: main topic, key takeaways, publication year\n\n3. pdf:\n- Required: title\n- AI extract: document type (textbook/guidelines/paper), main topics\n\n4. image:\n- Required: title (AI-suggested from context/filename)\n- AI extract: image type (diagram/photo/chart), labeled structures\n\n5. audio:\n- Required: title\n- AI extract: main topics from transcription (deferred)\n\n6. quickcapture:\n- Required: none (raw dump)\n- AI extract: auto-detect content type, suggest title, tags\n\n7. manual:\n- Required: title\n- AI extract: topic, format suggestions\n\nIMPLEMENTATION in electron/ai-service.ts:\n\n- Add function: suggestSourceMetadata(content: string, sourceType: SourceType): Promise<SuggestedMetadata>\n- SuggestedMetadata = { title, topics: string[], tags: string[], questionId?, sourceUrl? }\n- Use source-type-specific prompts\n- Return confidence scores for each suggestion\n\nUI INTEGRATION:\n- On paste/import, call suggestSourceMetadata\n- Pre-fill form with AI suggestions\n- User can edit before single Save",
        "testStrategy": "Test qbank paste extracts questionId and topic. Test article URL extracts title. Test quick capture with mixed content gets reasonable title suggestion. Verify confidence scores help user decide whether to accept.",
        "priority": "medium",
        "dependencies": [
          "35"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "38",
        "title": "[v2-T2] Capture pipeline: Quick Dump → SourceItem (inbox), text + image support",
        "description": "Implement capture flow that creates SourceItems in Knowledge Bank with inbox status. Support text paste and image paste/drop.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update QuickDumpModal to create SourceItems instead of QuickDumps",
            "description": "Refactor QuickDumpModal.tsx to use sourceItems.create API, mapping text content to SourceItem schema with sourceType='quickcapture' and status='inbox'.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T02:38:03.709Z"
          },
          {
            "id": 2,
            "title": "Add image paste/drop support to QuickDumpModal",
            "description": "Implement clipboard paste and drag-drop handlers for images in QuickDumpModal, with visual preview and content type detection.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T02:54:36.818Z"
          },
          {
            "id": 3,
            "title": "Implement image file storage and mediaPath handling",
            "description": "Create IPC handler for saving image files to app data directory and returning relative path for mediaPath field.",
            "dependencies": [
              2
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T03:15:27.734Z"
          },
          {
            "id": 4,
            "title": "Add inboxCount state management to useAppStore",
            "description": "Extend useAppStore with inboxCount state that queries source_items table for items with status='inbox', and refreshes after captures.",
            "dependencies": [
              1
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2026-01-06T02:33:30.360Z",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Wire Sidebar to display inbox badge count from useAppStore",
            "description": "Connect Sidebar component to useAppStore.inboxCount and replace hardcoded inboxCount=0 with live state.",
            "dependencies": [
              4
            ],
            "details": "",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-06T02:33:30.460Z"
          }
        ],
        "updatedAt": "2026-01-06T03:15:27.734Z"
      },
      {
        "id": "39",
        "title": "[v2-T2.1] Inbox UI: persistent indicator, count badge, batch triage actions",
        "description": "Add persistent inbox indicator in sidebar showing count of unprocessed items. Enable batch selection and triage actions.",
        "details": "SIDEBAR INBOX VIEW:\n\n1. INBOX COUNT BADGE:\n- Show count next to Inbox in Smart Views sidebar\n- Update in real-time when items added/processed\n- Visual emphasis when count > 0 (dot indicator)\n\n2. INBOX LIST VIEW:\n- Vertical list grouped by date (Today, Yesterday, Earlier)\n- Each row shows: icon, title, source type, tags, time ago\n- Primary action: 'Add to Notebook'\n- Secondary action: 'Open' (view full content)\n- Destructive: delete (icon + confirm)\n\n3. BATCH ACTIONS:\n- Checkbox selection for multiple items\n- Select all / deselect all\n- Batch 'Add to Notebook' (select topic for all)\n- Batch delete (with confirmation)\n- Batch tag assignment\n\n4. FILTER/SORT:\n- Filter by source type\n- Sort by date (newest/oldest)\n- Search within inbox\n\nCOMPONENTS:\n\n- src/components/knowledgebank/InboxView.tsx\n- src/components/knowledgebank/SourceItemRow.tsx\n- src/components/knowledgebank/BatchActions.tsx\n\nSTORE ACTIONS in useAppStore:\n- inboxCount: number (derived from sourceItems)\n- selectedInboxItems: Set<string>\n- toggleInboxSelection, selectAllInbox, clearInboxSelection\n- batchAddToNotebook, batchDeleteInbox",
        "testStrategy": "Add 5 items via Quick Dump, verify inbox badge shows 5. Select 3 items, batch add to notebook, verify badge shows 2. Test batch delete. Test filter by source type.",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "40",
        "title": "[v2-T3] Knowledge Bank UI: vertical list grouped by status, search, filters",
        "description": "Build the main Knowledge Bank view showing all SourceItems organized by status with filtering and search capabilities.",
        "details": "KNOWLEDGE BANK VIEW:\n\n1. STATUS GROUPS:\n- Inbox (status='inbox') - top priority, most prominent\n- Processed (status='processed') - middle section\n- Curated (status='curated') - items added to Notebook\n\n2. LIST LAYOUT (Vertical):\n- Icon by source type (📄 text, 🖼️ image, 🎤 audio, ⚡ quick)\n- Title (AI-generated or user-edited)\n- Tags as pills\n- Topic link (if assigned)\n- Relative time\n- Actions: [Add to Notebook ▼] [Open] [🗑️]\n\n3. SEARCH:\n- Search box at top\n- Searches: title, rawContent, tags, topic names\n- Real-time filtering as user types\n- <200ms response time\n\n4. FILTERS:\n- By status (multi-select)\n- By source type (multi-select)\n- By topic (dropdown)\n- By tag (dropdown)\n- By date range\n\n5. SORT OPTIONS:\n- Newest first (default)\n- Oldest first\n- Alphabetical\n- By topic\n\nCOMPONENTS:\n\n- src/components/knowledgebank/KnowledgeBankView.tsx (main view)\n- src/components/knowledgebank/StatusGroup.tsx\n- src/components/knowledgebank/FilterBar.tsx\n- src/components/knowledgebank/SourceItemRow.tsx (reuse from T2.1)\n\nNO CARD CREATION HERE:\n- 'Add to Notebook' is the only path to cards\n- No 'Create Card' button in Knowledge Bank",
        "testStrategy": "Add items of various types and statuses. Verify grouping correct. Test search finds content in rawContent. Test filters narrow results correctly. Verify <200ms search response.",
        "priority": "high",
        "dependencies": [
          "39"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "41",
        "title": "[v2-T4] Notebook UI: topic pages, add blocks from sources, enforce card-creation here only",
        "description": "Build the Notebook layer with topic pages containing blocks from Knowledge Bank. This is the ONLY place where cards can be created.",
        "details": "NOTEBOOK VIEW:\n\n1. TOPIC PAGE LIST:\n- Sidebar or list showing all NotebookTopicPages\n- Show: topic name, aliases, card count, source count\n- Search/filter by topic name\n- 'New Topic Page' button\n\n2. TOPIC PAGE VIEW:\n- Header: Topic name, aliases, stats\n- Blocks section: excerpts from SourceItems\n- Each block shows:\n  - Source reference (clickable deep link)\n  - Content excerpt\n  - Annotations (user notes)\n  - Actions: [Edit] [→ Source] [Generate Card]\n- Footer: [+ Add from Knowledge Bank] [Generate All Cards]\n\n3. ADD BLOCK FLOW:\n- Click '+ Add from Knowledge Bank'\n- Modal shows Knowledge Bank filtered to curated/processed\n- Select source item\n- Select excerpt (highlight text) or use full content\n- Save creates NotebookBlock linked to source\n- SourceItem status → 'curated'\n\n4. BLOCK MANAGEMENT:\n- Drag to reorder blocks (position field)\n- Edit block content (excerpt)\n- Add annotations\n- Delete block (doesn't delete source)\n\nCARD CREATION ENFORCED:\n- 'Generate Card' button ONLY appears on blocks\n- No card creation in Knowledge Bank\n- No card creation from scratch\n- All cards have notebookTopicPageId (enforced)\n\nCOMPONENTS:\n\n- src/components/notebook/NotebookView.tsx\n- src/components/notebook/TopicPageList.tsx\n- src/components/notebook/TopicPageView.tsx\n- src/components/notebook/NotebookBlock.tsx\n- src/components/notebook/AddBlockModal.tsx",
        "testStrategy": "Create topic page, add block from source, verify deep link works. Generate card from block, verify card has notebookTopicPageId. Verify no way to create card outside Notebook.",
        "priority": "high",
        "dependencies": [
          "40",
          "36"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "42",
        "title": "[v2-T4.1] Card generation from notebook: AI suggests, card-worthiness gate",
        "description": "Implement AI-powered card generation from Notebook blocks with card-worthiness evaluation before creation.",
        "details": "CARD GENERATION FLOW:\n\n1. USER INITIATES:\n- Click 'Generate Card' on a block\n- Or 'Generate All Cards' for entire topic page\n\n2. AI CARD SUGGESTION:\n- Call AI to analyze block content\n- Suggest card format (Q&A, cloze, vignette)\n- Generate front/back content\n- Return multiple card suggestions if content-rich\n\n3. CARD-WORTHINESS GATE (T5):\n- Before showing card to user, evaluate:\n  - Board-relevant? (high-yield for Step 2/3)\n  - Testable? (clear right answer)\n  - Discriminative? (distinguishes from similar concepts)\n- Show AI assessment with checkmarks/warnings\n- Recommendation: CREATE CARD / KEEP AS NOTE ONLY\n\n4. USER DECISION:\n- [Create Card] - proceeds with creation\n- [Keep as Note Only] - doesn't create card, marks block\n- [Edit First] - allows editing before creation\n- [Discard] - cancels without saving\n\n5. CARD CREATION:\n- Create card with:\n  - notebookTopicPageId (required)\n  - sourceBlockId (specific block)\n  - tags from topic\n  - FSRS defaults\n- Update NotebookTopicPage.cardIds array\n\nCOMPONENTS:\n\n- src/components/notebook/CardGenerationModal.tsx\n- src/components/notebook/CardWorthinessGate.tsx\n- src/components/notebook/CardSuggestionPreview.tsx\n\nAI FUNCTIONS in electron/ai-service.ts:\n- generateCardFromBlock(blockContent: string, topicContext: string): Promise<CardSuggestion[]>\n- evaluateCardWorthiness(card: CardSuggestion): Promise<WorthinessAssessment>",
        "testStrategy": "Generate card from medical fact block, verify AI suggests appropriate format. Test worthiness gate shows correct assessments. Test 'Keep as Note Only' doesn't create card. Verify all created cards have required provenance fields.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "43",
        "title": "[v2-T5] Card-worthiness gate: rubric (board-relevant? testable? discriminative?), UI",
        "description": "Implement the full card-worthiness evaluation rubric that gates all card creation to minimize low-yield cards.",
        "details": "WORTHINESS RUBRIC:\n\n1. BOARD-RELEVANT:\n- Is this high-yield for Step 2/3 or specialty boards?\n- AI checks against known high-yield topics\n- Weight: High\n\n2. TESTABLE:\n- Does this have a clear, unambiguous answer?\n- Avoid opinion-based or 'it depends' content\n- Weight: High\n\n3. DISCRIMINATIVE:\n- Does this distinguish from similar concepts?\n- Avoid cards that could apply to multiple conditions\n- Weight: Medium\n\n4. MINIMUM INFORMATION:\n- Single concept per card?\n- Not testing multiple facts at once?\n- Weight: High\n\n5. NO PATTERN MATCHING:\n- Answer not giveaway from card format?\n- Could be rephrased and still work?\n- Weight: Medium\n\nSCORING:\n- Each criterion: Pass / Warning / Fail\n- Overall: CREATE / CONSIDER EDITING / NOT RECOMMENDED\n- Show reasoning for each criterion\n\nUI COMPONENT:\n\n```\n┌─ Card Quality Check ─────────────────────────────────┐\n│ \"What is the most specific marker for MI?\"           │\n│ → Troponin I                                         │\n│                                                      │\n│ ✓ Board-relevant (high-yield for Step 2/3)           │\n│ ✓ Testable (clear right answer)                      │\n│ ✓ Discriminative (distinguishes troponin vs CK-MB)   │\n│ ✓ Minimum information (single fact)                  │\n│ ⚠️ Consider: Add 'why' for deeper learning           │\n│                                                      │\n│ Recommendation: ✅ CREATE CARD                       │\n│                                                      │\n│ [Create] [Keep Note] [Edit] [Discard]                │\n└──────────────────────────────────────────────────────┘\n```\n\nAI IMPLEMENTATION:\n- evaluateCardWorthiness(card) returns WorthinessAssessment\n- WorthinessAssessment has criteria[], overallRecommendation, suggestions[]",
        "testStrategy": "Test high-yield card passes all criteria. Test vague card gets warnings. Test multi-fact card fails minimum info. Test pattern-matching card gets warning. Verify recommendations match rubric logic.",
        "priority": "high",
        "dependencies": [
          "42"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "44",
        "title": "[v2-T8] Smart Views: system views (Inbox, Today, Queue, Weak Topics), filter engine",
        "description": "Implement Smart Views system with preset system views and a reusable filter engine for dynamic list filtering.",
        "details": "SYSTEM SMART VIEWS:\n\n1. INBOX (📥):\n- Filter: status='inbox'\n- Badge: count\n- Default sort: newest first\n\n2. TODAY (📅):\n- Filter: due cards (due <= today) + recent captures (createdAt = today)\n- Badge: combined count\n- Sections: 'Due for Review', 'Captured Today'\n\n3. QUEUE (📋):\n- Filter: sourceType='quickcapture' AND status='inbox'\n- Badge: count\n- Quick dumps pending processing\n\n4. NOTEBOOK (📚):\n- Shows all NotebookTopicPages\n- No filter, just different view type\n\n5. TOPICS (🏷️):\n- CanonicalTopic browser\n- Hierarchical if parentTopicId used\n- Show card counts per topic\n\n6. STATS (📊):\n- Dashboard view (deferred content)\n\n7. WEAK TOPICS (⚠️):\n- Topics where cards have low ease (< 2.0 average)\n- Badge: count of weak topics\n- Helps identify knowledge gaps\n\nFILTER ENGINE:\n\n```typescript\ninterface SmartViewFilter {\n  status?: string[];           // ['inbox', 'processed']\n  sourceType?: string[];       // ['qbank', 'article']\n  topicIds?: string[];         // specific topics\n  tags?: string[];             // tag matches\n  hasLowEase?: boolean;        // cards with ease < 2.0\n  isBoardMiss?: boolean;       // flagged board questions\n  dateRange?: { start, end };  // created/modified date\n}\n\nfunction applyFilter(items: any[], filter: SmartViewFilter): any[]\n```\n\nSIDEBAR COMPONENT:\n\n- src/components/layout/SmartViewSidebar.tsx\n- Show all system views with badges\n- Click to switch main content view\n- Highlight active view",
        "testStrategy": "Test Inbox shows only inbox items. Test Today combines due cards and today's captures. Test Weak Topics finds low-ease topics. Test filter engine with complex multi-criteria filters.",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "45",
        "title": "[v2-T6] FSRS integration: scheduling fields, review UI, response time tracking",
        "description": "Ensure FSRS integration works with new card provenance model. Track response times for future personalization.",
        "details": "FSRS FIELDS (already in cards table):\n- stability, difficulty, elapsedDays, scheduledDays\n- reps, lapses, state\n- dueDate, lastReview\n\nNEW TRACKING:\n- responseTimeMs in review_logs (already added in Task 1)\n- Track time from card shown to answer revealed\n- Track time from answer revealed to rating\n\nREVIEW UI UPDATES:\n\n1. PROVENANCE DISPLAY:\n- Show source: 'From: [Topic Name]'\n- Click to navigate to NotebookTopicPage\n- Show related cards count\n\n2. ZERO-DECISION FLOW:\n- Show Answer (Space)\n- Continue (Enter) = auto-grade based on response time\n- I Forgot (F) = grade as Again\n- Edit (E) = open card editor\n- Skip (S) = skip without grading\n\n3. LOW-EASE FLAGGING:\n- If card ease < 2.0 after review, flag for attention\n- Show in Weak Topics smart view\n- Suggest 'fix card' flow\n\nRESPONSE TIME LOGIC:\n- Fast correct (< 5s): increase ease slightly\n- Slow correct (> 15s): decrease ease slightly\n- Helps identify cards that need improvement\n\nCOMPONENTS:\n\n- Update src/components/review/ReviewInterface.tsx\n- Add response time tracking\n- Add provenance display\n- Connect to NotebookTopicPage navigation",
        "testStrategy": "Review card, verify response time logged. Test fast answer increases ease. Test slow answer decreases ease. Test low-ease card appears in Weak Topics. Test provenance link navigates correctly.",
        "priority": "high",
        "dependencies": [
          "41",
          "42"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "46",
        "title": "[v2-T6.1] Low-ease detection: flag repeatedly-hard cards, route to fix flow",
        "description": "Detect cards with consistently low ease scores and surface them for improvement through a 'fix card' workflow.",
        "details": "LOW-EASE DETECTION:\n\n1. CRITERIA:\n- Ease factor < 2.0 (default is 2.5)\n- OR lapses > 3 in last 30 days\n- OR response time consistently > 15s\n\n2. FLAGGING:\n- Add lowEaseFlag boolean to cards table (or compute dynamically)\n- Update after each review\n- Clear flag when ease recovers above threshold\n\n3. WEAK TOPICS AGGREGATION:\n- Group flagged cards by topic\n- Count flagged cards per CanonicalTopic\n- Sort topics by flagged card count\n- Show in Weak Topics smart view\n\nFIX CARD FLOW:\n\n1. USER ENTRY:\n- Click 'Fix' on low-ease card during review\n- Or browse Weak Topics and select card\n\n2. FIX OPTIONS:\n- Edit card (simplify, clarify)\n- Split card (if testing multiple concepts)\n- Add context (link to more detailed note)\n- Mark as leech (suspend temporarily)\n- Delete and recreate from Notebook\n\n3. AFTER FIX:\n- Reset FSRS parameters (optional)\n- Card re-enters learning phase\n- Track if fix was successful (ease improvement)\n\nCOMPONENTS:\n\n- src/components/review/FixCardModal.tsx\n- Add 'Fix' button to review UI for low-ease cards\n- Weak Topics view shows fix suggestions",
        "testStrategy": "Create card, fail it 4 times, verify low-ease flag set. Verify card appears in Weak Topics. Test fix flow resets card. Test ease recovery clears flag.",
        "priority": "medium",
        "dependencies": [
          "45"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "47",
        "title": "[v2-T9] UI/UX rules: button hierarchy, destructive confirmations, naming patterns",
        "description": "Establish and enforce consistent UI/UX patterns across all v2 components for button styling, confirmations, and naming.",
        "details": "BUTTON HIERARCHY:\n\n1. PRIMARY (Purple):\n- Main action on any screen\n- Examples: 'Save', 'Create Card', 'Add to Notebook'\n- shadcn: variant='default' with purple theme\n\n2. SECONDARY (Gray):\n- Alternative actions\n- Examples: 'Open', 'Edit', 'Skip'\n- shadcn: variant='outline' or 'secondary'\n\n3. DESTRUCTIVE (Icon + Confirm):\n- Delete operations\n- Icon-only button (🗑️) with hover tooltip\n- Click shows confirmation dialog\n- Never inline delete without confirm\n\n4. GHOST (Text only):\n- Subtle actions\n- Examples: 'Cancel', 'Back'\n- shadcn: variant='ghost'\n\nCONFIRMATION PATTERNS:\n\n- Delete SourceItem: 'Delete this source? Content will be lost.'\n- Delete Card: 'Delete this card? Review history will be lost.'\n- Delete Topic: 'Delete topic and X cards? This cannot be undone.'\n- Batch delete: 'Delete X items? This cannot be undone.'\n\nNAMING CONVENTIONS:\n\n- Use 'Knowledge Bank' not 'Sources' or 'Inbox'\n- Use 'Notebook' not 'Notes' or 'Pages'\n- Use 'Topic' not 'Subject' or 'Category'\n- Use 'Block' not 'Excerpt' or 'Snippet'\n- Use 'Generate Card' not 'Create Card' (implies AI assistance)\n\nKEYBOARD SHORTCUTS:\n\n- Ctrl+K: Command palette\n- Ctrl+Shift+S: Quick Dump\n- Ctrl+1-6: Navigate Smart Views\n- Space: Show answer / Continue\n- Enter: Confirm action\n- Escape: Cancel / Close modal\n- F: Mark as forgotten (review)\n- E: Edit current item\n- Delete/Backspace: Delete (with confirm)\n\nIMPLEMENTATION:\n\n- Create src/components/ui/button-variants.tsx with themed variants\n- Create src/components/ui/ConfirmDialog.tsx reusable component\n- Document patterns in src/styles/design-system.md",
        "testStrategy": "Audit all buttons across app for consistency. Test all delete actions show confirmation. Test keyboard shortcuts work globally. Verify naming consistency in UI.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "48",
        "title": "Research AI context relevance optimization (lost in the middle problem)",
        "description": "Studies show models perform better with 10 highly-relevant files than 50 loosely-related ones. Plan how to optimize file/context selection when querying AI: relevance scoring, chunking strategies, embeddings-based retrieval, quality over quantity.",
        "priority": "low",
        "status": "deferred",
        "tags": [],
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": "49",
        "title": "Personalized response time baselines for FSRS auto-grading",
        "description": "Replace fixed time thresholds (<5s=Easy, 5-15s=Good, etc.) with personalized baselines. Grade relative to user's own response patterns rather than absolute time. Research shows response latency correlates with retrieval strength (Bjork 1994, PMC4480221).",
        "details": "EVIDENCE BASE:\n- Response latency is a valid proxy for retrieval difficulty (PMC4480221)\n- FSRS already uses response time in its 21-parameter personalization model\n- Items strengthen across retrieval attempts even when accuracy unchanged - latency reveals this\n\nIMPLEMENTATION:\n1. Track per-card response time history in review_logs (already storing responseTimeMs from Task 5)\n2. Calculate user-level baseline: median response time across last 100 reviews\n3. Calculate card-level baseline: median response time for this specific card\n4. Grade relative to baseline:\n   - <50% of baseline = Easy (fast for you)\n   - 50-100% of baseline = Good (normal for you)\n   - 100-200% of baseline = Hard (slow for you)\n   - >200% of baseline = Again (struggled)\n5. Cold start: use fixed thresholds until 20+ reviews exist\n6. Weighted recency: recent reviews weighted higher than old ones\n7. Add analytics dashboard showing personal response time trends\n\nFILES TO MODIFY:\n- electron/fsrs-service.ts: Add getPersonalizedBaseline(), calculateRelativeGrade()\n- electron/database.ts: Add reviewLogQueries.getRecentForUser(), getRecentForCard()\n- src/components/review/ReviewInterface.tsx: Use personalized grading when data available",
        "testStrategy": "Create mock review history with varying response times. Verify baseline calculation accuracy. Test cold start fallback to fixed thresholds. Test grade determination relative to baseline. Verify weighted recency favors recent data. Compare auto-grades between fixed and personalized modes.",
        "priority": "medium",
        "status": "pending",
        "tags": [],
        "dependencies": [
          "5"
        ],
        "subtasks": []
      },
      {
        "id": "50",
        "title": "Voice-based answer capture with AI grading (Exploratory)",
        "description": "Optional feature: user speaks answer aloud, speech-to-text converts to text, AI compares against expected answer. Research shows AI grading achieves QWK>0.93 for objective content but 70% disagreement on nuanced responses. Best for simple fact recall, not complex medical reasoning.",
        "details": "EVIDENCE BASE (from research):\n- AI grading accuracy varies by content type (MIT Sloan 2024, Flodén 2025)\n- Objective STEM content: QWK > 0.93 (highly accurate)\n- Nuanced/subjective content: 70.5% score differences vs human graders\n- Recommendation: 'AI best for formative feedback, not standalone grading'\n\nIMPLEMENTATION APPROACH:\n1. Use Web Speech API (browser-native, no external service) for speech-to-text\n2. AI comparison via existing ai-service.ts infrastructure\n3. Grading prompt: 'Compare user answer to expected answer. Rate semantic similarity 0-100. Flag if user missed key concepts.'\n4. Threshold: >80% similarity = recall successful, <50% = Again\n5. Show AI reasoning to user for transparency\n\nSCOPE LIMITATIONS:\n- ONLY enable for cards tagged 'objective-fact' or similar\n- Disable for cards with complex/nuanced answers\n- User can toggle feature on/off in settings\n- Store voice transcription for user review (privacy: local only)\n\nUSER FLOW:\n1. Card shown → User taps microphone icon (or hotkey)\n2. User speaks answer → STT converts to text\n3. Text shown to user for verification → User confirms or edits\n4. AI grades → Shows result with reasoning\n5. User can override if AI was wrong\n\nFILES TO CREATE/MODIFY:\n- src/components/review/VoiceCapture.tsx: New component for voice recording\n- electron/ai-service.ts: Add gradeVoiceAnswer() function\n- src/components/review/ReviewInterface.tsx: Integrate VoiceCapture\n- src/stores/useAppStore.ts: Add voiceModeEnabled setting",
        "testStrategy": "Test Web Speech API availability detection. Test transcription accuracy with sample medical terms. Test AI grading consistency across multiple attempts. Test user override flow. Verify privacy (no external transmission of voice). Test toggle on/off. Compare AI grades to human grades on test set.",
        "priority": "low",
        "status": "pending",
        "tags": [
          "exploratory"
        ],
        "dependencies": [
          "49"
        ],
        "subtasks": []
      },
      {
        "id": "51",
        "title": "AI Agent / Jarvis Mode for natural language card retrieval",
        "description": "Voice/text command interface to pull relevant flashcards using natural language. Example: 'Let's review ACLS protocol' → AI finds and queues all ACLS-related cards. Think Jarvis-style assistant for post-shift exhausted brain.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "status": "deferred",
        "tags": [
          "future",
          "ai-agent"
        ],
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": "52",
        "title": "Procedural Simulation Mode with equipment recall and sequential cloze",
        "description": "Interactive procedure review: User voices equipment needed (items appear in left panel as named), then walks through sequential cloze steps (right panel). Builds both equipment recall AND procedural memory in realistic simulation format.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "status": "deferred",
        "tags": [
          "future",
          "procedures",
          "simulation"
        ],
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": "53",
        "title": "Review UI: Refine manual grade button color contrast",
        "description": "Adjust manual grade button colors for better accessibility and visual clarity. Current dark colors have low contrast.",
        "priority": "low",
        "status": "deferred",
        "tags": [
          "ux",
          "polish"
        ],
        "dependencies": [
          "5"
        ],
        "subtasks": []
      },
      {
        "id": "54",
        "title": "Review UI: Show response time and auto-grade reasoning",
        "description": "Add visual indicator showing how auto-grade was determined (e.g., 'Recalled (12.3s)'). User can't tell why card was graded certain way.",
        "priority": "medium",
        "status": "deferred",
        "tags": [
          "ux",
          "transparency"
        ],
        "dependencies": [
          "5"
        ],
        "subtasks": []
      },
      {
        "id": "55",
        "title": "Review UI: Add first-time interactive tutorial",
        "description": "New users confused about Continue vs. manual buttons. Add guided tutorial explaining zero-decision flow and when to override.",
        "priority": "high",
        "status": "deferred",
        "tags": [
          "ux",
          "onboarding"
        ],
        "dependencies": [
          "5",
          "54"
        ],
        "subtasks": []
      },
      {
        "id": "56",
        "title": "Review UI: Hide manual grade buttons until answer shown",
        "description": "Manual grade buttons appear before answer revealed, which is confusing. Should only show after Space pressed.",
        "priority": "high",
        "status": "deferred",
        "tags": [
          "ux",
          "bug-fix"
        ],
        "dependencies": [
          "5"
        ],
        "subtasks": []
      },
      {
        "id": "57",
        "title": "Review UI: Add persistent back button in header",
        "description": "Add global '← Capture' button in header so user can exit review without scrolling to bottom.",
        "priority": "medium",
        "status": "deferred",
        "tags": [
          "ux",
          "navigation"
        ],
        "dependencies": [
          "5"
        ],
        "subtasks": []
      },
      {
        "id": "58",
        "title": "Main screen (Capture): Improve onboarding and discoverability",
        "description": "Capture screen feels empty. Add hero section, multi-input tabs, examples, recent activity. Make it feel like a proper home screen.",
        "priority": "high",
        "status": "deferred",
        "tags": [
          "ux",
          "onboarding"
        ],
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": "59",
        "title": "Capture UI: Auto-resize paste box based on content type",
        "description": "Paste box should adapt: single-line for quick text, multi-line for paragraphs, drop zone for PDFs/images.",
        "priority": "medium",
        "status": "deferred",
        "tags": [
          "ux",
          "smart-ui"
        ],
        "dependencies": [
          "58"
        ],
        "subtasks": []
      },
      {
        "id": "60",
        "title": "Quick Dump UI: Add explanation and visual distinction",
        "description": "Quick Dump is unclear. Add tooltip, visual design (lightning icon), and explanation of 'emergency capture' use case.",
        "priority": "medium",
        "status": "deferred",
        "tags": [
          "ux",
          "quick-dump"
        ],
        "dependencies": [
          "58"
        ],
        "subtasks": []
      },
      {
        "id": "61",
        "title": "Review UI: Add response time indicator in header",
        "description": "Show subtle timer in top-right (0-5s green, 5-15s blue, etc.) and/or expandable session stats panel.",
        "priority": "low",
        "status": "deferred",
        "tags": [
          "ux",
          "stats"
        ],
        "dependencies": [
          "5",
          "54",
          "57"
        ],
        "subtasks": []
      },
      {
        "id": "62",
        "title": "Capture UI: Clarify keyboard shortcuts and boost AI confidence",
        "description": "Remove confusing 'Tab to navigate, Space to toggle' hint. Replace with accurate shortcuts and better AI accuracy messaging.",
        "priority": "medium",
        "status": "deferred",
        "tags": [
          "ux",
          "onboarding"
        ],
        "dependencies": [
          "58"
        ],
        "subtasks": []
      },
      {
        "id": "71",
        "title": "Queue onboarding and guidance: explain what Queue is and how to access reviews",
        "description": "Users don't understand what the Queue view is or how it relates to reviews. Add onboarding explanation and UI guidance.",
        "status": "deferred",
        "priority": "medium",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "onboarding",
          "ux",
          "post-mvp",
          "queue"
        ]
      },
      {
        "id": "72",
        "title": "Undo functionality (Ctrl+Z) for edits and review grades",
        "description": "Implement global undo system allowing users to reverse recent actions, especially card edits and review grades.",
        "status": "deferred",
        "priority": "high",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "ux",
          "post-mvp",
          "undo",
          "quality-of-life"
        ]
      },
      {
        "id": "73",
        "title": "Anki import functionality (.apkg file support)",
        "description": "Allow users to import existing Anki decks (.apkg files) to migrate their medical flashcard collections into DougHub.",
        "status": "deferred",
        "priority": "critical",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "import",
          "anki",
          "migration",
          "critical",
          "post-mvp"
        ]
      },
      {
        "id": "74",
        "title": "Keyboard shortcut reference overlay (Ctrl+? or F1)",
        "description": "Global keyboard shortcut help overlay showing all available shortcuts, context-sensitive to current view.",
        "status": "deferred",
        "priority": "medium",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "ux",
          "keyboard",
          "shortcuts",
          "post-mvp",
          "onboarding"
        ]
      },
      {
        "id": "75",
        "title": "Statistics and analytics dashboard (FSRS metrics, retention, weak topics)",
        "description": "Comprehensive analytics view showing learning progress, FSRS metrics, retention curves, and performance insights.",
        "status": "deferred",
        "priority": "high",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "analytics",
          "stats",
          "fsrs",
          "post-mvp",
          "retention"
        ]
      },
      {
        "id": "76",
        "title": "Tag management UI (create, rename, merge, delete tags manually)",
        "description": "Interface for manual tag management, separate from AI auto-suggestions. Allow users to organize, clean up, and maintain their tag taxonomy.",
        "status": "deferred",
        "priority": "medium",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "tags",
          "management",
          "ux",
          "post-mvp",
          "organization"
        ]
      },
      {
        "id": "77",
        "title": "Capture textarea auto-resize based on content length",
        "description": "Make the paste/input textarea dynamically resize based on content, eliminating need to scroll within small box.",
        "status": "deferred",
        "priority": "medium",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "ux",
          "capture",
          "textarea",
          "post-mvp",
          "polish"
        ]
      },
      {
        "id": "78",
        "title": "Capture page UX redesign: better 'dump it here, I'll organize' messaging",
        "description": "Redesign Capture page to clearly convey 'paste anything, AI will organize it' workflow. Currently feels empty and unclear.",
        "status": "deferred",
        "priority": "high",
        "dependencies": [],
        "details": "",
        "testStrategy": "",
        "subtasks": [],
        "tags": [
          "ux",
          "capture",
          "onboarding",
          "post-mvp",
          "redesign"
        ]
      },
      {
        "id": "79",
        "title": "Implement Superhuman-style split view for Notebook",
        "description": "Create a master-detail layout for the Notebook view with a narrow topic list (~280px) on the left and content display on the right, including resizable divider, search/filter, smooth transitions, and keyboard navigation",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:02:11.895Z"
      },
      {
        "id": "80",
        "title": "Add Notion-style breadcrumb navigation",
        "description": "Implement dynamic breadcrumb trail in content area header showing current location (e.g., 'Capture > New Note', 'Review > Cardiology') with clickable segments, truncation for long paths, and subtle styling",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          "79"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:02:11.900Z"
      },
      {
        "id": "81",
        "title": "Add Things 3 today badge pulse animation",
        "description": "Implement subtle pulse animation for the Today count badge in sidebar when due cards exist (due > 0), respecting prefers-reduced-motion, and stopping after user interaction",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "79"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:02:11.904Z"
      },
      {
        "id": "82",
        "title": "Implement Browser Extension with Local HTTP API for Web Content Capture",
        "description": "Create a browser extension (Chrome/Firefox) with local HTTP API server in Electron main process to enable direct web content capture into DougHub's Knowledge Bank inbox",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T02:17:22.219Z"
      },
      {
        "id": "83",
        "title": "OCR Image Text Search Integration",
        "description": "Extract text from images using Tesseract.js and index in SQLite FTS5 for full-text search",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:02:38.830Z"
      },
      {
        "id": "84",
        "title": "Video/Audio Transcription Search with Whisper",
        "description": "Transcribe video and audio content using Whisper API/local model for searchable text index",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          "83"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:02:38.835Z"
      },
      {
        "id": "85",
        "title": "Voice Search Interface (Web Speech API)",
        "description": "Implement voice-to-text search using Web Speech API for hands-free query input",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "83"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:02:38.839Z"
      },
      {
        "id": "86",
        "title": "Semantic Intent Search with Local Embeddings",
        "description": "Implement AI-powered semantic search using Ollama embeddings for intent-based querying beyond keyword matching",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          "83"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:02:38.843Z"
      },
      {
        "id": "87",
        "title": "Context-Aware Search Suggestions",
        "description": "AI-powered search suggestions like 'Cards comparing X and Y' based on user study patterns and context",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "83",
          "86"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:02:38.847Z"
      },
      {
        "id": "88",
        "title": "Add Vision API Support with Camera/Webcam Capture",
        "description": "Extend QuickDumpModal with camera/webcam capture and integrate multimodal AI vision analysis for images with text context",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:07:32.984Z"
      },
      {
        "id": "89",
        "title": "Design and Implement Unified Capture Pathway UX",
        "description": "Audit and redesign capture UX to clearly guide users through three pathways: Quick Dump → Inbox, Main Page → Extract Concepts, and Learning Pipeline with visual cues and progressive disclosure",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:07:32.989Z"
      },
      {
        "id": "90",
        "title": "Enhance AI Service for Image Context Understanding",
        "description": "Extend AI service to accept multimodal inputs (image + text) and generate appropriate card formats based on image type (diagrams → cloze, algorithms → vignettes)",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          "88"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:07:32.993Z"
      },
      {
        "id": "91",
        "title": "Debug and Fix Ollama AI Extraction Pipeline",
        "description": "Troubleshoot and resolve AI extraction issues with Ollama integration, focusing on JSON parsing, model compatibility, and response handling in the extractConcepts() function",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-06T04:58:26.652Z"
      },
      {
        "id": "92",
        "title": "Expand medical acronym database with open-source dataset",
        "description": "Replace 137-entry acronym list with comprehensive dataset (~2000 entries) from imantsm/medical_abbreviations GitHub repo. Improves search recall for medical terminology.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T05:15:00.000Z"
      },
      {
        "id": "93",
        "title": "Close Ollama on app close",
        "description": "Gracefully terminate the Ollama process when Electron app closes, if it was auto-started by DougHub. Track spawned process PID and kill on app quit event.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["17"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:00:00.000Z"
      },
      {
        "id": "94",
        "title": "[Learning Mode] Post-practice review trigger with Quick/Deep mode choice",
        "description": "After practice questions, show contextual prompt offering Quick Review (5min) or Deep Study (15min) modes. Queue items for later via Learning Inbox sidebar badge.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "95",
        "title": "[Learning Mode] 3-button confidence rating UI (Forgot/Struggled/Knew It)",
        "description": "Simple post-answer metacognitive signal capture. Replace complex confidence scales with 3 buttons that map to scheduling adjustments.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["94"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "96",
        "title": "[Learning Mode] Elaborated feedback with why-right and why-wrong explanations",
        "description": "Show detailed explanations for every answer option (correct and incorrect). Link explanations to source material. Essential for learning (d=0.48-0.73).",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["94"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "97",
        "title": "[Learning Mode] Adaptive gating logic based on confidence + correctness",
        "description": "Route cards through different pipeline steps based on performance. Correct+confident=quick path, incorrect+confident=overconfidence intervention, repeated errors=full pipeline.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["95", "96"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "98",
        "title": "[Learning Mode] Discrimination training for similar/confusable concepts",
        "description": "When user confuses similar conditions, show compare/contrast with discriminating features. Triggered selectively for commonly confused medical concepts (g=0.42-0.67).",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["97"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "99",
        "title": "[Learning Mode] Transfer practice with single-variable variants",
        "description": "Generate 2-3 variant questions that test same concept in different contexts. Light interleaving for application skills (d=0.40-0.66).",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["97"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "100",
        "title": "[Learning Mode] Response time tracking as implicit confidence signal",
        "description": "Track answer latency automatically. <3s = strong recall, >10s = struggle. Use to weight scheduling without adding UI friction.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["94"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "101",
        "title": "[Learning Mode] Confidence-weighted FSRS scheduling adjustments",
        "description": "Multiply FSRS intervals by confidence factor. High confidence + correct = 1.5x, high confidence + incorrect = 0.5x penalty, low confidence + correct = 1.0x.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["95", "100"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "102",
        "title": "[Learning Mode] Pre-test diagnostic for topic skip decisions",
        "description": "Before generating cards for a topic, present 5-10 diagnostic questions. >80% accuracy = skip card generation. <50% = full pipeline.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "103",
        "title": "[Learning Mode] Illness Script template for medical content consolidation",
        "description": "Scaffolded summary template: Enabling conditions, Pathophysiological fault, Clinical consequences, Management. Auto-populate from question content.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["96"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "104",
        "title": "[Learning Mode] Confusion alert for similar-term answers",
        "description": "When user enters answer matching a different term in study set, show: 'Careful—you answered X, but that's the answer for Y.' Discrimination feedback.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["98"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "105",
        "title": "[Learning Mode] Session fatigue detection with break suggestions",
        "description": "Track accuracy within session. If drops 20%+ from start, suggest break. After 20min, gentle prompt to continue or rest. Never force-end.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["94"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "106",
        "title": "[Learning Mode] Progress bar UI (thin, top of screen, Duolingo-style)",
        "description": "Simple horizontal progress bar showing session completion. Unobtrusive but motivating. Core UX element.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": ["94"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "107",
        "title": "[Learning Mode] Card maturity tracking and exam readiness indicator",
        "description": "Surface card maturity as exam readiness proxy. Show '75% of cardiology cards have reached stable retention.' Motivational dashboard element.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "108",
        "title": "[Gamification] Daily streak with visual indicator",
        "description": "Track consecutive study days. Visual streak counter. Part of full gamification phase.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "109",
        "title": "[Gamification] XP system with session summaries",
        "description": "Award XP for completed reviews. Show session summary with XP earned. Progress toward daily goals.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": ["108"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      },
      {
        "id": "110",
        "title": "[Gamification] Review heatmap (GitHub-style activity calendar)",
        "description": "Visual calendar showing study activity intensity by day. Motivational pattern recognition.",
        "details": "",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-06T06:30:00.000Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-06T05:29:32.390Z",
      "taskCount": 84,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}